<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<script>/*<![CDATA[*/
var _$ = {
	nowPage: {
		id: [0,1,0,0,0],
		title: 'Node.js', // Home | mNote
		pageType: 'sub',
		layoutType: 'sub'
	}
};
/*]]>*/</script>
<script src="../../share/inc/html_head.js"></script>
</head>
<body>
<script src="../../share/inc/all_header.js"></script>





<h1 class="hb1 h1">Node.js</h1>


<!-- mtab1 -->
<div class="mtab1">
<menu>
<li>
	<a href="#NodeJS">Node.js (( PoiemaWeb</a>
	<ul>
	<li><a href="#h3-01">1 Node.js Basics</a></li>
	<li><a href="#h3-02">2 Node.js & npm</a></li>
	<li><a href="#h3-03">3 Node.js module</a></li>
	<li><a href="#h3-04">4 Node.js file upload example</a></li>
	<li><a href="#h3-05">5 Node.js에서 비밀 설정 정보(Secrets) 관리</a></li>
	</ul>
</li>
<li><a href="#NodeJS-BasicUse">Node.js 기본 사용법 (( PYRASIS.COM</a></li>
<li><a href="#Link">Reference Link</a></li>
</menu>
</div><!-- /mtab1 -->
<!-- mtab1 -->
<div class="mtab1">
<menu>
<li><a href="Express.html">Express</a></li>
<li><a href="MongoDB.html">MongoDB</a></li>
<li><a href="TypeScript.html">TypeScript</a></li>
</menu>
</div><!-- /mtab1 -->


<!-- ◇◆◇◆◇◆◇◆◇◆ -->
<h2 class="hb1 h2" id="NodeJS">Node.js (( <a href="https://poiemaweb.com/nodejs-basics" target="_blank" rel="noopener" title="새 창" class="a1">PoiemaWeb</a></h2>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-01">1 Node.js Basics :: 네트워크 애플리케이션을 위한 자바스크립트 런타임 환경</h3>


<h4 class="hb1 h4">1. Introduction</h4>
<h4 class="hb1 h4">2. Install</h4>

<p>Node.js를 설치하기 위해 <a href="https://nodejs.org/">Node.js의 웹사이트(http://nodejs.org)</a>에 접속해 보자.</p>

<pre class="mg0">
<code class="xmp">
$ node -v
v10.15.1
$ npm -v
6.4.1
</code>
</pre>

<h4 class="hb1 h4">3. Update</h4>

<h5 class="hb1 h5">3.1 Node.js</h5>

<pre class="mg0">
<code class="xmp">
$ npm install -g n
</code>
</pre>

<pre class="mg0">
<code class="xmp">
$ npm cache clean -f
npm WARN using --force I sure hope you know what you are doing.
</code>
</pre>

<pre class="mg0">
<code class="xmp">
$ n 10.0.0  # 버전 지정 설치
$ n lts     # 최신 LTS 버전 설치
$ n stable  # stable 버전 설치
$ n latest  # 최신 currunt 버전 설치
</code>
</pre>

<pre class="mg0">
<code class="xmp">
$ node -v
v10.15.1
$ n latest # sudo n latest
$ n
    node/10.15.1
  ο node/11.10.0
$ node -v
v11.10.0
</code>
</pre>

<pre class="mg0">
<code class="xmp">
$ n rm 10.15.1  # 버전 지정 삭제
$ n - 10.15.1   # rm 대신 -를 사용할 수 있다
$ n prune       # 현재 사용중인 버전을 제외한 나머지를 일괄 삭제
</code>
</pre>


<h5 class="hb1 h5">3.2 npm</h5>

<pre class="mg0">
<code class="xmp">
$ npm install -g npm@latest
$ npm -v
6.8.0
</code>
</pre>

<h4 class="hb1 h4">4. REPL</h4>

<pre class="mg0">
<code class="xmp">
$ node
</code>
</pre>

<p>
	객체 이름과 마침표를 입력하고 탭키를 입력하면 객체의 프로퍼티를 확인할 수도 있다.
</p>

<pre class="mg0">
<code class="xmp">
> Object.
</code>
</pre>

<p>
	CTRL + C 키를 두번 실행하면 REPL을 종료시킨다. 
</p>


<h4 class="hb1 h4">5. Node.js 맛보기 : HTTP Server</h4>


<pre class="mg0">
<code class="xmp">
// app.js
const http = require('http'); // 1

http.createServer((request, response) => { // 2
  response.statusCode = 200;
  response.setHeader('Content-Type', 'text/plain');
  response.end('Hello World');
}).listen(3000); // 3

console.log('Server running at http://127.0.0.1:3000/');
</code>
</pre>

<pre class="mg0">
<code class="xmp">
$ node app.js
</code>
</pre>

<p>
	위 명령을 실행하고 브라우저에서 “http://localhost:3000” 에 접속하면 “Hello World”가 출력되는 것을 확인할 수 있다.
</p>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-02">2 Node.js & npm :: 모듈화와 npm(node package manager)</h3>

<h4 class="hb1 h4">1. 모듈화와 CommonJS</h4>

<p>
	C언어는 #include, Java는 import 등 대부분의 언어는 모듈 기능을 가지고 있다.
	하지만 <b class="em0">Client-side JavaScript</b>의 경우, script 태그를 사용하여 외부의 스크립트 파일을 가져올 수는 있지만
	<em class="em">파일마다 독립적인 파일 Scope를 갖지 않고 하나의 전역 객체(Global Object)에 바인딩</em>되기 때문에
	전역변수가 중복되는 등의 문제가 발생할 수 있다. 이것으로는 모듈화를 구현할 수 없다.
</p>

<p>
	<b class="em0">CommonJS</b> 방식은 AMD에 비해 문법이 간단하며 동기 방식(synchronous loading)으로 동작한다.
	<b class="em0">AMD</b> 방식은 CommonJS에 비해 문법이 다소 까다로우며 CommonJS와는 달리 비동기 방식(asynchronous loading)으로 동작한다. AMD 방식을 지원하는 대표적인 모듈 로더는 <b class="em0">RequireJS</b>이다.
</p>

<p>
	Node.js는 사실상 모듈 시스템의 사실상 표준(de facto standard)인 CommonJS를 채택하였고
	현재는 독자적인 진화를 거쳐 CommonJS 사양과 100% 동일하지는 않지만 기본적으로 CommonJS 방식을 따르고 있다.
</p>

<p>
	브라우저에서의 모듈 사용은 대부분의 브라우저가 ES6의 모듈을 지원하지 않고 있으므로
	<b class="em0">Browserify</b> 또는 <b class="em0">webpack</b>과 같은 모듈 번들러를 사용하여야 한다.
</p>


<h4 class="hb1 h4">2. npm</h4>

<p>
	<b class="em0">npm(node package manager)</b>은 자바스크립트 패키지 매니저이다.
	Node.js에서 사용할 수 있는 모듈들을 패키지화하여 모아둔 저장소 역할과 패키지 설치 및 관리를 위한 <b class="em0">CLI</b>(Command line interface)를 제공한다.
	자신이 작성한 패키지를 공개할 수도 있고 필요한 패키지를 검색하여 재사용할 수도 있다.
</p>

<h5 class="hb1 h5">2.1 패키지 설치</h5>

<pre class="mg0">
<code class="xmp">
$ <b class="em">npm install</b> &lt;package&gt;
</code>
</pre>

<pre class="mg0">
<code class="xmp">
$ mkdir emoji && cd emoji
</code>
</pre>

<pre class="mg0">
<code class="xmp">
$ npm install node-emoji
</code>
</pre>

<h5 class="hb1 h5">2.2 지역 설치와 전역 설치</h5>

<p>
	<b class="em0">npm install</b> 명령어에는 지역(local) 설치와 전역(global) 설치 옵션이 있다.
	옵션을 별도로 지정하지 않으면 지역으로 설치되며, 프로젝트 루트 디렉터리에 <b class="em0">node_modules</b> 디렉터리가 자동 생성되고 그 안에 패키지가 설치된다.
	지역으로 설치된 패키지는 해당 프로젝트 내에서만 사용할 수 있다.
</p>

<pre class="mg0">
<code class="xmp">
# 지역 설치
$ npm install &lt;package&gt;

# 전역 설치
$ npm install <b class="em">-g</b> &lt;package&gt;
</code>
</pre>

<p>
	전역에 설치된 패키지는 OS에 따라 설치 장소가 다르다.
</p>

<ul class="bu">
<li>
	macOS의 경우
	/usr/local/lib/node_modules
</li>
<li>
	윈도우의 경우
	c:\Users\%USERNAME%\AppData\Roaming\npm\node_modules
</li>
</ul>

<p>
	node 명령어로 Node.js REPL을 실행하고 node-emoji를 로드한 후 emoji를 출력해 보자.
</p>

<pre class="mg0">
<code class="xmp">
$ node
Welcome to Node.js v12.3.1.
Type ".help" for more information.
> const emoji = require('node-emoji').emoji;
undefined
> console.log(emoji.heart);
❤️
undefined
</code>
</pre>

@m.TT) cmd 화면에서 해보니.. 나오는거 같긴 한다. 눈에 안보님


<h5 class="hb1 h5">2.3 package.json과 의존성 관리</h5>

<p>
	<b class="em0">package.json</b>을 생성하려면 프로젝트 루트에서 <code>npm init</code> 명령어를 실행한다.
</p>

<pre class="mg0">
<code class="xmp">
$ npm init
</code>
</pre>

<p>
	npm init 명령어에 <code>--yes</code> 또는 <code>-y</code> 옵션을 추가한다. 그러면 기본 설정값으로 package.json 파일을 생성한다.
</p>

<pre class="mg0">
<code class="xmp">
$ <b class="em">npm init <em class="em4">-y</em></b>
Wrote to /Users/leeungmo/Desktop/emoji/package.json:

{
  "name": "emoji",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "dependencies": {
    "node-emoji": "^1.10.0"
  },
  "devDependencies": {},
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}
</code>
</pre>

<dl class="b0">
</dl>


<dl class="fixed1auto1 tp1">
<dt><b class="em4">name</b>과 <b class="em4">version</b></dt>
<dd>이것으로 패키지의 고유성을 판단하므로 생략할 수 없다. </dd>
<dt><b class="em4">dependencies</b></dt>
<dd>해당 프로젝트가 의존하는 패키지들의 이름과 버전을 명시. 여기서 의존하는 패키지란 해당 프로젝트에서 참조하는 모듈을 의미한다.</dd>
<dt><b class="em4">devDependencies</b></dt>
<dd>개발 시에만 사용하는 개발용 의존 패키지를 명시한다. 예를 들어 TypeScript와 같은 트랜스파일러는 개발 단계에서만 필요하고 배포할 필요는 없으므로 devDependencies에 포함시킨다.</dd>
</dl>

<p>
	npm install 명령어에 <code>--save</code> 옵션을 사용하면 패키지 설치와 함께 package.json의 dependencies에 설치된 패키지 이름과 버전이 기록된다.
</p>

<pre class="mg0">
<code class="xmp">
$ npm install --save node-emoji
</code>
</pre>

<p class="pd1em-rv bg-info">
	npm@5부터 --save는 기본 옵션이 되었다.<br />
	--save 옵션을 사용하지 않더라도 모든 install 명령은 package.json의 dependencies에 설치된 패키지와 버전을 기록한다.<br />
	기존의 --save-dev은 변경되지 않았다.<br />
</p>

<p>
	npm install 명령어에 <code>--save-dev</code>(축약형 -D) 옵션을 사용하면 패키지 설치와 함께 package.json의 devDependencies에 설치된 패키지와 버전이 기록된다.
</p>

<pre class="mg0">
<code class="xmp">
$ npm install --save-dev &lt;package&gt;
</code>
</pre>

<p>
	npm install 명령어를 사용하면 package.json에 명시된 모든 의존 패키지를 한번에 설치할 수 있다.
</p>

<pre class="mg0">
<code class="xmp">
$ <b class="em">npm install</b>
</code>
</pre>


<h5 class="hb1 h5">2.4 Semantic versioning(유의적 버전)</h5>

<p>
	npm install 명령어의 패키명 뒤에 <code>@버전</code>을 추가하면 패키지 버전을 지정하여 설치할 수 있다.
</p>

<pre class="mg0">
<code class="xmp">
$ npm install node-emoji@1.5.0
</code>
</pre>

<pre class="mg0">
<code class="xmp">
...
  "dependencies": {
    "node-emoji": "^1.5.0"
  },
...
</code>
</pre>

이때 <b class="em0">package.json</b>의 dependencies에 새롭게 추가한 패키지가 추가되고 버전 앞에 <code>^</code>(캐럿)이 추가된 것을 확인할 수 있다.
이것은 패키지 버전을 지정하였을 때 뿐만이 아니라 <code>--save-exact</code> 옵션을 지정하지 않으면 기본적으로 추가되는 것이다.
이 <code>^</code>(캐럿)은 이후 해당 패키지의 버전이 업데이트되었을 경우, 마이너 버전 범위 내에서 업데이트를 허용한다는 의미이다.

<p class="pd1em-rv bg-info">
	npm install 명령어에 <code>--save-exact</code> 옵션을 지정하면 설치된 버전을 범위 지정없이 기록한다.
</p>


<h5 class="hb1 h5">2.5 자주 사용하는 npm 명령어</h5>

<h6 class="hb1 h6">package.json 생성</h6>

<pre class="mg0">
<code class="xmp">
$ npm init
# 기본 설정
$ npm init -y
</code>
</pre>

<h6 class="hb1 h6">패키지 설치</h6>

<pre class="mg0">
<code class="xmp">
# 로컬 설치
$ npm install <package-name>
# 전역 설치
$ npm install -g <package-name>
# 개발 설치
$ npm install --save-dev <package-name>
# package.json의 모든 패키지 설치
$ npm install
</code>
</pre>

<h6 class="hb1 h6">패키지 제거</h6>

<pre class="mg0">
<code class="xmp">
# 로컬/개발 패키지 제거
$ npm uninstall <package-name>
# 전역 패키지 제거
$ npm uninstall -g <package-name>
</code>
</pre>

<h6 class="hb1 h6">패키지 업데이트</h6>

<pre class="mg0">
<code class="xmp">
$ npm update <package-name>
</code>
</pre>

<h6 class="hb1 h6">전역 설치 패키지 확인</h6>

<pre class="mg0">
<code class="xmp">
$ npm ls -g --depth=0
</code>
</pre>

<h6 class="hb1 h6">package.json scripts 프로퍼티의 start 실행</h6>

<pre class="mg0">
<code class="xmp">
$ npm start
</code>
</pre>

<h6 class="hb1 h6">package.json scripts 프로퍼티의 start 이외의 scripts 실행</h6>

<pre class="mg0">
<code class="xmp">
$ npm run &lt;script-name&gt;
</code>
</pre>

<h6 class="hb1 h6">전역 패키지 설치 폴더 확인</h6>

<pre class="mg0">
<code class="xmp">
$ npm root -g
/usr/local/lib/node_modules
# 파인더 오픈
$ open /usr/local/lib/node_modules
</code>
</pre>

<h6 class="hb1 h6">패키지 정보 참조</h6>

<pre class="mg0">
<code class="xmp">
$ npm view &lt;package-name&gt;
</code>
</pre>

<xmp class="xmp">
# react-create-app 패키지 정보 확인
$ npm view react-create-app

react-create-app@2.0.6 | MIT | deps: 19 | versions: 19
This helper exports a function returning a ready-to-use React App component with the following: - react-router-redux - history - redux-persist

dist
.tarball: https://registry.npmjs.org/react-create-app/-/react-create-app-2.0.6.tgz
.shasum: 88b10bc9a53e58a8b08b7a4cdf8cd6b21f8113fe
.integrity: sha512-YT8WiWx9wuJFM35EyW/Z9R/75MYj3hW9DsT7f1Dj6M3bdTRnWOocOh9r4HkM5OKFQDzZwTvyQrzITTEn6JxCqg==

dependencies:
babel-eslint: 7.2.3
babel-jest: 20.0.3
babel-loader: 7.1.2
babel-plugin-transform-class-properties: 6.24.1
babel-plugin-transform-decorators-legacy: 1.3.4
babel-preset-env: next
babel-preset-react: 6.24.1
babel-preset-stage-0: 6.24.1
eslint-loader: 1.9.0
eslint-plugin-import: 2.7.0
eslint-plugin-jest: 20.0.3
eslint-plugin-react: 7.3.0
eslint: 4.5.0
prop-types: 15.5.10
react-redux: 5.0.6
react: 15.6.1
redux-persist-crosstab: 3.6.0
redux-persist: 4.9.1
redux: 3.7.2

maintainers:
- damianobarbati <damiano@mvpbld.com>

dist-tags:
latest: 2.0.6

published over a year ago by damianobarbati <damiano@mvpbld.com>
</xmp>

<pre class="mg0">
<code class="xmp">
# eslint-config-airbnb와 함께 설치해야 하는 다른 패키지 확인
$ npm view eslint-config-airbnb@latest peerDependencies

{
  eslint: '^5.16.0 || ^6.1.0',
  'eslint-plugin-import': '^2.18.2',
  'eslint-plugin-jsx-a11y': '^6.2.3',
  'eslint-plugin-react': '^7.14.3',
  'eslint-plugin-react-hooks': '^1.7.0'
}
</code>
</pre>

<h6 class="hb1 h6">버전 확인</h6>

<pre class="mg0">
<code class="xmp">
$ npm -v
</code>
</pre>

<h6 class="hb1 h6">npm 명령어 설명 참조</h6>

<pre class="mg0">
<code class="xmp">
$ npm help &lt;command&gt;
</code>
</pre>

<p>
	npm 명령어에 대한 자세한 설명은 npm CLI 명령어을 참조하기 바란다.
</p>


<h4 class="hb1 h4">Reference</h4>


<ul class="bu">
  <li>
    <a href="http://www.commonjs.org/">CommonJS</a>
  </li>
  <li>
    <a href="https://www.npmjs.com/">npm</a>
  </li>
  <li>
    <a href="https://docs.npmjs.com/files/package.json">package.json</a>
  </li>
  <li>
    <a href="https://docs.npmjs.com/#cli">npm CLI 명령어</a>
  </li>
  <li>
    <a href="https://nodejs.github.io/nodejs-ko/articles/2016/06/09/es-modules-and-node-js-hard-choices/">ES Modules와 Node.js: 쉽지 않은 선택</a>
  </li>
</ul>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-03">3 Node.js module :: Node.js의 module loading system</h3>

<h4 class="hb1 h4">1. Node.js 모듈</h4>

<p>
	Node.js는 module 단위로 각 기능을 분할할 수 있다.
	module은 파일과 1대1의 대응 관계를 가지며 하나의 모듈은 자신만의 독립적인 실행 영역(Scope)를 가지게 된다.]
	따라서 클라이언트 사이드 JavaScript와는 달리 전역변수의 중복 문제가 발생하지 않는다.
</p>

<p>
	모듈은 <b class="em0">module.exports</b> 또는 <b class="em0">exports</b> 객체를 통해 정의하고 외부로 공개한다.
	그리고 공개된 모듈은 <b class="em0">require</b> 함수를 사용하여 임포트한다.
</p>

<h4 class="hb1 h4">2. exports</h4>

모듈은 독립적인 파일 스코프를 갖기 때문에 모듈 안에 선언한 모든 것들은 기본적으로 해당 모듈 내부에서만 참조 가능하다.
만약 모듈 안에 선언한 항목을 외부에 공개하여 다른 모듈들이 사용할 수 있게 하고 싶다면 exports 객체를 사용해야 한다.

모듈을 파일로 작성하고 외부에 공개할 대상을 <code>exports</code> 객체의 프로퍼티 또는 메소드를 정의한다.
그리고 모듈을 전역 함수 <code>require()</code>를 이용하여 추출한다.


<pre class="mg0">
<code class="xmp">
// circle.js
const { PI } = Math;
<em class="em">exports</em>.area = (r) => PI * r * r;
<em class="em">exports</em>.circumference = (r) => 2 * PI * r;
</code>
</pre>

<p>
	circle.js는 독립적인 파일 스코프를 갖는 모듈이다.
	circle 모듈에서 area와 circumference를 exports 객체의 메소드로 정의하였다.
	변수 PI는 circle 모듈에서만 유효한 private 변수가 되고, area와 circumference는 외부에 공개된다.
</p>

<p>
	require 함수를 사용하여 임의의 이름으로 circle 모듈을 import한다.
	모듈의 확장자는 생략할 수 있다.
</p>

<pre class="mg0">
<code class="xmp">
// app.js
const circle = <em class="em">require</em>('./circle.js'); // == require('./circle')

console.log('지름이 4인 원의 면적: ${circle.area(4)}');
console.log('지름이 4인 원의 둘레: ${circle.circumference(4)}');
</code>
</pre>

<p>
	이때 circle 모듈은 객체로 반환된다.
	따라서 circle.area, circle.circumference와 같은 형식으로 공개된 circle 모듈을 참조한다.
	app.js를 실행해 보자.
</p>

<pre class="mg0">
<code class="xmp">
$ node app
지름이 4인 원의 면적: 50.26548245743669
지름이 4인 원의 둘레: 25.132741228718345
</code>
</pre>


<h4 class="hb1 h4">3. module.exports</h4>

<p>
	exports 객체는 프로퍼티 또는 메소드를 여러 개 정의할 수 있었다.
	하지만 module.exports에는 하나의 값(원시 타입, 함수, 객체)을 할당할 수 있다.
</p>

<pre class="mg0">
<code class="xmp">
// circle.js
const { PI } = Math;

module.exports = function (r) {
  return {
    area() { return PI * r * r; },
    circumference() { return 2 * PI * r}
  };
circle 모듈의 module.exports에는 하나의 함수를 할당하였다.
</code>
</pre>

<pre class="mg0">
<code class="xmp">
// app.js
const circle = require('./circle');
const myCircle = circle(4);

console.log(`지름이 4인 원의 면적: ${myCircle.area()}`);
console.log(`지름이 4인 원의 둘레: ${myCircle.circumference()}`);
</code>
</pre>

<p>
	require 함수를 통해 circle 모듈을 임포트하여 circle 변수에 할당하였다.
	이때 circle 변수는 circle 모듈에서 module.exports에 할당한 값 자체 즉 객체를 반환하는 함수이다.
</p>

<pre class="mg0">
<code class="xmp">
// primitive.js
const pv = 'primitive value';
module.exports = pv;
</code>
</pre>

<pre class="mg0">
<code class="xmp">
// app.js
const value = require('./primitive');
console.log(value); // => 'primitive value'
</code>
</pre>

<p>
	exports와 module.exports는 혼동하기 쉽다.
	exports는 module.exports에의 참조이며 module.exports의 alias이다.
	즉, exports는 module.exports와 같다고 보아도 무방하다.
</p>


<table class="t3 w100">
	<thead>
	<tr>
	<th>구분</th>
	<th>모듈 정의 방식</th>
	<th>require 함수의 호출 결과</th>
	</tr>
	</thead>
	<tbody>
	<tr>
	<th scope="row"><b class="em4">exports</b></th>
	<td>exports 객체에는 값을 할당할 수 없고 공개할 대상을 exports 객체에 프로퍼티 또는 메소드로 추가한다.</td>
	<td>exports 객체에 추가한 프로퍼티와 메소드가 담긴 객체가 전달된다.</td>
	</tr>
	<tr>
	<th scope="row"><b class="em4">module.exports</b></th>
	<td>module.exports 객체에 하나의 값(원시 타입, 함수, 객체)만을 할당한다.</td>
	<td>module.exports 객체에 할당한 값이 전달된다.</td>
	</tr>
	</tbody>
	</table>



<h5 class="hb1 h5">3.1 module.exports에 함수를 할당하는 방식</h5>
<h5 class="hb1 h5">3.2 exports에 객체를 할당하는 방식</h5>

<h4 class="hb1 h4">4. require</h4>

<p>
	require 함수의 인수에는 파일뿐만 아니라 디렉터리를 지정할 수도 있다. 예를 들어 다음과 같은 디렉터리 구조의 경우를 살펴보자.
</p>

<pre class="mg0 pd1em lhD bgce">
project/
├── app.js
└── module/
    ├── index.js
    ├── calc.js
    └── print.js
</pre>

<p>
	아래과 같이 모듈을 명시하지 않고 <em class="em">require 함수로 디렉터리를 지정하면 해당 디렉터리의 index.js을 로드</em>한다.
</p>

<pre class="mg0">
<code class="xmp">
const myModule = require('./module');
</code>
</pre>

<p>
	이때 로드되는 <em class="em">index.js 내에서 calc.js과 print.js를 require하면</em> 한번의 require로 alc.js과 print.js의 모든 기능을 사용할 수 있다.
</p>

<pre class="mg0">
<code class="xmp">
// module/index.js
module.exports = {
  calc: require('./calc'),
  print: require('./print')
};
</code>
</pre>

<pre class="mg0">
<code class="xmp">
// module/calc.js
module.exports = {
  add (v1, v2) { return v1 + v2 },
  minus (v1, v2) { return v1 - v2 }
};
</code>
</pre>

<pre class="mg0">
<code class="xmp">
// module/print.js
module.exports = {
  sayHello() { console.log('Hi!') }
};
</code>
</pre>

<pre class="mg0">
<code class="xmp">
// app.js
const myModule = require('./module');

// module/calc.js의 기능
const result = myModule.calc.add(1, 2);

console.log(result);

// module/print.js의 기능
myModule.print.sayHello();
</code>
</pre>


<h4 class="hb1 h4">5. 코어 모듈과 파일 모듈</h4>

<p>
	Node.js는 기본으로 포함하고 있는 모듈이 있다.
	이를 코어 모듈이라 한다.
	코어 모듈을 로딩할 때에는 패스를 명시하지 않아도 무방하다.
</p>

<pre class="mg0">
<code class="xmp">
const http = require('http');
</code>
</pre>

<p>
	npm을 통해 설치한 외부 패키지 또한 패스를 명시하지 않아도 무방하다.
</p>

<pre class="mg0">
<code class="xmp">
const mongoose = require('mongoose');
</code>
</pre>

<p>
	코어 모듈과 외부 패키지 이외는 모두 파일 모듈이다. 파일 모듈을 로딩할 때에는 패스를 명시하여야 한다.
</p>

<pre class="mg0">
<code class="xmp">
const foo = require('./lib/foo');
</code>
</pre>

<h4 class="hb1 h4">Reference</h4>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-04">4 Node.js file upload example</h3>

<p>
	Node.js는 Server-side Javascript이다.<br />
	즉, 백엔드에서 자바스크립트를 실행할 수 있게 한다.<br />
	또한 유용한 모듈을 내부에 탑재하고 있고 필요에 따라 <code>npm</code> 등을 사용하여 외부에서 필요한 모듈을 import하여 사용할 수 있어
	높은 생산성과 스피디한 개발을 가능케 해준다.<br />
	따라서 Node.js는 Server-side Javascript와 모듈(라이브러리)로 구성되어 있다고 말할 수 있다.<br />
</p>

<p>
	file upload 예제를 통해서 Node.js의 기본과 <b class="em0">Routing</b>, <b class="em0">모듈화</b>, <b class="em0">Request Handling</b> 등을 알아보자.
</p>


<h4 class="hb1 h4">Install</h4>

<a href="https://poiemaweb.com/nodejs-basics#install" target="_blank" rel="noopener" title="새 창" class="a1">Node.js의 설치</a>

<h4 class="hb1 h4">Hello World</h4>

동작 확인

<h4 class="hb1 h4">Use cases</h4>

앞으로 구현해볼 예제의 use case는 아래와 같다.

<ul class="bu">
<li>사용자는 웹 브라우저로 이 웹 애플리케이션을 이용할 수 있다.</li>
<li>사용자가 <b class="em0">http://domain/start</b> 를 요청하면 파일 업로드 폼이 들어있는 웰컴 페이지를 볼 수 있어야 한다.</li>
<li>업로드할 이미지 파일을 선택해서 폼으로 전송하면, 해당 이미지는 <b class="em0">http://domain/upload</b> 로 업로드 되어야 하며, 업로드가 끝나면 해당 페이지에 표시된다.</li>
</ul>

<h4 class="hb1 h4">Appication Stack</h4>

<p>
	use case를 만족시키기 위해 구현되어야 할 기술적 사항은 아래와 같다.
</p>

<ul class="bu">
<li>
	웹페이지를 제공해야 한다.
	따라서 <b class="em0">HTTP 서버</b>가 필요하다.<br />
</li>
<li>
	서버는 URL 요청(<b class="em0">request</b>)별로 다르게 응답해야 한다.<br />
	따라서, 요청과 요청을 처리할 핸들러들을 연결짓기 위한 라우터(<b class="em0">router</b>) 같은 것이 필요하다.
</li>
<li>
	서버로 도착한 요청들, 그리고 라우터를 이용해서 라우팅된 요청들을 만족시키기 위해서
	실제적인 요청 핸들러(<b class="em0">request handler</b>)가 필요하다.
</li>
<li>
	라우터는 들어오는 어떠한 POST 데이터들도 다룰 수 있어야 한다.<br />
	그리고 해당 데이터를 다루기 편한 형태로 만들어 요청 핸들러(request handler) 들에게 넘겨야 한다.<br />
	따라서 요청 데이터 핸들링(<b class="em0">request data handling</b>)이 필요하다.<br />
</li>
<li>
	URL에 대한 요청을 다루는 것뿐 아니라 URL이 요청되었을 때 내용을 표시할 필요도 있다.<br />
	즉, 요청 핸들러(request handler)는 사용자 브라우저로 컨텐트를 보내기 위한한 뷰 로직(<b class="em0">view logic</b>)이 필요하다.
</li>
<li>
	사용자가 이미지들을 업로드 할 수 있어야 하므로
	세부 사항을 다루는 업로드 핸들링(<b class="em0">upload handling</b>)이 필요하다.
</li>
</ul>

<h4 class="hb1 h4">Building the application stack</h4>


<h5 class="hb1 h5">Basic HTTP server (기본 HTTP 서버)</h5>


<p>
	우선 HTTP server를 생성하기 위하여 <code>http</code> 모듈을 로드한다.
</p>
<p>
	<code>http.createServer([requestListener])</code>는 <code>http.Server</code>의 새로운 인스턴스를 반환한다.
	반환된 인스턴스의 메소드 <code>listen</code>을 호출하여 접속 대기를 시작한다.
</p>
<p>
	다음은 8888 포트를 Listen 하는 HTTP 서버를 시작한 다음 대기하는 코드이다.
	어떤 요청이 들어오더라도 HTTP 서버는 아무 일도 하지 않기 때문에 웹 브라우저는 대기상태에 빠지게 된다.
</p>

<pre class="mg0">
<code class="xmp">
// server.js

// Node.js에 기본 내장되어 있는 http 모듈을 로드한다
var http = require("http");

// http 모듈의 createServer 메소드를 호출하여 HTTP 서버 생성
var server = http.createServer();
server.listen(8888);
</code>
</pre>

<pre class="mg0">
<code class="xmp">
$ node server.js
</code>
</pre>

<p>
	요청이 발생 했을 때, 서버가 특정 동작을 수행하게 하려면 콜백함수를 지정하여야 한다.
	requestListener는 request event가 발생했을 때 자동 호출될 콜백 함수이다.
</p>

<pre class="mg0">
<code class="xmp">
// server.js

// Node.js에 기본 내장되어 있는 http 모듈을 로드한다
var http = require("http");

// http 모듈의 createServer 메소드를 호출하여 HTTP 서버 생성
http.createServer(function(request, response) {
  response.writeHead(200, {"Content-Type": "text/plain"}); // (1)
  response.write("Hello World");  // (2)
  response.end();                 // (3)
}).listen(8888);
</code>
</pre>

<pre class="mg0">
<code class="xmp">
$ node server.js
</code>
</pre>

<ul class="bu">
<li>(1) 요청(request)이 올 때마다 response.writeHead() 함수를 사용해서 HTTP status 200 과 content-type을 응답 헤더로 보내고,</li>
<li>(2) response.write()로 HTTP 응답 바디에 “Hello World” 텍스트를 담아 보낸다.</li>
<li>(3) 마지막으로 response.end()로 응답을 마무리한다.</li>
</ul>


<h5 class="hb1 h5">Event-driven callbacks (이벤트 중심 콜백)</h5>

<p>
	Node.js는 <b class="em0">event-driven</b>, <b class="em0">non-blocking I/O model</b>을 지원한다.
	자세한 사항은 아래의 포스트를 참조하기 바란다.
</p>

<ul class="bu">
<li><a href="http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb" target="_blank" rel="noopener" title="새 창" class="a1">Understanding node.js</a></li>
</ul>

<p>
	Javascript의 함수는 일급 객체이다.
</p>
<p>
	일급 객체(first-class object)란 생성, 대입, 연산, 인자 또는 반환값으로서의 전달 등, 프로그래밍언어의 기본적 조작을 제한없이 사용할 수 있는 대상을 의미한다.
</p>
<p>
	다음 조건을 만족하면 일급 객체로 간주한다.
</p>

<div class="panel1">
	<ol class="bo mgtb0">
	<li>무명의 리터럴로 표현이 가능하다.</li>
	<li>변수나 자료 구조(객체, 배열…)에 저장할 수 있다.</li>
	<li>함수의 파라미터로 전달 할 수 있다.</li>
	<li>반환값(return value)으로 사용할 수 있다.</li>
	</ol>
</div>


<pre class="mg0">
<code class="xmp">
// 1. 무명의 리터럴로 표현이 가능하다.
// 2. 변수나 데이터 구조안에 담을 수 있다.

var increase = function(num) {
  return num + 1;
};

var decrease = function(num){
  return num - 1;
};

var obj = {
  increase: increase,
  decrease: decrease
};

// 2. 함수의 파라미터로 전달 할 수 있다.
function cal(func, num){
  return func(num);
}

console.log(cal(increase, 1));
console.log(cal(decrease, 1));

// 3. 반환값(return value)으로 사용할 수 있다.
function cal(mode){
  var funcs = {
    'plus' : function(left, right){return left + right},
    'minus' : function(left, right){return left - right}
  }
  return funcs[mode];
}
console.log(cal('plus')(2,1));
console.log(cal('minus')(2,1));
</code>
</pre>

<p>
	Javascript의 함수는 위의 조건을 모두 만족하므로 Javascript의 함수는 일급객체이다.<br />
	따라서 Javascript의 함수는 흡사 변수와 같이 사용할 수 있으며 코드의 어디에서든지 정의할 수 있다.<br />
</p>
<p>
	함수와 다른 객체를 구분 짖는 특징은 호출할 수 있다는 것이다.<br />
</p>

<pre class="mg0">
<code class="xmp">
// server.js
var http = require("http");

// callback function
function onRequest(request, response) {
  console.log("Request received.");
  response.writeHead(200, {"Content-Type": "text/plain"});
  response.write("Hello World");
  response.end();
}

http.createServer(onRequest).listen(8888);

console.log("Server has started.");
</code>
</pre>

<p>
	HTTP 요청(비동기적 이벤트)이 발생하면 callback(onRequest)이 호출된다.<br />
	이 때 두 개의 파라미터 <code>reqeust</code>와 <code>response</code> 가 callback 함수 onRequest에 전달된다.<br />
	요청에 대한 처리를 callback에서 처리한다.<br />
</p>
<p>
	<em class="em">한번의 브라우저 요청에 “Request received.” 메시지가 두번</em> STDOUT으로 찍히는 것은<br />
	대부분의 브라우저가 http://localhost:8888/ 을 요청할 때 http://localhost:8888/favicon.ico 를 로드하려 하기 때문이다.<br />
</p>


<h5 class="hb1 h5">모듈화</h5>

<p>
	지금까지 작성한 HTTP 서버 생성 로직을 모듈화한다.<br />
	모듈화는 모듈을 필요로 하는 스크립트에 제공할 기능의 일부를 <code>export</code> 하는 것이다.<br />
	HTTP 서버 생성 로직을 함수에 담아 export한다.<br />
</p>

<pre class="mg0">
<code class="xmp">
// server.js
var http = require("http"); // node.js의 내부모듈

function start() {
  function onRequest(request, response) {
    console.log("Request received.");
    response.writeHead(200, {"Content-Type": "text/plain"});
    response.write("Hello World");
    response.end();
  }

  http.createServer(onRequest).listen(8888);
  console.log("Server has started.");
}

exports.start = start;
</code>
</pre>

<p>
	HTTP 서버 생성 모듈을 로드한다. 모듈을 로드하면 HTTP 서버 생성 함수을 담고 있는 객체가 반환된다.
</p>

<pre class="mg0">
<code class="xmp">
// index.js
var server = require("./server");

server.start();
</code>
</pre>

<pre class="mg0">
<code class="xmp">
$ node index.js
</code>
</pre>



<h5 class="hb1 h5">Routing (라우팅)</h5>

<p>
	요청 URL과 GET/POST 파라미터를 router로 전달하면 router는 어떤 코드를 실행할지 결정할 수 있어야 한다.
</p>
<p>
	즉, 전달된 요청 URL과 파라미터에 따라 서버의 할 일이 정해지는데 서버의 할 일을 수행하는 함수를 <b class="em0">request handler</b>라 한다.
</p>
<p>
	우선 요청 URL과 파라미터를 취득할 수 있어야 한다.
</p>

<pre class="mg0">
<code class="xmp">
// url & querystring modules

                        url.parse(string).query
                                        |
          url.parse(string).pathname    |
                        |               |
                        |               |
                      ----- -------------------
http://localhost:8888/start?foo=bar&hello=world
                                ---       -----
                                 |          |
                                 |          |
        querystring.parse(string)["foo"]    |
                                            |
                querystring.parse(string)["hello"]
</code>
</pre>

<p>
	우리에게 필요한 모든 정보는 request 객체(callback 함수 onRequest의 첫 번째 인자)를 통해 접근할 수 있다.<br />
	하지만 이 정보를 얻어내기 위해 <b class="em0">url</b>과 <b class="em0">querystring</b> 모듈이 추가로 필요하다.<br />
</p>
<p>
	<b class="em0">url</b> 모듈은 URL의 각각의 부분 (예를 들면 URL path와 query string)을 추출할 수 있는 메소드를 제공한다.
</p>
<p>
	<b class="em0">querystring</b> 모듈은 query string을 request 파라미터로 파싱 하는데 사용한다. 또한, POST 요청의 body를 파싱하는 데도 사용된다.
</p>

<h6 class="hb1 h6">Get path name & request parameters (경로 이름 및 요청 매개 변수 가져 오기)</h6>

<p class="fsXL">
	<em class="em1">~~ 이후 정리 생략하고 ~~ 내용 보고..(난해하다TT).. 샘플 소스 코드 실행해보는 거에 집중!!</em>
</p>


<h5 class="hb1 h5">Dependency injection (의존성 주입)</h5>
<h5 class="hb1 h5">Request handler (요청 처리기)</h5>
<h5 class="hb1 h5">Blocking vs Non-Blocking (차단 및 비 차단)</h5>

<h6 class="hb1 h6">동기 방식</h6>
<h6 class="hb1 h6">비동기 방식</h6>

<h5 class="hb1 h5">Non-blocking 방식 request handler (비 차단 방식 요청 처리기)</h5>
<h5 class="hb1 h5">Handling POST requests (POST 요청 처리)</h5>
<h5 class="hb1 h5">Handling file uploads (파일 업로드 처리)</h5>


<pre class="mg0">
<code class="xmp">
$ npm start
</code>
</pre>

<p class="fsXL">
	<em class="em1"> 소스 코드 대로 한거 최종 실패!!<br />
		))) http://localhost:7777/ 파일 업로드 폼 전송 후<br />
		))) 사이트에 연결할 수 없음. localhost에서 연결을 거부했습니다.
	
	</em>
</p>


<h4 class="hb1 h4">Express framework (익스프레스 프레임 워크)</h4>
<h4 class="hb1 h4">Reference</h4>


<ul class="bu">
  <li><a href="https://nodejs.org">Node.js</a></li>
  <li><a href="http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb">Understanding node.js</a></li>
  <li><a href="http://www.nextree.co.kr/p7292/">이벤트 기반 비동기 방식</a></li>
  <li><a href="http://expressjs.com/">Express</a></li>
</ul>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-05">5 Node.js에서 비밀 설정 정보(Secrets) 관리</h3>

<h4 class="hb1 h4">코드 내에 하드 코딩하기</h4>
<h4 class="hb1 h4">설정파일 사용하기</h4>
<h4 class="hb1 h4">command-line에서 argument 요구하기 (명령 줄에서 인수 요구하기)</h4>
<h4 class="hb1 h4">환경변수(environment variable) 사용하기</h4>
<h4 class="hb1 h4">Reference</h4>



<!-- ◇◆◇◆◇◆◇◆◇◆ -->
<h2 class="hb1 h2" id="NodeJsBasicUse">Node.js 기본 사용법 (( PYRASIS.COM</h2>

<p>
	<strong class="h1"><a href="http://pyrasis.com/nodejs/nodejs-HOWTO" target="_blank" title="새 창">Node.js 기본 사용법</a></strong>
	내용을 요약하였다.
</p>

<ol class="bo">
<li><em class="em">JavaScript 로 서버 프로그래밍을 할 수 있도록 해주는 플랫폼입니다.</em></li>
<li>2009년 라이언 달이라는 프로그래머가 구글의 V8 자바스크립트 엔진<a href="http://code.google.com/p/v8" target="_blank" title="새 창">http://code.google.com/p/v8</a>을 웹 브라우저가 아닌 서버로 사용할 수 있도록 만든 것이 Node.js입니다.</li>
<li>단언컨대, Node.js는 가장 생산성이 좋은 플랫폼입니다.</li>
<li>소켓 통신, HTTP 웹 서버, WebSocket(socket.io) 등의 HTTP 기반 실시간 프로토콜도 손쉽게 사용, ..</li>
<li>결과적으로 Node.js는 자바스크립트를 웹 브라우저 속에서만 사용되던 언어에서 범용 스크립트 언어로 탈바꿈 시켰습니다.</li>
<li><strong class="h1 em1">npm</strong> <small>(Node Packaged Modules)</small>
은 Node.js로 만들어진 모듈을 인터넷에서 받아서 설치해주는 패키지 매니저입니다.</li>
<li>우리가 생각한 모든게 다 Node.js 모듈로 만들어져 있습니다(GitHub 저장소의 상당수가 Node.js 모듈입니다).</li>
<li>Node.js의 가장 큰 특징을 꼽으라면 <b class="h1 em2">단일 스레드 모델과 Non-blocking I/O</b>입니다.</li>
</ol>



<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">설치하기</h3>

<p>윈도우에 설치: <a href="http://nodejs.org/" target="_blank" title="새 창">nodejs.org</a>에 가서 Windows Installer (.msi)를 받아서 설치합니다.</p>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">사용하기</h3>

<p>
	Node.js는 node(윈도우에서는 node.exe) 실행파일이 자바스크립트를 읽어서 실행하는 방식입니다.
	즉 스크립트 언어인 Python이나 Perl, Ruby와 동일한 실행 방식입니다.<br />
</p>


<b class="em">app.js</b>
<pre>
<code class="xmp">
console.log('Hello World');
</code>
</pre>
<pre>
<samp class="xmp">
$ node app.js
Hello World
</samp>
</pre>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">웹 서버 만들기</h3>

<pre>
<code class="xmp">
var http = require('http');

var server = http.createServer(function (req, res) {
  res.writeHead(200, { 'Content-Type' : 'text/plain' });
  res.end('Hello World');
});

server.listen(8000);
</code>
</pre>
<pre>
<samp class="xmp">
$ node app.js
Hello World
</samp>
</pre>

이번에는 node 실행파일이 바로 종료되지 않고 계속 대기 중입니다.
이건 <var class="fwb">server.listen()</var> 함수 때문에 그렇습니다.
8000번 포트로 접속을 계속 대기하고 있어서 사용자가 종료하기 전까지는 끝나지 않습니다.
끝내려면 <kbd class="fwb">Ctrl+C</kbd>를 입력하면 됩니다.<br />
웹 브라우저를 실행하고 <kbd class="em1">http://127.0.0.1:8000</kbd>으로 접속합니다.
빈 화면에 <samp class="">Hello World</samp>가 표시됩니다.


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">express로 웹 서버 만들기</h3>

<pre>
<samp class="xmp">
$ mkdir HelloWebServer
</samp>
</pre>

<b class="em">app.js</b>
<pre>
<code class="xmp">
var express = <b class="em">require</b>('express') // express 모듈을 로딩
  , http = require('http') // http 모듈을 로딩
  , app = express() // express를 함수로 실행해서 app 객체를 생성
  , server = <b class="em">http.createServer</b>(app); // app 객체와 http 서버를 연결

// get 함수로 HTTP의 GET 메서드를 처리할 수 있습니다. get 함수에 경로를 지정하고, 웹 브라우저가 해당 경로에 접속했을 때 실행될 함수를 지정합니다.
// req는 요청(Request) 객체이고 res는 응답(Response) 객체입니다.
app.<b class="em">get</b>('/', function (<b class="em">req</b>, <b class="em">res</b>) {
  res.send('Hello /'); // http://127.0.0.1:8000/
});
app.get('/world.html', function (req, res) {
  res.send('Hello World'); // http://127.0.0.1:8000/world.html
});

// http 모듈로 생성한 http 서버를 8000번 포트로 실행합니다 
server.listen(8000, function() {
  console.log('Express server listening on port ' + server.address().port);
});
</code>
</pre>

<pre>
<samp class="xmp">
~/HelloWebServer$ npm install express
</samp>
</pre>

주의할 점은 app.js가 있는 디렉터리에서 npm install express 명령을 실행해야 된다는 것입니다.
npm install 명령을 실행하면 app.js가 있는 디렉터리에 <b class="em">node_modules</b> 디렉터리가 생성됩니다.
그리고 node_modules 디렉터리 안에 <b class="em">express</b> 모듈이 설치됩니다.

<!-- box1 -->
<div class="box1 info1">
	<b class="em">npm install -g express</b>와 같이 -g 옵션을 주면 Node.js 설치 디렉터리에 모듈이 설치됩니다.
	전역 모듈 설치라고 하는데 이렇게 설치하면 app.js 디렉터리와 상관없이 모듈을 사용할 수 있습니다.
</div>
<!-- /box1 -->


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">템플릿 엔진 사용하기</h3>

<h4 class="hb1 h4">EJS</h4>

<ol class="bo">
<li><a href="http://embeddedjs.com/" target="_blank" title="새 창">EJS</a>(Embedded JavaScript) 는 서버에서 자바스크립트로 HTML을 생성하는 템플릿 엔진입니다.</li>
<li>템플릿 엔진인 만큼 함수를 이용해서 HTML 태그를 생성할 수 있습니다. 함수 이름이나 사용 방식은 Ruby On Rails와 비슷합니다.<br />
<a href="?" target="_blank" title="새 창">https://code.google.com/p/embeddedjavascript/wiki/ViewHelpers</a>
</li>
</ol>

<h4 class="hb1 h4">Jade</h4>
<a href="http://jade-lang.com/" target="_blank" title="새 창">Jade</a>는 HTML 문법을 간략화한 템플릿 엔진입니다. HTML은 간단한 내용이라도 코드가 길어지고 복잡하여 가독성이 떨어지는 단점이 있죠. Jade는 가독성이 높은 문법을 사용하여 생산성을 높입니다. 

<pre>
<samp class="xmp">
~$ sudo npm install -g express-generator
~$ mkdir ExampleJade
~$ cd ExampleJade
~/ExampleJade$ express
</samp>
</pre>
Jade는 Javascript와 별개로 Jade만의 태그 문법과 제어문을 가지고 있습니다.
<a href="http://jade-lang.com/reference" target="_blank" title="새 창">http://jade-lang.com/reference</a>

<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">실시간 통신 사용하기</h3>

<p>Node.js에서 사용할 수 있는 대표적인 실시간 통신 기술은 다음과 같습니다.</p>

<ol class="bo">
<li>TCP socket</li>
<li>WebSocket:  <a href="http://caniuse.com/websockets" target="_blank" title="새 창">WebSocket 지원 웹 브라우저</a></li>
<li>socket.io</li>
</ol>

<h4 class="hb1 h4">WebSocket</h4>

<pre>
<samp class="xmp">
~$ mkdir ExampleWebSocket
~/ExampleWebSocket$ npm install websocket
</samp>
</pre>

이렇게 실시간 통신을 자바스크립트로 간단하게 만들 수 있습니다. WebSocket 서버 &lt;-&gt; 웹 브라우저 뿐만 아니라 WebSocket 서버 &lt;-&gt; WebSocket 서버도 가능합니다.

<a href="http://github.com/Worlize/WebSocket-Node" target="_blank" title="새 창">http://github.com/Worlize/WebSocket-Node</a>

<h4 class="hb1 h4">socket.io</h4>

<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">모듈 작성하기</h3>

<ol class="bo">
<li>웹 브라우저의 자바스크립트는 HTML에서 &lt;script&gt; 태그로 로딩을 합니다. 하지만 지금까지 자바스크립트 끼리는 서로 로딩할 방법이 없었는데 최근 여러가지 표준이 개발되었습니다.</li>
<li>Node.js는 <a href="http://www.commonjs.org/" target="_blank" title="새 창">CommonJS</a> 모듈 방식을 사용합니다.</li>
</ol>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">package.json 작성하기</h3>

<ol class="bo">
<li>개발한 Node.js 어플리케이션을 서버에 배포할 때에는 <b class="em">package.json</b> 파일이 필수입니다. package.json 파일은 현재 어플리케이션에서 사용하고 있는 npm 모듈을 정의합니다. 그래서 npm 명령은 package.json 파일을 읽어서 모듈을 설치하게 됩니다.</li>
<li><a href="https://www.npmjs.org/doc/json.html" target="_blank" title="새 창">https://www.npmjs.org/doc/json.html</a></li>
<li>package.json 파일은 소스의 최상위 디렉터리에 위치해야 합니다.</li>
<li>dependencies 에 npm 모듈의 이름과 버전을 지정합니다.</li>
<li><a href="https://www.npmjs.org/doc/misc/semver.html" target="_blank" title="새 창">https://www.npmjs.org/doc/misc/semver.html</a></li>
<li>package.json 파일을 작성하고 npm install 명령을 입력하면, 정의된 모듈을 설치합니다.<br />
<pre>
<samp class="xmp">
$ npm install
</samp>
</pre>
</li>
</ol>

<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">환경변수 설정하기</h3>

<ol class="bo">
<li>윈도우에서 환경변수 설정하기(PowerShell을 실행합니다)
<pre>
<samp class="xmp">
PS C:\Project\Hello> $env:NODE_ENV="production"
PS C:\Project\Hello> node app.js
</samp>
</pre>
</li>
<li>리눅스에서 환경 변수 설정하기
<pre>
<samp class="xmp">
$ NODE_ENV="production" node app.js
</samp>
</pre>
</li>
</ol>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">유용한 모듈</h3>
<p>Node.js로 개발할 때 생산성을 높일 수 있는 유용한 모듈이 많습니다.</p>

<h4 class="hb1 h4">forever</h4>

<ol class="bo">
<li>자바스크립트 소스 파일을 감시하다가 소스 파일의 내용이 바뀌면 자동으로 node를 재시작하는 모듈입니다.
<pre>
<samp class="xmp">
$ npm install -g forever
$ forever start -w ./app.js
</samp>
</pre>
</li>
</ol>

<h4 class="hb1 h4">nodemon</h4>

<ol class="bo">
<li>forever와 비슷한 모듈입니다. 소스 파일의 내용이 바뀌면 자동으로 node를 재시작 합니다. 윈도우에서 개발할 때 forever보다 nodemon이 좀더 편리합니다.
<pre>
<samp class="xmp">
$ npm install -g nodemon
$ nodemon app.js
</samp>
</pre>
</li>
</ol>



<!-- panel1 -->
<div class="panel1 clearfix">

<h2 class="hb1 h2" id="Link">Reference Link</h2>

<ol class="bo num">
<li>
	<a href="https://poiemaweb.com/nodejs-basics" target="_blank" rel="noopener" title="새 창" class="a1">
		9.1 <b class="em1">Node.js Basics</b> :: 네트워크 애플리케이션을 위한 자바스크립트 런타임 환경
	</a> - PoiemaWeb
</li>
<li><a href="https://www.google.co.kr/search?q=node.js+강좌" target="_blank" title="새 창">구글링: node.js 강좌</a></li>
<li><a href="https://nodejs.org/" target="_blank" title="새 창">nodejs.org</a></li>
<li><a href="http://ko.wikipedia.org/wiki/Node.js" target="_blank" title="새 창">Node.js - 위키백과</a></li>
<li><a href="http://pyrasis.com/nodejs/nodejs-HOWTO" target="_blank" title="새 창">Node.js 기본 사용법</a></li>
<li><a href="http://overapi.com/nodejs/" target="_blank" title="새 창">NodeJS Cheat Sheet | OverAPI.com</a></li>
<li><a href="http://www.nodebeginner.org/index-kr.html" target="_blank" title="새 창">The Node Beginner Book</a> (Korean version)</li>
</ol>

</div>
<!-- /panel1 -->





<div class="brclear"></div>
<hr class="line1 dott" />
<p>
<strong>History</strong>
: 20150427.~
20200122. 
20200120. 
20171016. 
20150427.
</p>





<script src="../../share/inc/all_footer.js"></script>
</body>
</html>