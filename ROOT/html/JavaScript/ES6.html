<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<script>/*<![CDATA[*/
var _$ = {
	nowPage: {
		id: [0,1,0,0,0],
		title: 'JavaScript - ES6', // Home | mNote
		pageType: 'sub',
		layoutType: 'sub'
	}
};
/*]]>*/</script>
<script src="../../share/inc/html_head.js"></script>
</head>
<body>
<script src="../../share/inc/all_header.js"></script>





<!-- ◇◆◇◆◇◆◇◆◇◆◇◆ -->
<h1 class="hb1 h1">ECMAScript6 (ES6) (ECMAScript 2015 (ES2015))</h1>


<p class="pd1em-rv bgc-warning cvf">
	))) 호환(X)[IE11] (O)[Edge14~] ))) 2020 Win7 지원종료 3년 후 2023년에 다시 보자!
</p>



<!-- mtab1 -->
<div class="mtab1">
<ul>
<li><a>Using ES6</a>
	<ul>
	<li><a href="#h2-1">1 let, const와 블록 레벨 스코프</a></li>
	<li><a href="#h2-2">2 템플릿 리터럴</a></li>
	<li><a href="#h2-3">3 화살표 함수</a></li>
	<li><a href="#h2-4">4 매개변수 기본값, Rest 파라미터, Spread 문법, Rest/Spread 프로퍼티</a></li>
	<li><a href="#h2-5">5 객체 리터럴 프로퍼티 기능 확장</a></li>
	<li><a href="#h2-6">6 디스트럭처링</a></li>
	<li><a href="#h2-7">7 클래스</a></li>
	<li><a href="#h2-8">8 모듈</a></li>
	<li><a href="#h2-9">9 프로미스</a></li>
	<li><a href="#h2-10">10 7번째 타입 심볼(Symbol)</a></li>
	<li><a href="#h2-11">11 이터레이션과 for...of 문</a></li>
	<li><a href="#h2-12">12 제너레이터와 async/awit</a></li>
	<li><a href="#h2-13">13 <b class="em0">Babel</b>과 Webpack을 이용한 ES6 환경 구축 ①</a></li>
	<li><a href="#h2-14">14 Babel과 <b class="em0">Webpack</b>을 이용한 ES6 환경 구축 ②</a></li>
	</ul>
</li>
<li><a href="#Link">Link</a></li>
</ul>
</div>
<!-- /mtab1 -->


<!-- even-grid -->
<div class="even-grid float-left gap40px vgap00">
	<div class="small-9 column">
		<div class="wrap1">


<p>
	((( <a href="https://poiemaweb.com/" target="_blank" rel="noopener" title="새 창" class="a1">poiemaweb.com</a>
			<a href="https://poiemaweb.com/sass-basics" target="_blank" rel="noopener" title="새 창" class="a1">Sass</a>
</p>


<!-- ◇◆◇◆◇◆◇◆◇◆ -->
<h2 class="hb1 h2" id="h2-1">1 let, const와 블록 레벨 스코프</h2>

ES5까지 변수를 선언할 수 있는 유일한 방법은 var 키워드를 사용하는 것이었다.
var 키워드로 선언된 변수는 아래와 같은 특징이 있다.
이는 다른 언어와는 다른 특징으로 주의를 기울이지 않으면 심각한 문제를 일으킨다.

<ol class="bo">
<li><em class="em">함수 레벨 스코프(Function-level scope)</em>
	<ul class="bu">
	<li>함수의 코드 블록만을 스코프로 인정한다. 따라서 전역 함수 외부에서 생성한 변수는 모두 전역 변수이다. 이는 전역 변수를 남발할 가능성을 높인다.</li>
	<li>for 문의 변수 선언문에서 선언한 변수를 for 문의 코드 블록 외부에서 참조할 수 있다.</li>
	</ul>
</li>
<li>var 키워드 생략 허용
	<ul class="bu">
	<li>암묵적 전역 변수를 양산할 가능성이 크다.</li>
	</ul>
</li>
<li>변수 중복 선언 허용
	<ul class="bu">
	<li>의도하지 않은 변수값의 변경이 일어날 가능성이 크다.</li>
	</ul>
</li>
<li><em class="em">변수 호이스팅</em>
	<ul class="bu">
	<li>변수를 선언하기 이전에 참조할 수 있다.</li>
	</ul>
</li>
</ol>


대부분의 문제는 전역 변수로 인해 발생한다.<br />
전역 변수는 간단한 애플리케이션의 경우, 사용이 편리하다는 장점이 있지만 불가피한 상황을 제외하고 사용을 억제해야 한다.<br />
전역 변수는 유효 범위(scope)가 넓어서 어디에서 어떻게 사용될 것인지 파악하기 힘들며,
비순수 함수(Impure function)에 의해 의도하지 않게 변경될 수도 있어서 복잡성을 증가시키는 원인이 된다.<br />
따라서 <em class="em">변수의 스코프는 좁을수록 좋다.</em><br />
ES6는 이러한 var 키워드의 단점을 보완하기 위해 let과 const 키워드를 도입하였다.<br />

<!-- ◇◆◇◆◇◆◇◆◇◆ -->
<h2 class="hb1 h2" id="h2-2">2 템플릿 리터럴</h2>


<p>
	ES6는 템플릿 리터럴(Template literal)이라고 불리는 새로운 문자열 표기법을 도입하였다.<br />
	템플릿 리터럴은 일반 문자열과 비슷해 보이지만, ‘ 또는 “ 같은 통상적인 따옴표 문자 대신 백틱(backtick) 문자 <code>`</code>를 사용한다.
</p>

<p>문자열 인터폴레이션은 <code>${ … }</code>으로 표현식을 감싼다. 문자열 인터폴레이션 내의 표현식은 문자열로 강제 타입 변환된다.</p>


<!-- ◇◆◇◆◇◆◇◆◇◆ -->
<h2 class="hb1 h2" id="h2-3">3 화살표 함수</h2>

화살표 함수(Arrow function)는 function 키워드 대신 화살표(<code>=></code>)를 사용하여 보다 간략한 방법으로 함수를 선언할 수 있다.<br />
하지만 모든 경우 화살표 함수를 사용할 수 있는 것은 아니다.

<h3 class="hb1 h3">this</h3>

<h4 class="hb1 h4">화살표 함수의 this</h4>

<p>
	일반 함수는 함수를 선언할 때 this에 바인딩할 객체가 정적으로 결정되는 것이 아니고,
	함수를 호출할 때 함수가 어떻게 호출되었는지에 따라 this에 바인딩할 객체가 동적으로 결정된다고 하였다.
</p>
<p>
	화살표 함수는 함수를 선언할 때 this에 바인딩할 객체가 정적으로 결정된다.<br />
	동적으로 결정되는 일반 함수와는 달리 화살표 <em class="em">함수의 this 는 언제나 상위 스코프의 this를 가리킨다.</em><br />
	이를 Lexical this라 한다. 화살표 함수는 앞서 살펴본 Solution 3의 Syntactic sugar이다.<br />
</p>
<p class="pd1em-rv bgc-info1 text-info1">
	화살표 함수의 this 바인딩 객체 결정 방식은 함수의 상위 스코프를 결정하는 방식인 렉시컬 스코프와 유사하다.
</p>

<h3 class="hb1 h3">화살표 함수를 사용해서는 안되는 경우</h3>

<ol class="bo">
<li>메소드</li>
<li>prototype</li>
<li>생성자 함수</li>
<li>addEventListener 함수의 콜백 함수</li>
</ol>


<!-- ◇◆◇◆◇◆◇◆◇◆ -->
<h2 class="hb1 h2" id="h2-4">4 매개변수 기본값, Rest 파라미터, Spread 문법, Rest/Spread 프로퍼티</h2>


<h3 class="hb1 h3">1. 매개변수 기본값 (Default Parameter value)</h3>


<p>
	함수를 호출할 때 매개변수의 개수만큼 인수를 전달하는 것이 일반적이지만 그렇지 않은 경우에도 에러가 발생하지는 않는다.
	함수는 매개변수의 개수와 인수의 개수를 체크하지 않는다.
	인수가 부족한 경우, 매개변수의 값은 undefined이다.
</p>
<p>따라서 매개변수에 적절한 인수가 전달되었는지 함수 내부에서 확인할 필요가 있다.</p>
<p>
	<em class="em">ES6에서는 매개변수 기본값을 사용하여 함수 내에서 수행하던 인수 체크 및 초기화를 간소화할 수 있다.</em>
	매개변수 기본값은 매개변수에 인수를 전달하지 않았을 경우에만 유효하다.
</p>
<p>
	매개변수 기본값은
	함수 정의 시 선언한 매개변수 개수를 나타내는 함수 객체의 length 프로퍼티와 arguments 객체에 영향을 주지 않는다.
</p>


<h3 class="hb1 h3">2. Rest 파라미터</h3>

<p>
	Rest 파라미터(Rest Parameter, 나머지 매개변수)는 매개변수 이름 앞에 세개의 점 <code>...</code>을 붙여서 정의한 매개변수를 의미한다.<br />
	Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받는다.<br />
</p>

<h3 class="hb1 h3">3. Spread 문법</h3>

<p>
	Spread 문법(Spread Syntax, <code>...</code>)는 대상을 개별 요소로 분리한다. Spread 문법의 대상은 이터러블이어야 한다.
</p>

<h3 class="hb1 h3">4. Rest/Spread 프로퍼티</h3>

<p>
	ECMAScript 언어 표준에 제안(proposal)된
	Rest/Spread 프로퍼티(Object Rest/Spread Properties)는 객체 리터럴을 분해하고 병합하는 편리한 기능을 제공한다.
</p>


<!-- ◇◆◇◆◇◆◇◆◇◆ -->
<h2 class="hb1 h2" id="h2-5">5 객체 리터럴 프로퍼티 기능 확장</h2>

<p>
	ES6에서는 객체 리터럴 프로퍼티 기능을 확장하여 더욱 간편하고 동적인 객체 생성 기능을 제공한다.
</p>

1. 프로퍼티 축약 표현
2. 프로퍼티 키 동적 생성
3. 메소드 축약 표현
4. __proto__ 프로퍼티에 의한 상속


<!-- ◇◆◇◆◇◆◇◆◇◆ -->
<h2 class="hb1 h2" id="h2-6">6 디스트럭처링(Destructuring)</h2>

<p>
	디스트럭처링(Destructuring)은 구조화된 배열 또는 객체를 Destructuring(비구조화, 파괴)하여 개별적인 변수에 할당하는 것이다.
	배열 또는 객체 리터럴에서 필요한 값만을 추출하여 변수에 할당하거나 반환할 때 유용하다.
</p>

<h3 class="hb1 h3">1. 배열 디스트럭처링 (Array destructuring)</h3>

<h3 class="hb1 h3">2. 객체 디스트럭처링 (Object destructuring)</h3>


<!-- ◇◆◇◆◇◆◇◆◇◆ -->
<h2 class="hb1 h2" id="h2-7">7 클래스</h2>


자바스크립트는 프로토타입 기반(prototype-based) 객체지향 언어다. 비록 다른 객체지향 언어들과의 차이점에 대한 논쟁이 있긴 하지만, 자바스크립트는 강력한 객체지향 프로그래밍 능력을 지니고 있다.

프로토타입 기반 프로그래밍은 클래스가 필요없는(class-free) 객체지향 프로그래밍 스타일로 프로토타입 체인과 클로저 등으로 객체 지향 언어의 상속, 캡슐화(정보 은닉) 등의 개념을 구현할 수 있다.

Javascript Object-Oriented Programming
ES5에서는 생성자 함수와 프로토타입, 클로저를 사용하여 객체 지향 프로그래밍을 구현하였다.


<h3 class="hb1 h3">1. 클래스 정의 (Class Definition)</h3>
<h3 class="hb1 h3">2. 인스턴스 생성</h3>
<h3 class="hb1 h3">3. constructor</h3>
<h3 class="hb1 h3">4. 클래스 필드</h3>
<h3 class="hb1 h3">5. Class field declarations proposal</h3>
<h3 class="hb1 h3">6. getter, setter</h3>
<h3 class="hb1 h3">7. 정적 메소드</h3>
<h3 class="hb1 h3">8. 클래스 상속</h3>


<!-- ◇◆◇◆◇◆◇◆◇◆ -->
<h2 class="hb1 h2" id="h2-8">8 모듈</h2>

<p>
	모듈이란 애플리케이션을 구성하는 개별적 요소로서 재사용 가능한 코드 조각을 말한다. 모듈은 세부 사항을 캡슐화하고 공개가 필요한 API만을 외부에 노출한다.
</p>

클라이언트 사이드 자바스크립트는 script 태그를 사용하여 외부의 스크립트 파일을 가져올 수는 있지만,
파일마다 독립적인 파일 스코프를 갖지 않고 하나의 전역 객체(Global Object)를 공유한다.
즉, 자바스크립트 파일을 여러 개의 파일로 분리하여 script 태그로 로드하여도
분리된 자바스크립트 파일들이 결국 하나의 자바스크립트 파일 내에 있는 것처럼 하나의 전역 객체를 공유한다.
따라서 분리된 자바스크립트 파일들이 하나의 전역을 갖게 되어 전역 변수가 중복되는 등의 문제가 발생할 수 있다.
이것으로는 모듈화를 구현할 수 없다.

서버 사이드 자바스크립트 런타임 환경인 Node.js는 모듈 시스템의 사실상 표준(de facto standard)인 CommonJS를 채택하였고
독자적인 진화를 거쳐 현재는 CommonJS 사양과 100% 동일하지는 않지만 기본적으로 CommonJS 방식을 따르고 있다.
즉, Node.js에서는 표준은 아니지만 모듈이 지원된다.
따라서 Node.js 환경에서는 모듈 별로 독립적인 스코프, 즉 모듈 스코프를 갖는다.

<p>
	이러한 상황에서 ES6에서는 클라이언트 사이드 자바스크립트에서도 동작하는 모듈 기능을 추가하였다.
	2019년 11월 현재, 모던 브라우저(Chrome 61, FF 60, SF 10.1, Edge 16 이상)에서 ES6 모듈을 사용할 수 있다.
</p>

<p>
	<code>script</code> 태그에 <code>type="module"</code> 어트리뷰트를 추가하면 로드된 자바스크립트 파일은 모듈로서 동작한다.
	ES6 모듈의 파일 확장자는 모듈임을 명확히 하기 위해 <code>mjs</code>를 사용하도록 권장한다.
</p>

<p>
	단, 아래와 같은 이유로 아직까지는 브라우저가 지원하는 ES6 모듈 기능보다는 Webpack 등의 모듈 번들러를 사용하는 것이 일반적이다.
</p>

<ul class="bu">
<li>IE를 포함한 구형 브라우저는 ES6 모듈을 지원하지 않는다.</li>
<li>브라우저의 ES6 모듈 기능을 사용하더라도 트랜스파일링이나 번들링이 필요하다.</li>
<li>아직 지원하지 않는 기능(Bare import 등)이 있다. (ECMAScript modules in browsers 참고)</li>
<li>점차 해결되고는 있지만 아직 몇가지 이슈가 있다. (ECMAScript modules in browsers 참고)</li>
</ul>

<p>
	ES6를 사용하여 프로젝트를 진행하려면<br />
	ES6로 작성된 코드를 IE를 포함한 모든 브라우저에서 문제 없이 동작시키기 위한 개발환경을 구축하는 것이 필요하다.<br />
	이 문제에 대해서는<br />
	Babel과 Webpack을 이용한 ES6 개발환경 구축①과 Babel과 Webpack을 ES6 개발환경 구축②에서 알아볼 것이다.<br />
	이 장에서는 ES6 모듈의 기본 문법에 대해서만 살펴보도록 하자.<br />
</p>

<h3 class="hb1 h3">1. 모듈 스코프</h3>
<h3 class="hb1 h3">2. export 키워드</h3>
<h3 class="hb1 h3">3. import 키워드</h3>


<!-- ◇◆◇◆◇◆◇◆◇◆ -->
<h2 class="hb1 h2" id="h2-9">9 프로미스</h2>


<h3 class="hb1 h3">1. 프로미스란?</h3>

<p>
	자바스크립트는 비동기 처리를 위한 하나의 패턴으로 콜백 함수를 사용한다.
	하지만 전통적인 콜백 패턴은 가독성이 나쁘고 비동기 처리 중 발생한 에러의 예외 처리가 곤란하며
	여러 개의 비동기 처리 로직을 한꺼번에 처리하는 것도 한계가 있다.
	ES6에서 비동기 처리를 위한 또 다른 패턴으로 프로미스(Promise)를 도입하였다.
	<em class="em">Promise는 전통적인 콜백 패턴이 가진 단점을 보완하며 비동기 처리 시점을 명확하게 표현한다.</em>
</p>


<h3 class="hb1 h3">2. 콜백 패턴의 단점</h3>
<h3 class="hb1 h3">3. 프로미스의 생성</h3>
<h3 class="hb1 h3">4. 프로미스의 후속 처리 메소드</h3>
<h3 class="hb1 h3">5. 프로미스의 에러 처리</h3>
<h3 class="hb1 h3">6. 프로미스 체이닝</h3>
<h3 class="hb1 h3">7. 프로미스의 정적 메소드</h3>



<!-- ◇◆◇◆◇◆◇◆◇◆ -->
<h2 class="hb1 h2" id="h2-10">10 7번째 타입 심볼(Symbol)</h2>


<h3 class="hb1 h3">1. Symbol이란?</h3>


<p>
	1997년 자바스크립트가 ECMAScript로 처음 표준화된 이래로 자바스크립트는 6개의 타입을 가지고 있었다.
</p>

<ul class="bu">
<li>원시 타입 (primitive data type)
	<ul class="bu">
	<li>Boolean</li>
	<li>null</li>
	<li>undefined</li>
	<li>Number</li>
	<li>String</li>
	</ul>
</li>
<li>객체 타입 (Object type)
	<ul class="bu">
	<li>Object</li>
	</ul>
</li>
</ul>

<p>
	심볼(symbol)은 ES6에서 새롭게 추가된 7번째 타입으로 변경 불가능한 원시 타입의 값이다.
	심볼은 주로 이름의 충돌 위험이 없는 유일한 객체의 프로퍼티 키(property key)를 만들기 위해 사용한다.
</p>

<h3 class="hb1 h3">2. Symbol의 생성</h3>

<p>
	Symbol은 <code>Symbol()</code> 함수로 생성한다. Symbol() 함수는 호출될 때마다 Symbol 값을 생성한다.
	이때 생성된 Symbol은 객체가 아니라 변경 불가능한 원시 타입의 값이다.
</p>
<p>
	Symbol() 함수는 String, Number, Boolean과 같이 래퍼 객체를 생성하는 생성자 함수와는 달리 new 연산자를 사용하지 않는다.
</p>


<h3 class="hb1 h3">3. Symbol의 사용</h3>
<h3 class="hb1 h3">4. Symbol 객체</h3>


<!-- ◇◆◇◆◇◆◇◆◇◆ -->
<h2 class="hb1 h2" id="h2-11">11 이터레이션과 for...of 문</h2>


<h3 class="hb1 h3">1. 이터레이션 프로토콜</h3>

<p>
	ES6에서 도입된 이터레이션 프로토콜(<em class="em">iteration</em> protocol)은 데이터 컬렉션을 순회하기 위한 프로토콜(미리 약속된 규칙)이다.
	이터레이션 프로토콜을 준수한 객체는 for…of 문으로 순회할 수 있고 Spread 문법의 피연산자가 될 수 있다.
	이터레이션 프로토콜에는 이터러블 프로토콜(<em class="em">iterable</em> protocol)과 이터레이터 프로토콜(<em class="em">iterator</em> protocol)이 있다.
</p>

<h4 class="hb1 h4">1.1 이터러블</h4>

<p>
	이터러블 프로토콜을 준수한 객체를 이터러블이라 한다.
	이터러블은 Symbol.iterator 메소드를 구현하거나 프로토타입 체인에 의해 상속한 객체를 말한다.
	Symbol.iterator 메소드는 이터레이터를 반환한다.
	이터러블은 for…of 문에서 순회할 수 있으며 Spread 문법의 대상으로 사용할 수 있다.
</p>

<p>
	배열은 Symbol.iterator 메소드를 소유한다. 따라서 <em class="em">배열은 이터러블 프로토콜을 준수한 이터러블이다.</em>
</p>

<p>
	일반 객체는 Symbol.iterator 메소드를 소유하지 않는다. 따라서 <em class="em">일반 객체는 이터러블 프로토콜을 준수한 이터러블이 아니다.</em>
</p>

<p>
	일반 객체는 이터레이션 프로토콜을 준수(Symbol.iterator 메소드를 소유)하지 않기 때문에 이터러블이 아니다.
	따라서 일반 객체는 for…of 문에서 순회할 수 없으며 Spread 문법의 대상으로 사용할 수도 없다.
	하지만 <em class="em">일반 객체도 이터러블 프로토콜을 준수하도록 구현하면 이터러블이 된다.</em>
	이에 대해서는 3. 커스텀 이터러블에서 살펴보도록 하자.
</p>


<h3 class="hb1 h3">2. for…of 문</h3>
<h3 class="hb1 h3">3. 커스텀 이터러블</h3>


<!-- ◇◆◇◆◇◆◇◆◇◆ -->
<h2 class="hb1 h2" id="h2-12">12 제너레이터와 async/awit</h2>


<h3 class="hb1 h3">1. 제너레이터란?</h3>

<p>
	ES6에서 도입된 제너레이터(Generator) 함수는 이터러블을 생성하는 함수이다.
	제너레이터 함수를 사용하면 이터레이션 프로토콜을 준수해 이터러블을 생성하는 방식보다 간편하게 이터러블을 구현할 수 있다.
	또한 제너레이터 함수는 비동기 처리에 유용하게 사용된다.
</p>

<h3 class="hb1 h3">2. 제너레이터 함수의 정의</h3>
<h3 class="hb1 h3">3. 제너레이터 함수의 호출과 제너레이터 객체</h3>
<h3 class="hb1 h3">4. 제너레이터의 활용</h3>


<h4 class="hb1 h4">4.1 이터러블의 구현</h4>
<h4 class="hb1 h4">4.2 비동기 처리</h4>

((중략))
<p>
	제너레이터을 통해 비동기 처리를 동기 처리처럼 구현할 수 있으나 코드는 장황해졌다.
	따라서 좀 더 간편하게 비동기 처리를 구현할 수 있는 async/awit가 ES7에서 도입되었다.
</p>

<p>
	위 예제를 async/awit 구현해 보자.
</p>


<!-- ◇◆◇◆◇◆◇◆◇◆ -->
<h2 class="hb1 h2" id="h2-13">13 <b class="em5">Babel</b>과 Webpack을 이용한 ES6 환경 구축 ①</h2>


<p>
	크롬, 사파리, 파이어폭스와 같은 에버그린 브라우저(Evergreen browser, 사용자의 업데이트 없이도 최신 버전으로 자동 업데이트를 수행하는 모던 브라우저)의
	ES6 지원 비율은 약 98%로 거의 대부분의 ES6 사양을 구현하고 있다.
</p>

<a href="https://kangax.github.io/compat-table/es6/" target="_blank" rel="noopener" title="새 창" class="a1">ECMAScript 6 Browser Support</a>

<p>
	하지만 인터넷 익스플로어(IE) 11의 ES6 지원 비율은 약 11%이다.
	그리고 매년 새롭게 도입되는 ES6 이상의 버전(ES6+)과 제안 단계에 있는 ES 제안 사양(ES NEXT)은 브라우저에 따라 지원 비율이 제각각이다.
</p>

<p>
	따라서 ES6+ 또는 ES NEXT의 ES 최신 사양을 사용하여 프로젝트를 진행하려면 최신 사양으로 작성된 코드를
	경우에 따라 IE를 포함한 구형 브라우저에서 문제 없이 동작시키기 위한 개발 환경을 구축하는 것이 필요하다.
	특히 모듈의 경우, 모듈 로더가 필요하다.
</p>

<p>
	2019년 11월 현재, 모던 브라우저(Chrome 61, FF 60, SF 10.1, Edge 16 이상)에서 ES6 모듈을 사용할 수 있다.
	단, 아래와 같은 이유로 아직까지는 브라우저가 지원하는 ES6 모듈 기능보다는 Webpack 등의 모듈 번들러를 사용하는 것이 일반적이다.
</p>

<ul class="bu">
<li>IE를 포함한 구형 브라우저는 ES6 모듈을 지원하지 않는다.</li>
<li>브라우저의 ES6 모듈 기능을 사용하더라도 트랜스파일링이나 번들링이 필요하다.</li>
<li>아직 지원하지 않는 기능(Bare import 등)이 있다. (ECMAScript modules in browsers 참고)</li>
<li>점차 해결되고는 있지만 아직 몇가지 이슈가 있다. (ECMAScript modules in browsers 참고)</li>
</ul>

<p>
	트랜스파일러(Transpiler) Babel과 모듈 번들러(Module bundler) Webpack을 이용하여 ES6+ 개발환경을 구축하여 보자.
	아울러 Webpack을 통해 ES6+ 코드와 Sass를 트랜스파일링하는 방법도 알아볼 것이다.
</p>

<h3 class="hb1 h3">1. Babel</h3>

<h4 class="hb1 h4">1.2 Babel이란?</h4>

<p>
	<em class="em">Babel 은 최신 사양의 자바스크립트 코드를 IE나 구형 브라우저에서도 동작하는 ES5 이하의 코드로 변환(트랜스파일링)</em>할 수 있다.
</p>

<h4 class="hb1 h4">1.2 Babel CLI 설치</h4>

<pre class="mg0">
<code class="xmp">
# 프로젝트 폴더 생성
$ mkdir es6-project && cd es6-project
# package.json 생성
$ npm init -y
# babel-core, babel-cli 설치
$ npm install --save-dev @babel/core @babel/cli
</code>
</pre>


<h4 class="hb1 h4">1.3 .babelrc 설정 파일 작성</h4>

<pre class="mg0">
<code class="xmp">
# env preset 설치
$ npm install --save-dev @babel/preset-env
</code>
</pre>


<h5 class="hb1 h5">.babelrc</h5>

<pre class="mg0">
<code class="xmp">
{
  "presets": ["@babel/preset-env"]
}
</code>
</pre>


<h4 class="hb1 h4">1.4 트랜스파일링</h4>


<h5 class="hb1 h5">package.json</h5>

<pre class="mg0">
<code class="xmp">
{
  "name": "es6-project",
  "version": "1.0.0",
  "scripts": {
    "build": "babel src/js -w -d dist/js"
  },
  "devDependencies": {
    "@babel/cli": "^7.7.0",
    "@babel/core": "^7.7.2",
    "@babel/preset-env": "^7.7.1"
  }
}
</code>
</pre>


<h5 class="hb1 h5">트랜스파일링을 실행</h5>
<pre class="mg0">
<code class="xmp">
$ npm run build
</code>
</pre>


<h4 class="hb1 h4">1.5 Babel 플러그인</h4>


<pre class="mg0">
<code class="xmp">
$ npm install --save-dev @babel/plugin-proposal-class-properties
</code>
</pre>

<h5 class="hb1 h5">package.json</h5>
<pre class="mg0">
<code class="xmp">
{
  "name": "es6-project",
  "version": "1.0.0",
  "scripts": {
    "build": "babel src/js -w -d dist/js"
  },
  "devDependencies": {
    "@babel/cli": "^7.7.0",
    "@babel/core": "^7.7.2",
    "@babel/plugin-proposal-class-properties": "^7.7.0",
    "@babel/preset-env": "^7.7.1"
  }
}
</code>
</pre>

<h5 class="hb1 h5">.babelrc</h5>
<pre class="mg0">
<code class="xmp">
{
  "presets": ["@babel/preset-env"],
  "plugins": ["@babel/plugin-proposal-class-properties"]
}
</code>
</pre>


<h4 class="hb1 h4">1.6 브라우저에서 모듈 로딩 테스트</h4>

<p>
	브라우저는 CommonJS 방식의 module loading system(require 함수)을 지원하지 않으므로 위에서 트랜스파일링된 결과를 그대로 브라우저에서 실행하면 에러가 발생한다.
</p>
<p>
	브라우저의 ES6 모듈 기능을 사용하도록 Babel을 설정할 수도 있으나 앞서 설명한 바와 같이 브라우저의 ES6 모듈 기능을 사용하는 것은 문제가 있다.
</p>
<p>
	다음 장에서는 Webpack을 통해 이러한 문제를 해결해보도록 하자.
</p>

<h3 class="hb1 h3">Reference</h3>

<ul>
  <li>
    <a href="https://babeljs.io/">Babel</a>
  </li>
  <li>
    <a href="https://kangax.github.io/compat-table/es6/">ECMAScript 6 Browser Support</a>
  </li>
</ul>



<!-- ◇◆◇◆◇◆◇◆◇◆ -->
<h2 class="hb1 h2" id="h2-14">14 Babel과 <b class="em5">Webpack</b>을 이용한 ES6 환경 구축 ②</h2>


<h3 class="hb1 h3">2. Webpack</h3>

<h4 class="hb1 h4">2.1 Webpack이란?</h4>


<p>
	<em class="em">Webpack은 의존 관계에 있는 모듈들을 하나의 자바스크립트 파일로 번들링하는 모듈 번들러</em>이다.
	Webpack을 사용하면 의존 모듈이 하나의 파일로 번들링되므로 별도의 모듈 로더가 필요없다.
	그리고 다수의 자바스크립트 파일을 하나의 파일로 번들링하므로 html 파일에서 script 태그로 다수의 자바스크립트 파일을 로드해야 하는 번거로움도 사라진다.
</p>

<p>
	Webpack과 Babel을 이용하여 ES6+ 개발 환경을 구축하여 보자.
	Webpack이 자바스크립트 파일을 번들링하기 전에 Babel을 로드하여 ES6+ 코드를 ES5 코드로 트랜스파일링하는 작업을 실행하도록 설정할 것이다.
	그리고 Sass를 사용하는 경우, Sass 트랜스파일링도 Webpack에서 관리하도록 할 것이다.
</p>


<h4 class="hb1 h4">2.2 Webpack 설치</h4>

<pre class="mg0">
<code class="xmp">
# Webpack V4는 webpack-cli를 요구한다
$ npm install --save-dev webpack webpack-cli
</code>
</pre>

<h5 class="hb1 h5">package.json</h5>

<pre class="mg0">
<code class="xmp">
{
  "name": "es6-project",
  "version": "1.0.0",
  "scripts": {
    "build": "babel src/js -w -d dist/js"
  },
  "devDependencies": {
    "@babel/cli": "^7.7.0",
    "@babel/core": "^7.7.2",
    "@babel/plugin-proposal-class-properties": "^7.7.0",
    "@babel/preset-env": "^7.7.1",
    "webpack": "^4.41.2",
    "webpack-cli": "^3.3.10"
  }
}
</code>
</pre>


<h4 class="hb1 h4">2.3 babel-loader</h4>

<pre class="mg0">
<code class="xmp">
# babel-loader 설치
$ npm install --save-dev babel-loader
</code>
</pre>

<h5 class="hb1 h5">package.json </h5>

<pre class="mg0">
<code class="xmp">
{
  "name": "es6-project",
  "version": "1.0.0",
  "scripts": {
    "build": "webpack -w"
  },
  "devDependencies": {
    "@babel/cli": "^7.7.0",
    "@babel/core": "^7.7.2",
    "@babel/plugin-proposal-class-properties": "^7.7.0",
    "@babel/preset-env": "^7.7.1",
    "babel-loader": "^8.0.6",
    "webpack": "^4.41.2",
    "webpack-cli": "^3.3.10"
  }
}
</code>
</pre>


<h4 class="hb1 h4">2.4 webpack.config.js</h4>


<h5 class="hb1 h5">webpack.config.js</h5>

<pre class="mg0">
<code class="xmp">
const path = require('path');

module.exports = {
  // enntry file
  entry: './src/js/main.js',
  // 컴파일 + 번들링된 js 파일이 저장될 경로와 이름 지정
  output: {
    path: path.resolve(__dirname, 'dist/js'),
    filename: 'bundle.js'
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        include: [
          path.resolve(__dirname, 'src/js')
        ],
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['@babel/preset-env'],
            plugins: ['@babel/plugin-proposal-class-properties']
          }
        }
      }
    ]
  },
  devtool: 'source-map',
  // https://webpack.js.org/concepts/mode/#mode-development
  mode: 'development'
};
</code>
</pre>


<pre class="mg0">
<code class="xmp">
$ npm run build
</code>
</pre>


<xmp class="xmp">
<!DOCTYPE html>
<html>
<body>
  <script src="./dist/js/bundle.js"></script>
</body>
</html>
</xmp>

<p>
	main.js, lib.js 모듈이 하나로 번들링된 bundle.js가 브라우저에서 문제없이 실행된 것을 확인할 수 있다.
</p>

<h4 class="hb1 h4">2.5 babel-polyfill</h4>

<p>
	Babel을 사용하여 ES6+ 코드를 ES5 이하로 트랜스파일링하여도 브라우저가 지원하지 않는 코드가 남아 있을 수 있다.
	예를 들어, <em class="em">ES6에서 추가된 Promise, Object.assign, Array.from 등은 ES5 이하로 트랜스파일링하여도 대체할 ES5 기능이 없기 때문에 그대로 남아 있다.</em>
</p>
<p>
	따라서 오래된 브라우저에서도 ES6+에서 새롭게 추가된 객체나 메소드를 사용하기 위해서는
	@babel/polyfill을 설치해야 한다.
</p>

<pre class="mg0">
<code class="xmp">
$ npm install @babel/polyfill
</code>
</pre>

<h5 class="hb1 h5">package.json</h5>

<pre class="mg0">
<code class="xmp">
{
  "name": "es6-project",
  "version": "1.0.0",
  "scripts": {
    "build": "webpack -w"
  },
  "devDependencies": {
    "@babel/cli": "^7.7.0",
    "@babel/core": "^7.7.2",
    "@babel/plugin-proposal-class-properties": "^7.7.0",
    "@babel/preset-env": "^7.7.1",
    "babel-loader": "^8.0.6",
    "webpack": "^4.41.2",
    "webpack-cli": "^3.3.10"
  },
  "dependencies": {
    "@babel/polyfill": "^7.7.0"
  }
}
</code>
</pre>


<pre class="mg0">
<code class="xmp">
// src/js/main.js
import "@babel/polyfill";
...
</code>
</pre>

<p>
	webpack을 사용하는 경우에는 위 방법을 대신 폴리필을 webpack.config.js 파일의 entry 배열에 추가한다.
</p>

<pre class="mg0">
<code class="xmp">
// webpack.config.js
const path = require('path');

module.exports = {
  // entry files
  entry: ['@babel/polyfill', './src/js/main.js'],
  ...
</code>
</pre>

<pre class="mg0">
<code class="xmp">
$ npm run build
</code>
</pre>


<h4 class="hb1 h4">2.6 Sass 컴파일</h4>

<p>
	Sass를 컴파일한 결과물인 css를 bundle.js 파일에 포함시키는 방법과 별도의 css 파일로 분리하는 방법이 있다.
</p>


<h5 class="hb1 h5">2.6.1 컴파일된 css를 bundle.js 파일에 포함시키는 방법</h5>


<pre class="mg0">
<code class="xmp">
$ npm install node-sass style-loader css-loader sass-loader --save-dev
</code>
</pre>

<h6 class="hb1 h6">package.json</h6>

<h6 class="hb1 h6">webpack.config.js</h6>

<p>
	테스트를 위해 3개의 Sass 파일을 src/sass 폴더와 src/sass/partials 폴더에 추가한다.
</p>

<pre class="mg0">
<code class="xmp">
$ npm run build
</code>
</pre>

CSS가 적용되는 것을 확인하기 위해 index.html을 아래와 같이 수정하자.

<xmp class="xmp">
<!DOCTYPE html>
<html>
  <head>
    <script src="./dist/js/bundle.js"></script>
  </head>
<body>
  Hello world!
</body>
</html>
</xmp>

<p>
	CSS가 적용된 것을 확인할 수 있다.
</p>
<p>
	컴파일된 CSS는 bundle.js에 포함되어 있다.
</p>


<h5 class="hb1 h5">2.6.2 컴파일된 CSS를 별도의 CSS 파일로 분리하는 방법</h5>


<!-- panel0 -->
<div class="panel0 bg-warning">
Webpack v4 이전 버전에서는 extract-text-webpack-plugin을 사용했었다.<br />
Webpack v4부터 css와 관련한 파일 분리는 mini-css-extract-plugin을 사용하도록 변경되었다.<br />
</div>
<!-- /panel0 -->


<pre class="mg0">
<code class="xmp">
$ npm install --save-dev <b class="em">mini-css-extract-plugin</b>
</code>
</pre>


<h6 class="hb1 h6">package.json 확인</h6>

<pre class="mg0">
<code class="xmp">
{
  "name": "es6-project",
  "version": "1.0.0",
  "scripts": {
    "build": "webpack -w"
  },
  "devDependencies": {
    "@babel/cli": "^7.7.0",
    "@babel/core": "^7.7.2",
    "@babel/plugin-proposal-class-properties": "^7.7.0",
    "@babel/preset-env": "^7.7.1",
    "babel-loader": "^8.0.6",
    "css-loader": "^3.2.0",
    "mini-css-extract-plugin": "^0.8.0",
    "node-sass": "^4.13.0",
    "sass-loader": "^8.0.0",
    "style-loader": "^1.0.0",
    "webpack": "^4.41.2",
    "webpack-cli": "^3.3.10"
  },
  "dependencies": {
    "@babel/polyfill": "^7.7.0"
  }
}
</code>
</pre>


<h6 class="hb1 h6">webpack.config.js 수정</h6>


<pre class="mg0">
<code class="xmp">
const path = require('path');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');

module.exports = {
  // entry files
  entry: ['@babel/polyfill', './src/js/main.js', './src/sass/main.scss'],
  // 컴파일 + 번들링된 js 파일이 저장될 경로와 이름 지정
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'js/bundle.js'
  },
  plugins: [
    // 컴파일 + 번들링 CSS 파일이 저장될 경로와 이름 지정
    new MiniCssExtractPlugin({ filename: 'css/style.css' })
  ],
  module: {
    rules: [
      {
        test: /\.js$/,
        include: [
          path.resolve(__dirname, 'src/js')
        ],
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['@babel/preset-env'],
            plugins: ['@babel/plugin-proposal-class-properties']
          }
        },
        exclude: /node_modules/
      },
      {
        test: /\.scss$/,
        use: [
          MiniCssExtractPlugin.loader,
          'css-loader',
          'sass-loader'
        ],
        exclude: /node_modules/
      }
    ]
  },
  devtool: 'source-map',
  // https://webpack.js.org/concepts/mode/#mode-development
  mode: 'development'
};
</code>
</pre>

<h6 class="hb1 h6">빌드 명령 실행</h6>

<pre class="mg0">
<code class="xmp">
$ npm run build
</code>
</pre>

<h6 class="hb1 h6">style.css 파일이 저장</h6>

<pre class="mg0">
<code class="xmp">
body {
  color: #333;
  font-size: 16px;
  font-family: Arial, sans-serif;
  line-height: 125%;
}

/*# sourceMappingURL=style.css.map*/
</code>
</pre>


<h6 class="hb1 h6">index.html에서 style.css 파일을 로드</h6>

<xmp class="xmp">
<!DOCTYPE html>
<html>
  <head>
    <link href="./dist/css/style.css" rel="stylesheet"></link>
    <script src="./dist/js/bundle.js"></script>
  </head>
<body>
  Hello world!
</body>
</html>
</xmp>

<p>
	CSS가 적용된 것을 확인할 수 있다.
</p>


<h3 class="hb1 h3">Reference</h3>


<ul>
  <li>
    <a href="https://webpack.js.org/">Webpack</a>
  </li>
  <li>
    <a href="https://webpack.academy/">webpack academy</a>
  </li>
  <li>
    <a href="https://kangax.github.io/compat-table/es6/">ECMAScript 6 Browser Support</a>
  </li>
</ul>




		</div>
	</div>
	<div class="small-3 column">
		<div class="wrap1">


<!-- ◇◆◇◆◇◆◇◆◇◆ -->
<h2 class="hb1 h2" id="Link">Link</h2>


<ol class="bo">
<li>
	<a href="★★" target="_blank" rel="noopener" title="새 창" class="a1">
		★★
	</a>
</li>
<li>
	<a href="https://www.w3schools.com/js/js_versions.asp" target="_blank" rel="noopener" title="새 창" class="a1">
		JavaScript Versions
	</a> - w3schools.com
</li>
</ol>


		</div>
	</div>
</div>
<!-- /even-grid -->





<br />
<hr class="show" />
<p>
<strong>History</strong>
20200121.~
20200803.
20200121.
</p>





<script src="../../share/inc/all_footer.js"></script>
</body>
</html>