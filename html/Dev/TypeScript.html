<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<script>/*<![CDATA[*/
var _$ = {
	nowPage: {
		id: [0,1,0,0,0],
		title: 'TypeScript', // Home | mNote
		pageType: 'sub',
		layoutType: 'sub'
	}
};
/*]]>*/</script>
<script src="../../share/inc/html_head.js"></script>
</head>
<body>
<script src="../../share/inc/all_header.js"></script>





<h1 class="hb1 h1">TypeScript</h1>


<!-- mtab1 -->
<div class="mtab1">
<menu>
<li>
	<a href="#h2-01">TypeScript (( PoiemaWeb</a>
	<ul>
	<li><a href="#h3-01">1 TypeScript의 소개와 개발 환경 구축</a></li>
	<li><a href="#h3-02">2 Visual Studio Code에서의 TypeScript 개발 환경 구축</a></li>
	<li><a href="#h3-03">3 정적 타이핑</a></li>
	<li><a href="#h3-04">4 클래스</a></li>
	<li><a href="#h3-05">5 인터페이스</a></li>
	<li><a href="#h3-06">6 타입 앨리어스</a></li>
	<li><a href="#h3-07">7 제네릭</a></li>
	</ul>
</li>
<li><a href="#Link">Reference Link</a></li>
</menu>
</div>
<!-- /mtab1 -->



<!-- ◇◆◇◆◇◆◇◆◇◆ -->
<h2 class="hb1 h2" id="h2-01">TypeScript (( <a href="https://poiemaweb.com/typescript-introduction" target="_blank" rel="noopener" title="새 창" class="a1">PoiemaWeb</a></h2>



<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-01">1 TypeScript의 소개와 개발 환경 구축</h3>

<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">1. Introduction</h4>

<p>
	자바스크립트는 1995년 넷스케이프사의 브렌던 아이크(Brendan Eich)가 자사의 웹브라우저인 Navigator 2에 탑재하기 위해 개발한 스크립트 언어이다. 초창기 자바스크립트는 웹페이지의 보조적인 기능을 수행하기 위해 한정적인 용도로 사용되었다. 이 시기에 대부분 로직은 주로 웹서버에서 실행되었고 브라우저(클라이언트)는 서버로부터 전달받은 HTML과 CSS를 렌더링하는 수준이었다.
</p>
<p>
	HTML5가 등장하기 이전까지 웹 애플리케이션은 플래시, 실버라이트, 액티브엑스와 같은 플러그인에 의존하여 인터랙티브한 웹페이지를 구축해왔다. 그러다가 HTML5가 등장함으로써 플러그인에 의존하던 구축 방식은 자바스크립트로 대체되었다. 또한 AJAX의 활성화로 데스크탑 애플리케이션과 유사한 사용자 경험을 제공할 수 있는 SPA(Single Page Application)가 대세가 되었다. 이로써 과거 서버 측이 담당하던 업무의 많은 부분이 클라이언트 측으로 이동하게 되었고, 자바스크립트는 웹의 어셈블리 언어로 불릴 만큼 중요한 언어로 그 위상이 높아지게 되었다.
</p>
<p>
	모든 프로그래밍 언어에 장단점이 있듯이 자바스크립트도 언어가 잘 정제되기 이전에 서둘러 출시된 문제와 과거 웹페이지의 보조적인 기능을 수행하기 위해 한정적인 용도로 만들어진 태생적 한계로 좋은 점도, 나쁜 점도 많은 것이 사실이다.
</p>
<p>
	자바스크립트는 C나 Java와 같은 C-family 언어와는 구별되는 아래와 같은 특성이 있다.
</p>

<ul class="bu">
<li>Prototype-based Object Oriented Language</li>
<li>Scope와 this</li>
<li>동적 타입(dynamic typed) 언어 혹은 느슨한 타입(loosely typed) 언어</li>
</ul>

<p>
	이와 같은 특성은 클래스 기반 객체지향 언어(Java, C++, C# 등)에 익숙한 개발자를 혼란스럽게 하며 코드가 복잡해질 수 있고 디버그와 테스트 공수가 증가하는 등의 문제를 일으킬 수 있어 특히 규모가 큰 프로젝트에서는 주의하여야 한다.
</p>
<p>
	이같은 자바스크립트의 태생적 문제를 극복하고자 CoffeeScript, Dart, Haxe와 같은 AltJS(자바스크립트의 대체 언어)가 등장하였다.
</p>
<p>
	TypeScript 또한 자바스크립트 대체 언어의 하나로써 자바스크립트(ES5)의 Superset(상위확장)이다. C#의 창시자인 덴마크 출신 소프트웨어 엔지니어 Anders Hejlsberg(아네르스 하일스베르)가 개발을 주도한 TypeScript는 Microsoft에서 2012년 발표한 오픈소스로, 정적 타이핑을 지원하며 ES6(ECMAScript 2015)의 클래스, 모듈 등과 ES7의 Decorator 등을 지원한다.
</p>

<figure class="block-center tac" style="max-width:300px;">
	<img src="https://poiemaweb.com/img/typescript-superset.png" alt="Typescript superset" />
	<figcaption>Typescript superset</figcaption>
</figure>

<p>
	TypeScript는 ES5의 Superset이므로 기존의 자바스크립트(ES5) 문법을 그대로 사용할 수 있다. 또한, ES6의 새로운 기능들을 사용하기 위해 Babel과 같은 별도 트랜스파일러(Transpiler)를 사용하지 않아도 ES6의 새로운 기능을 기존의 자바스크립트 엔진(현재의 브라우저 또는 Node.js)에서 실행할 수 있다.
</p>
<p>
	이후 ECMAScript의 업그레이드에 따른 새로운 기능을 지속적으로 추가할 예정이여서 매년 업그레이드될 ECMAScript의 표준을 따라갈 수 있는 좋은 수단이 될 것이다.
</p>
<p>
	더욱이 AngularJS의 후속 버전인 Angular의 TypeScript 정식 채용으로 TypeScript에 관심이 커져가고 있다.
</p>

<figure class="block-center tac" style="max-width:650px;">
	<img src="https://poiemaweb.com/img/typescript-google-trends.png" alt="Google Trends" />
	<figcaption>Google Trends</figcaption>
</figure>

<p>
	구글은 당초 Angular의 주력 언어로 TypeScript의 상위 집합인 AtScript를 계획했지만, TypeScript를 채용하는 것으로 방향을 전환했다. 그 배경으로 Angular에 필요한 기능을 TypeScript의 사양에 포함하는 것을 TypeScript 진영과 합의한 것으로 전해진다.
</p>

<figure class="block-center tac" style="max-width:300px;">
	<img src="https://poiemaweb.com/img/atscript.png" alt="AtScript superset" />
	<figcaption>AtScript superset</figcaption>
</figure>

<p>
	또한 구글은 2년간의 검토 끝에 2017년 3월 사내 표준 언어(Canonical Languages)로 TypeScript의 사용을 승인하였다. 구글은 구글애널리틱스, 파이어베이스, 구글 클라우드 플랫폼 등 대규모 프로젝트와 버그 추적, 채용 검토, 제품 승인 및 출시 도구와 같은 핵심적인 내부 도구에 TypeScript와 TypeScript 기반 Angular를 사용하고 있다.
</p>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">2. TypeScript의 장점</h4>
<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">2.1 정적 타입</h5>


<pre class="mg0">
<code class="xmp">
function sum(a: number, b: number) {
  return a + b;
}

sum('x', 'y');
// error TS2345: Argument of type '"x"' is not assignable to parameter of type 'number'.
</code>
</pre>


<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">2.2 도구의 지원</h5>

<p>
	TypeScript를 사용하는 이유는 여러가지 있지만 가장 큰 장점은 <b class="em0">IDE(통합개발환경)</b>를 포함한 다양한 도구의 지원을 받을 수 있다는 것이다.
	IDE와 같은 도구에 타입 정보를 제공함으로써 높은 수준의 <em class="em">인텔리센스(IntelliSense), 코드 어시스트, 타입 체크, 리팩토링</em> 등을 지원받을 수 있으며
	이러한 도구의 지원은 대규모 프로젝트를 위한 필수 요소이기도 하다.
</p>

<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">2.3 강력한 객체지향 프로그래밍 지원</h5>

<p>
	<b class="em">인터페이스, 제네릭</b> 등과 같은 강력한 객체지향 프로그래밍 지원은 크고 복잡한 프로젝트의 코드 기반을 쉽게 구성할 수 있도록 도우며,
	Java, C# 등의 클래스 기반 객체지향 언어에 익숙한 개발자가 자바스크립트 프로젝트를 수행하는 데 진입 장벽을 낮추는 효과도 있다.
</p>

<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">2.4 ES6 / ES Next 지원</h5>

<p>
	브라우저만 있으면 컴파일러 등의 개발환경 구축없이 바로 사용할 수 있는 ES5와 비교할 때,
	개발환경 구축 관점에서 다소 복잡해진 측면이 있지만
	현재 ES6를 완전히 지원하지 않고 있는 브라우저를 고려하여 Babel 등의 트랜스파일러를 사용해야 하는 현 상황에서
	TypeScript 개발환경 구축에 드는 수고는 그다지 아깝지 않을 것이다.
	또한, <em class="em">TypeScript는 아직 ECMAScript 표준에 포함되지는 않았지만 표준화가 유력한 스펙을 선제적으로 도입</em>하므로
	새로운 스펙의 유용한 기능을 안전하게 도입하기에 유리하다.
</p>

<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">2.5 Angular</h5>

<p>
	마지막으로 Angular는 TypeScript 뿐만 아니라 자바스크립트(ES5, ES6), Dart로도 작성할 수 있지만
	<em class="em">Angular 문서, 커뮤니티 활동에서 가장 많이 사용되고 있는 것이 TypeScript이다.</em>
	Angular 관련 문서의 예제 등도 TypeScript로 작성된 것이 대부분이어서 관련 정보를 얻을 때 이점이 있으며 이러한 현상은 앞으로도 지속될 것으로 예상된다.
</p>

<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">3. 개발환경 구축</h4>
<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">3.1 Node.js 설치</h5>
<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">3.2 TypeScript 컴파일러 설치 및 사용법</h5>

<p>
	Node.js를 설치하면 npm도 같이 설치된다. 다음과 같이 터미널(윈도우의 경우 커맨드창)에서 npm을 사용하여 TypeScript를 전역에 설치한다.
</p>

<pre class="mg0">
<code class="xmp">
$ npm install -g typescript
</code>
</pre>

<p>
	설치가 완료되었으면 버전을 출력하여 TypeScript의 설치를 확인한다.
</p>

<pre class="mg0">
<code class="xmp">
$ tsc -v
Version 2.8.3
</code>
</pre>

<p>
	<b class="em0">TypeScript 컴파일러(tsc)</b>는 <em class="em">TypeScript 파일(.ts)을 자바스크립트 파일로 트랜스파일링한다.</em>
</p>

<div class="panel0 bg-info">
	컴파일은 일반적으로 소스 코드를 바이트 코드로 변환하는 작업을 의미한다.
	TypeScript 컴파일러는 TypeScript 파일을 자바스크립트 파일로 변환하므로 컴파일보다는 트랜스파일링(Transpiling)이 보다 적절한 표현이다.
</div>

<p>
	트랜스파일링을 실행해보기 위해 아래와 같은 파일을 작성해 보자. 참고로 TypeScript 파일의 확장자는 .ts이다.
</p>

<p>
	<em class="em1 fsXL">~~ 이후 코드 실습만 하고 정리 생략 ~~</em>
</p>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">Reference</h4>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-01">2 Visual Studio Code에서의 TypeScript 개발 환경 구축</h3>

<p>
	<b class="em0">Visual Studio Code(VSCode)</b>는 마이크로소프트가 제공하는 오픈소스 코드 에디터이다.
	<em class="em">마이크로소프트는 TypeScript를 개발한 회사이기도 하여서 VSCode는 TypeScript 지원이 탁월하다.</em>
	IntelliSense, debugging, Git 등의 기능을 지원하며 다양한 Extension(확장 플러그인)을 제공하여 자신의 프로젝트에 맞는 개발 환경을 쉽게 구축할 수 있다.
</p>

<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">1. Visual Studio Code 설치</h4>
<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">2. tsconfig.json</h4>
<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">3. Task runner</h4>


<p>
	위 TypeScript 코드를 자바스크립트로 트랜스파일링하기 위해서는 TypeScript 컴파일러를 실행시켜야한다. 컴파일러는 VSCode 외부에 존재하므로 VSCode와 TypeScript 컴파일러 간의 연동이 필요하다.
</p>
<p>
	VSCode는 Task runner로 외부의 툴을 VSCode와 연동시킬 수 있다. CLI로 실행되는 툴들을 VSCode에서 실행시킬 수 있는 수 있도록 하는 것이다.
</p>
<p>
	Ctrl + Shft + P(⇧⌘P) 단축기 또는 메뉴의 보기 > 명령 팔레트를 선택하고 “Configure Task Runner”를 입력한다.
</p>

<p>
	<em class="em1 fsXL">~~ VSC 에서 Configure Task Runner 를 찾을 수 없어 이후 실습 중단! ~~</em>
</p>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">4. 외부 라이브러리의 사용을 위한 TypeScript Definition 설치</h4>
<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">5. 디버깅</h4>
<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">Reference</h4>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-01">3 정적 타이핑</h3>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">1. 타입 선언 (Type Declaration)</h4>

<p>
	TypeScript는 아래와 같이 변수명 뒤에 타입을 명시하는 것으로 타입을 선언할 수 있다.
</p>

<pre class="mg0">
<code class="xmp">
// 변수 foo는 string 타입이다.
let foo: string = 'hello';
</code>
</pre>

<p>
	선언한 타입에 맞지 않는 값을 할당하면 컴파일 시점에 에러가 발생한다.
</p>

<pre class="mg0">
<code class="xmp">
let bar: number = true; // error TS2322: Type 'true' is not assignable to type 'number'.
</code>
</pre>

<p>
	이러한 타입 선언은 개발자가 코드를 예측할 수 있도록 돕는다. 또한 타입 선언은 강력한 타입 체크를 가능하게 하여 문법 에러나 타입과 일치하지 않는 값의 할당 등 기본적인 오류를 런타임 이전에 검출한다. 비주얼스튜디오 코드(VS Code)와 같은 도구을 사용하면 코드를 작성하는 시점에 에러를 검출할 수 있어서 개발 효율이 대폭 향상된다.
</p>

<p>
	함수의 매개변수와 반환값에 대한 타입 선언 방법은 아래와 같다. 일반 변수와 마찬가지로 선언된 타입에 일치하지 않는 값이 주어지면 에러가 발생한다.
</p>

<pre class="mg0">
<code class="xmp">
// 함수선언식
function multiply1(x: number, y: number): number {
  return x * y;
}

// 함수표현식
const multiply2 = (x: number, y: number): number => x * y;

console.log(multiply1(10, 2));
console.log(multiply2(10, 3));

console.log(multiply1(true, 1)); // error TS2345: Argument of type 'true' is not assignable to parameter of type 'number'.
</code>
</pre>

<p>
	다양한 타입을 사전 선언하는 방법은 아래와 같다.
</p>

<pre class="mg0">
<code class="xmp">
// boolean
let isDone: boolean = false;

// null
let n: null = null;

// undefined
let u: undefined = undefined;

// number
let decimal: number = 6;
let hex: number = 0xf00d;
let binary: number = 0b1010;
let octal: number = 0o744;

// string
let color: string = "blue";
color = 'red';
let myName: string = `Lee`; // ES6 템플릿 문자열
let greeting: string = `Hello, my name is ${ myName }.`; // ES6 템플릿 대입문

// object
const obj: object = {};

// array
let list1: any[] = [1, 'two', true];
let list2: number[] = [1, 2, 3];
let list3: Array<number> = [1, 2, 3]; // 제네릭 배열 타입

// tuple : 고정된 요소수 만큼의 타입을 미리 선언후 배열을 표현
let tuple: [string, number];
tuple = ['hello', 10]; // OK
tuple = [10, 'hello']; // Error
tuple = ['hello', 10, 'world', 100]; // Error
tuple.push(true); // Error

// enum : 열거형은 숫자값 집합에 이름을 지정한 것이다.
enum Color1 {Red, Green, Blue};
let c1: Color1 = Color1.Green;

console.log(c1); // 1

enum Color2 {Red = 1, Green, Blue};
let c2: Color2 = Color2.Green;

console.log(c2); // 2

enum Color3 {Red = 1, Green = 2, Blue = 4};
let c3: Color3 = Color3.Blue;

console.log(c3); // 4

/*
any: 타입 추론(type inference)할 수 없거나 타입 체크가 필요 없는 변수에 사용한다.
var 키워드로 선언한 변수와 같이 어떤 타입의 값이라도 할당할 수 있다.
*/
let notSure: any = 4;
notSure = 'maybe a string instead';
notSure = false; // okay, definitely a boolean

// void : 일반적으로 함수에서 반환값이 없을 경우 사용한다.
function warnUser(): void {
  console.log("This is my warning message");
}

// never : 결코 발생하지 않는 값
function infiniteLoop(): never {
  while (true) {}
}

function error(message: string): never {
  throw new Error(message);
}
</code>
</pre>

<p>
	타입은 소문자, 대문자를 구별하므로 주의가 필요하다. 위에서 살펴본 바와 같이 TypeScript가 기본 제공하는 타입은 모두 소문자이다. 아래 코드를 살펴보자.
</p>

<pre class="mg0">
<code class="xmp">
// string: 원시 타입 문자열 타입
let primiteveStr: string;
primiteveStr = 'hello'; // OK
// 원시 타입 문자열 타입에 객체를 할당하였다.
primiteveStr = new String('hello'); // Error
/*
Type 'String' is not assignable to type 'string'.
'string' is a primitive, but 'String' is a wrapper object. Prefer using 'string' when possible.
*/

// String: String 생성자 함수로 생성된 String 래퍼 객체 타입
let objectStr: String;
objectStr = 'hello'; // OK
objectStr = new String('hello'); // OK
</code>
</pre>

<p>
	string 타입은 TypeScript가 기본으로 제공하는 원시 타입인 문자열 타입을 의미한다. 하지만 대문자로 시작하는 String 타입은 String 생성자 함수로 생성된 String 래퍼 객체 타입을 의미한다. 따라서 string 타입에 String 타입을 할당하면 에러가 발생한다. 하지만 String 타입에는 string 타입을 할당할 수 있다. 이처럼 객체의 유형도 타입이 될 수 있다.
</p>

<pre class="mg0">
<code class="xmp">
// Date 타입
const today: Date = new Date();

// HTMLElement 타입
const elem: HTMLElement = document.getElementById('myId');

class Person { }
// Person 타입
const person: Person = new Person();
</code>
</pre>

<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">2. 정적 타이핑</h4>

<p>
	C나 Java같은 C-family 언어는 변수를 선언할 때 변수에 할당할 값의 타입에 따라 사전에 타입을 명시적으로 선언(Type declaration)하여야 하며 선언한 타입에 맞는 값을 할당해야 한다. 이를 정적 타이핑(Static Typing)이라 한다.
</p>
<p>
	자바스크립트는 동적 타입(dynamic typed) 언어 혹은 느슨한 타입(loosely typed) 언어이다. 이것은 변수의 타입 선언 없이 값이 할당되는 과정에서 동적으로 타입을 추론(Type Inference)한다는 의미이다. 동적 타입 언어는 타입 추론에 의해 변수의 타입이 결정된 후에도 같은 변수에 여러 타입의 값을 교차하여 할당할 수 있다. 이를 동적 타이핑(Dynamic Typing)이라 한다.
</p>
<p>
	동적 타이핑은 사용하기 간편하지만 코드를 예측하기 힘들어 예상치 못한 오류를 만들 가능성이 높다. 또한 IDE와 같은 도구가 변수나 매개 변수, 함수의 반환값의 타입을 알 수 없어 코드 어시스트 등의 기능을 지원할 수 없게 한다.
</p>

<pre class="mg0">
<code class="xmp">
var foo;

console.log(typeof foo);  // undefined

foo = null;
console.log(typeof foo);  // object

foo = {};
console.log(typeof foo);  // object

foo = 3;
console.log(typeof foo);  // number

foo = 3.14;
console.log(typeof foo);  // number

foo = "Hi there";
console.log(typeof foo);  // string

foo = true;
console.log(typeof foo);  // boolean
</code>
</pre>

<p>
	TypeScript의 가장 독특한 특징은 정적 타이핑을 지원한다는 것이다. 정적 타입 언어는 타입을 명시적으로 선언하며, 타입이 결정된 후에는 타입을 변경할 수 없다. 잘못된 타입의 값이 할당 또는 반환되면 컴파일러는 이를 감지해 에러를 발생시킨다.
</p>

<pre class="mg0">
<code class="xmp">
let foo: string,   // 문자열 타입
    bar: number,   // 숫자 타입
    baz: boolean;  // 불리언 타입

foo = 'Hello';
bar = 123;
baz = 'true'; // error: Type '"true"' is not assignable to type 'boolean'.
</code>
</pre>

<p>
	정적 타이핑은 변수는 물론 함수의 매개변수와 반환값에도 사용할 수 있다.
</p>

<pre class="mg0">
<code class="xmp">
function add(x: number, y: number): number {
  return x + y;
}

console.log(add(10, 10)); // 20
console.log(add('10', '10'));
// error TS2345: Argument of type '"10"' is not assignable to parameter of type 'number'.
</code>
</pre>

<p>
	참고로 정적 타이핑과 동적 타이핑 중 무엇이 우위인지에 대한 논쟁은 사실 큰 의미가 없다. 정적 타이핑과 동적 타이핑의 가장 큰 차이를 컴파일 시의 에러 검출과 런타임 시의 에러 검출로 볼 수 있는데 Java와 같은 정적 타이핑 언어도 런타임에만 검출되는 에러가 존재하기 때문이다.
</p>
<p>
	정적 타이핑의 장점은 코드 가독성, 예측성, 안정성의 향상이라고 볼 수 있는데 이는 대규모 프로젝트에 매우 적합하다.
</p>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">3. 타입 추론</h4>

<p>
	만약 타입 선언을 생략하면 값이 할당되는 과정에서 동적으로 타입이 결정된다. 이를 타입 추론(Type Inference)이라 한다.
</p>

<pre class="mg0">
<code class="xmp">
let foo = 123; // foo는 number 타입
</code>
</pre>

<p>
	위 코드를 보면 변수 foo에 타입을 선언하지 않았으나 타입 추론에 의해 변수의 타입이 결정된다. 동적 타입 언어는 타입 추론에 의해 변수의 타입이 결정된 후에도 같은 변수에 여러 타입의 값을 교차하여 할당할 수 있다. 하지만 정적 타입 언어는 타입이 결정된 후에는 타입을 변경할 수 없다. TypeScript는 정적 타입 언어이므로 타입 추론으로 타입이 결정된 이후, 다른 타입의 값을 할당하면 에러가 발생한다.
</p>

<pre class="mg0">
<code class="xmp">
let foo = 123; // foo는 number 타입
foo = 'hi';    // error: Type '"hi"' is not assignable to type 'number'.
</code>
</pre>

<p>
	타입 선언을 생략하고 값도 할당하지 않아서 타입을 추론할 수 없으면 any 타입이 된다. any 타입의 변수는 자바스크립트의 var 키워드로 선언된 변수처럼 어떤 타입의 값도 재할당이 가능하다. 이는 TypeScript를 사용하는 장점을 없애기 때문에 사용하지 않는 편이 좋다.
</p>

<pre class="mg0">
<code class="xmp">
let foo; // let foo: any와 동치

foo = 'Hello';
console.log(typeof foo); // string

foo = true;
console.log(typeof foo); // boolean
</code>
</pre>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">Reference</h4>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-01">4 클래스</h3>


<p>
	<b class="em1">ES6에서 새롭게 도입된 클래스</b>는
	기존 프로토타입 기반 객체지향 언어보다 클래스 기반 언어에 익숙한 개발자가 보다 빠르게 학습할 수 있는 단순명료한 새로운 문법을 제시하고 있다.
	하지만 클래스가 새로운 객체지향 모델을 제공하는 것은 아니다.
	사실 클래스도 함수이고 기존 프로토타입 기반 패턴의 Syntactic sugar일 뿐이다.
	Typescript가 지원하는 클래스는 ECMAScript 6의 클래스와 상당히 유사하지만 몇 가지 Typescript만의 고유한 확장 기능이 있다.
</p>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">1. 클래스 정의 (Class Definition)</h4>

<p>
	ES6 클래스는 클래스 몸체에 메소드만을 포함할 수 있다.
	클래스 몸체에 클래스 프로퍼티를 선언할 수 없고 반드시 생성자 내부에서 클래스 프로퍼티를 선언하고 초기화한다.
</p>

<pre class="mg0">
<code class="xmp">
// person.js
class Person {
  constructor(name) {
    // 클래스 프로퍼티의 선언과 초기화
    this.name = name;
  }

  walk() {
    console.log(`${this.name} is walking.`);
  }
}
</code>
</pre>

<p>
	위 예제는 ES6에서 문제없이 실행되는 코드이지만 위 파일의 확장자를 ts로 바꾸어 Typescript 파일로 변경한 후, 컴파일하면 아래와 같이 컴파일 에러가 발생한다.
</p>

<pre class="mg0">
<code class="xmp">
person.ts(4,10): error TS2339: Property 'name' does not exist on type 'Person'.
person.ts(8,25): error TS2339: Property 'name' does not exist on type 'Person'.
</code>
</pre>

<p>
	<em class="em">Typescript 클래스는 클래스 몸체에 클래스 프로퍼티를 사전 선언하여야 한다.</em>
</p>

<pre class="mg0">
<code class="xmp">
// person.ts
class Person {
  // 클래스 프로퍼티를 사전 선언하여야 한다
  name: string;

  constructor(name: string) {
    // 클래스 프로퍼티수에 값을 할당
    this.name = name;
  }

  walk() {
    console.log(`${this.name} is walking.`);
  }
}

const person = new Person('Lee');
person.walk(); // Lee is walking
</code>
</pre>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">2. 접근 제한자</h4>

<table class="t3">
  <thead>
    <tr>
      <th style="text-align: left">접근 가능성</th>
      <th style="text-align: center">public</th>
      <th style="text-align: center">protected</th>
      <th style="text-align: center">private</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">클래스 내부</td>
      <td style="text-align: center">◯</td>
      <td style="text-align: center">◯</td>
      <td style="text-align: center">◯</td>
    </tr>
    <tr>
      <td style="text-align: left">자식 클래스 내부</td>
      <td style="text-align: center">◯</td>
      <td style="text-align: center">◯</td>
      <td style="text-align: center">✕</td>
    </tr>
    <tr>
      <td style="text-align: left">클래스 인스턴스</td>
      <td style="text-align: center">◯</td>
      <td style="text-align: center">✕</td>
      <td style="text-align: center">✕</td>
    </tr>
  </tbody>
</table>

<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">3. 생성자 파라미터에 접근 제한자 선언</h4>

<pre class="mg0">
<code class="xmp">
class Foo {
  /*
  접근 제한자가 선언된 생성자 파라미터 x는 클래스 프로퍼티로 선언되고 지동으로 초기화된다.
  public이 선언되었으므로 x는 클래스 외부에서도 참조가 가능하다.
  */
  constructor(public x: string) { }
}
((중략))
</code>
</pre>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">4. readonly 키워드</h4>

<p>
	Typescript는 <code>readonly</code> 키워드를 사용할 수 있다.
	readonly가 선언된 클래스 프로퍼티는 선언 시 또는 생성자 내부에서만 값을 할당할 수 있다.
	그 외의 경우에는 값을 할당할 수 없고 오직 읽기만 가능한 상태가 된다.
	이를 이용하여 상수의 선언에 사용한다.
</p>

<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">5. static 키워드</h4>

<p>
	ES6 클래스에서 static 키워드는 클래스의 정적(static) 메소드를 정의한다.
	정적 메소드는 클래스의 인스턴스가 아닌 클래스 이름으로 호출한다.
	따라서 클래스의 인스턴스를 생성하지 않아도 호출할 수 있다.
</p>

<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">6. 추상 클래스</h4>

<p>
	<b class="em0">추상 클래스(abstract class)</b>는 하나 이상의 추상 메소드를 포함하며 일반 메소드도 포함할 수 있다.
	추상 메소드는 내용이 없이 메소드 이름과 타입만이 선언된 메소드를 말하며 선언할 때 <code>abstract</code> 키워드를 사용한다.
	추상 클래스를 정의할 때는 abstract 키워드를 사용하며, 직접 인스턴스를 생성할 수 없고 상속만을 위해 사용된다.
	추상 클래스를 상속한 클래스는 추상 클래스의 추상 메소드를 반드시 구현하여야 한다.
</p>

<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">Reference</h4>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-01">5 인터페이스</h3>

<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">1. Introduction</h4>

<p>
	<b class="em0">인터페이스는 일반적으로 타입 체크를 위해 사용되며 변수, 함수, 클래스에 사용할 수 있다.</b>
	인터페이스는 여러가지 타입을 갖는 프로퍼티로 이루어진 새로운 타입을 정의하는 것과 유사하다.
	인터페이스에 선언된 프로퍼티 또는 메소드의 구현을 강제하여 일관성을 유지할 수 있도록 하는 것이다.
	ES6는 인터페이스를 지원하지 않지만 TypeScript는 인터페이스를 지원한다.
</p>
<p>
	인터페이스는 프로퍼티와 메소드를 가질 수 있다는 점에서 클래스와 유사하나 직접 인스턴스를 생성할 수 없고 모든 메소드는 추상 메소드이다.
	단, 추상 클래스의 추상 메소드와 달리 abstract 키워드를 사용하지 않는다.
</p>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">2. 변수와 인터페이스</h4>

<p>
	인터페이스는 변수의 타입으로 사용할 수 있다.
	이때 인터페이스를 타입으로 선언한 변수는 해당 인터페이스를 준수하여야 한다.
	이것은 새로운 타입을 정의하는 것과 유사하다.
</p>

<pre class="mg0">
<code class="xmp">
// 인터페이스의 정의
interface Todo {
  id: number;
  content: string;
  completed: boolean;
}

// 변수 todo의 타입으로 Todo 인터페이스를 선언하였다.
let todo: Todo;

// 변수 todo는 Todo 인터페이스를 준수하여야 한다.
todo = { id: 1, content: 'typescript', completed: false };
</code>
</pre>

<p>
	인터페이스를 사용하여 함수 파라미터의 타입을 선언할 수 있다.
	이때 해당 함수에는 함수 파라미터의 타입으로 지정한 인터페이스를 준수하는 인수를 전달하여야 한다.
	함수에 객체를 전달할 때 복잡한 매개변수 체크가 필요없어서 매우 유용하다.
</p>

<pre class="mg0">
<code class="xmp">
// 인터페이스의 정의
interface Todo {
  id: number;
  content: string;
  completed: boolean;
}

let todos: Todo[] = [];

// 파라미터 todo의 타입으로 Todo 인터페이스를 선언하였다.
function addTodo(todo: Todo) {
  todos = [...todos, todo];
}

// 파라미터 todo는 Todo 인터페이스를 준수하여야 한다.
const newTodo: Todo = { id: 1, content: 'typescript', completed: false };
addTodo(newTodo);
console.log(todos)
// [ { id: 1, content: 'typescript', completed: false } ]
</code>
</pre>

<p>
	<em class="em1 fsXL">~~ 이후 일독만 하고 생략 ~~</em>
</p>

<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">3. 함수와 인터페이스</h4>
<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">4. 클래스와 인터페이스</h4>
<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">5. 덕 타이핑 (Duck typing)</h4>
<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">6. 선택적 프로퍼티</h4>
<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">7. 인터페이스 상속</h4>
<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">Reference</h4>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-01">6 타입 앨리어스 (Type Alias)</h3>


<p>
	타입 앨리어스는 새로운 타입을 정의한다. 타입으로 사용할 수 있다는 점에서 타입 앨리어스는 인터페이스와 유사하다.
</p>
<p>
	인터페이스는 아래와 같이 타입으로 사용할 수 있다.
</p>

<pre class="mg0">
<code class="xmp">
interface Person {
  name: string,
  age?: number
}

// 빈 객체를 Person 타입으로 지정
const person = {} as Person;
person.name = 'Lee';
person.age = 20;
person.address = 'Seoul'; // Error
</code>
</pre>

<p>
	타입 앨리어스도 인터페이스와 마찬가지로 타입으로 사용할 수 있다.
</p>

<pre class="mg0">
<code class="xmp">
// 타입 앨리어스
type Person = {
  name: string,
  age?: number
}

// 빈 객체를 Person 타입으로 지정
const person = {} as Person;
person.name = 'Lee';
person.age = 20;
person.address = 'Seoul'; // Error
</code>
</pre>

<p>
	하지만 타입 앨리어스는 원시값, 유니온 타입, 튜플 등도 타입으로 지정할 수 있다.
</p>

<pre class="mg0">
<code class="xmp">
// 문자열 리터럴로 타입 지정
type Str = 'Lee';

// 유니온 타입으로 타입 지정
type Union = string | null;

// 문자열 유니온 타입으로 타입 지정
type Name = 'Lee' | 'Kim';

// 숫자 리터럴 유니온 타입으로 타입 지정
type Num = 1 | 2 | 3 | 4 | 5;

// 객체 리터럴 유니온 타입으로 타입 지정
type Obj = {a: 1} | {b: 2};

// 함수 유니온 타입으로 타입 지정
type Func = (() => string) | (() => void);

// 인터페이스 유니온 타입으로 타입 지정
type Shape = Square | Rectangle | Circle;

// 튜플로 타입 지정
type Tuple = [string, boolean];
const t: Tuple = ['', '']; // Error
</code>
</pre>

<p>
	인터페이스는 extends 또는 implements될 수 있지만 타입 앨리어스는 extends 또는 implements될 수 없다. 즉, 상속을 통해 확장이 필요하다면 타입 앨리어스보다는 인터페이스가 유리하다. 하지만 인터페이스로 표현할 수 없거나 유니온 또는 튜플을 사용해야한다면 타입 앨리어스를 사용한는 편이 유리하다.
</p>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-01">7 제네릭 (Generic)</h3>


<p>
	Java나 C# 같은 정적 타입 언어의 경우, 함수 또는 클래스를 정의하는 시점에 매개변수나 반환값의 타입을 선언하여야 한다.
	TypeScript 또한 정적 타입 언어이기 때문에 함수 또는 클래스를 정의하는 시점에 매개변수나 반환값의 타입을 선언하여야 한다.
	그런데 함수 또는 클래스를 정의하는 시점에 매개변수나 반환값의 타입을 선언하기 어려운 경우가 있다.
</p>
<p>
	아래의 예제를 살펴보자. FIFO(First In First Out) 구조로 데이터를 저장하는 큐를 표현한 것이다.
</p>


<pre class="mg0">
<code class="xmp">
class Queue {
  protected data = []; // data: any[]

  push(item) {
    this.data.push(item);
  }

  pop() {
    return this.data.shift();
  }
}

const queue = new Queue();

queue.push(0);
queue.push('1'); // 의도하지 않은 실수!

console.log(queue.pop().toFixed()); // 0
console.log(queue.pop().toFixed()); // Runtime error
</code>
</pre>

<p>
	Queue 클래스의 data 프로퍼티는 타입 선언을 생략하였기 때문에 any[] 타입이 된다.
	any[] 타입은 어떤 타입의 요소도 가질 수 있는 배열을 의미한다.
</p>
<p>
	any[] 타입은 배열 요소의 타입이 모두 같지 않다는 문제를 가지게 된다.
	위 예제의 경우 data 프로퍼티는 number 타입만을 포함하는 배열이라는 기대 하에 각 요소에 대해 Number.prototype.toFixed를 사용하였다.
	따라서 number 타입이 아닌 요소의 경우 런타임 에러가 발생한다.
</p>
<p>
	위와 같은 문제를 해결하기 위해 Queue 클래스를 상속하여 number 타입 전용 NumberQueue 클래스를 정의할 수 있다.
</p>

<pre class="mg0">
<code class="xmp">
class Queue {
  protected data = []; // data: any[]

  push(item) {
    this.data.push(item);
  }

  pop() {
    return this.data.shift();
  }
}

// Queue 클래스를 상속하여 number 타입 전용 NumberQueue 클래스를 정의
class NumberQueue extends Queue {
  // number 타입의 요소만을 push한다.
  push(item: number) {
    super.push(item);
  }

  pop(): number {
    return super.pop();
  }
}

const queue = new NumberQueue();

queue.push(0);
// 의도하지 않은 실수를 사전 검출 가능
// [ts] Argument of type '"1"' is not assignable to parameter of type 'number'.
// queue.push('1');
queue.push(+'1'); // 실수를 사전 인지하고 수정할 수 있다

console.log(queue.pop().toFixed()); // 0
console.log(queue.pop().toFixed()); // 1
</code>
</pre>

<p>
	이와 같이 number 타입 전용 NumberQueue 클래스를 정의하면 number 타입 이외의 요소가 추가(push)되었을 때,
	아래와 같이 런타임 이전에 에러를 사전 감지할 수 있다.
</p>

<figure class="box1 tac">
	<img src="https://poiemaweb.com/img/vscode-code-validator.png" alt="vscode-code-validator">
	<figcaption>Visual Studio Code의 코드 검증 기능</figcaption>
</figure>

<p>
	하지만 다양한 타입을 지원해야 한다면 타입 별로 클래스를 상속받아 추가해야 하므로 이 또한 좋은 방법은 아니다.
	제네릭을 사용하여 이 문제를 해결하여 보자.
</p>

<xmp class="xmp">
class Queue<T> {
  protected data: Array<T> = [];
  push(item: T) {
    this.data.push(item);
  }
  pop(): T {
    return this.data.shift();
  }
}

// number 전용 Queue
const numberQueue = new Queue<number>();

numberQueue.push(0);
// numberQueue.push('1'); // 의도하지 않은 실수를 사전 검출 가능
numberQueue.push(+'1');   // 실수를 사전 인지하고 수정할 수 있다

console.log(numberQueue.pop().toFixed()); // 0
console.log(numberQueue.pop().toFixed()); // 1

// string 전용 Queue
const stringQueue = new Queue<string>();

stringQueue.push('Hello');
stringQueue.push('World');

console.log(stringQueue.pop().toUpperCase()); // HELLO
console.log(stringQueue.pop().toUpperCase()); // WORLD

// 커스텀 객체 전용 Queue
const myQueue = new Queue<{name: string, age: number}>();
myQueue.push({name: 'Lee', age: 10});
myQueue.push({name: 'Kim', age: 20});

console.log(myQueue.pop()); // { name: 'Lee', age: 10 }
console.log(myQueue.pop()); // { name: 'Kim', age: 20 }
</xmp>

<p>
	<b class="em0">
		제네릭은 선언 시점이 아니라 생성 시점에 타입을 명시하여 하나의 타입만이 아닌 다양한 타입을 사용할 수 있도록 하는 기법이다.
		한 번의 선언으로 다양한 타입에 재사용이 가능하다는 장점이 있다.
	</b>
</p>
<p>
	<b class="em0">T는 제네릭을 선언할 때 관용적으로 사용되는 식별자로 타입 파라미터(Type parameter)라 한다.</b>
	T는 Type의 약자로 반드시 T를 사용하여야 하는 것은 아니다.
</p>
<p>
	또한 함수에도 제네릭을 사용할 수 있다.
	제네릭을 사용하면 하나의 타입만이 아닌 다양한 타입의 매개변수와 리턴값을 사용할 수 있다.
	아래 예제를 살펴보자.
</p>

<xmp class="xmp">
function reverse<T>(items: T[]): T[] {
  return items.reverse();
}
</xmp>

<p>
	reverse 함수는 인수의 타입에 의해 타입 매개변수가 결정된다. Reverse 함수는 다양한 타입의 요소로 구성된 배열을 인자로 전달받는다. 예를 들어 number 타입의 요소를 갖는 배열을 전달받으면 타입 매개변수는 number가 된다.
</p>

<pre class="mg0">
<code class="xmp">
function reverse<T>(items: T[]): T[] {
  return items.reverse();
}

const arg = [1, 2, 3, 4, 5];
// 인수에 의해 타입 매개변수가 결정된다.
const reversed = reverse(arg);
console.log(reversed); // [ 5, 4, 3, 2, 1 ]
</code>
</pre>

<p>
	만약 {name: string} 타입의 요소를 갖는 배열을 전달받으면 타입 매개변수는 {name: string}가 된다.
</p>

<pre class="mg0">
<code class="xmp">
function reverse<T>(items: T[]): T[] {
  return items.reverse();
}

const arg = [{ name: 'Lee' }, { name: 'Kim' }];
// 인수에 의해 타입 매개변수가 결정된다.
const reversed = reverse(arg);
console.log(reversed); // [ { name: 'Kim' }, { name: 'Lee' } ]
</code>
</pre>



<!-- ◇◆◇◆◇◆◇◆◇◆ -->
<h2 class="hb1 h2" id="Link">Reference Link</h2>





<div class="brclear"></div>
<hr class="line1 dott" />
<p>
<strong>History</strong>
: 20200207.~
20200210. 
20200207. 
</p>





<script src="../../share/inc/all_footer.js"></script>
</body>
</html>