<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<script>/*<![CDATA[*/
var $meta = {
	title: 'JavaScript (( PoiemaWeb | mNote',
	pageType: 'default'
};
/*]]>*/</script>
<script src="../../share/inc/html_head.js"></script>
<style type="text/css">/*<![CDATA[*/
/*]]>*/</style>
</head>
<body>
<script src="../../share/inc/all_header.js"></script>





<!-- ◇◆◇◆◇◆◇◆◇◆◇◆ -->
<h1 class="hb1 h1">
	JavaScript
		<small class="dpib fwn">
			((
			<a href="https://poiemaweb.com/coding" target="_blank">
				PoiemaWeb
			</a>
		</small>
</h1>


<!-- mtab1 -->
<div class="mtab1">
<menu>
<li><a href="#h2-01">JavaScript</a>
	<ul>
	<li><a href="#h3-01" class="em0">1 기본 개념과 동작 원리 이해의 중요성</a></li>
	<li><a href="#h3-02">2 자바스크립트란?</a></li>
	<li><a href="#h3-03">3 자바스크립트 개발 환경과 실행 방법</a></li>
	<li><a href="#h3-04">4 브라우저 동작 원리</a></li>
	<li><a href="#h3-05">5 자바스크립트의 기본 문법</a></li>
	<li><a href="#h3-06">6 데이터 타입과 변수</a></li>
	<li><a href="#h3-07">7 연산자</a></li>
	<li><a href="#h3-08">8 제어문</a></li>
	<li><a href="#h3-09">9 타입 변환과 단축 평가</a></li>
	<li><a href="#h3-10">10 객체</a></li>
	<li><a href="#h3-11" class="em0">11 객체와 변경불가성(Immutability)</a></li>
	<li><a href="#h3-12">12 함수</a></li>
	<li><a href="#h3-13">13 타입 체크</a></li>
	<li><a href="#h3-14">14 프로토타입</a></li>
	<li><a href="#h3-15">15 스코프</a></li>
	</ul>
</li>
<li><a href="#h2-01">JavaScript</a>
	<ul>
	<li><a href="#h3-16">16 보다 안정적인 자바스크립트 개발 환경을 위한 Strict mode</a></li>
	<li><a href="#h3-17">17 함수 호출 방식에 의해 결정되는 this</a></li>
	<li><a href="#h3-18">18 실행 컨텍스트와 자바스크립트의 동작 원리</a></li>
	<li><a href="#h3-19">19 클로저</a></li>
	<li><a href="#h3-20">20 자바스크립트 객체지향 프로그래밍</a></li>
	<li><a href="#h3-21" class="em2">21 빌트인 객체</a></li>
	<li><a href="#h3-22" class="em2">22 전역 객체</a></li>
	<li><a href="#h3-23" class="em2">23 Number 레퍼 객체</a></li>
	<li><a href="#h3-24" class="em2">24 수학 상수와 함수를 위한 Math 객체</a></li>
	<li><a href="#h3-25" class="em2">25 날짜와 시간을 위한 Date 객체</a></li>
	<li><a href="#h3-26" class="em2">26 정규표현식</a></li>
	<li><a href="#h3-27" class="em2">27 String 레퍼 객체</a></li>
	<li><a href="#h3-28" class="em2">28 배열</a></li>
	<li><a href="#h3-29" class="em3">29 자바스크립트 배열은 배열이 아니다</a></li>
	<li><a href="#h3-30" class="em2">30 배열 고차 함수</a></li>
	</ul>
</li>
<li><a href="#h2-01">JavaScript</a>
	<ul>
	<li><a href="#h3-31">31 문서 객체 모델(Document Object Model)</a></li>
	<li><a href="#h3-32">32 동기식 처리 모델 vs 비동기식 처리 모델</a></li>
	<li><a href="#h3-33">33 이벤트</a></li>
	<li><a href="#h3-34">34 디바이스의 방향 정보를 다루는 자바스크립트 이벤트</a></li>
	<li class="bdcc"><a href="#h3-35">35 비동기식 처리 모델과 Ajax</a></li>
	<li><a href="#h3-36">36 REST(Representational State Transfer) API</a> <b class="em">~ing~</b></li>
	<li><a href="#h3-37">37 Single Page Application & Routing</a></li>
	</ul>
</li>
</menu>
<!-- <menu>
<li><a href="#Task">Task</a></li>
<li><a href="#ToDo">ToDo</a></li>
<li><a href="#Unfinished">Unfinished</a></li>
<li><a href="#Finished">Finished</a></li>
</menu> -->
<!-- <menu>
<li><a href="#Outline">Outline</a></li>
<li><a href="#Start">Start</a></li>
<li><a href="#Task">Task</a></li>
<li><a href="#Link">Link</a></li>
</menu> -->
</div>
<!-- /mtab1 -->


<!-- ◇◆◇◆◇◆◇◆◇◆ -->
<h2 class="hb1 h2" id="h2-01">JavaScript</h2>

<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-01">1 기본 개념과 동작 원리 이해의 중요성</h3>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">1. 프로그래밍이란?</h4>
<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">2. 프로그래밍 언어</h4>
<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">3. Syntax & Semantics</h4>
<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">4. 기본 개념과 동작 원리 이해의 중요성</h4>

<p class="panel0 bg-info">
	빨리 가는 유일한 방법은 제대로 가는 것이다.<br />
	- 로버트 C. 마틴(Robert C. Martin), “클린 코드”의 저자<br />
</p>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-02">2 자바스크립트란?</h3>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">1. 자바스크립트의 탄생</h4>
<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">2. 자바스크립트의 파편화와 표준화</h4>
<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">3. 자바스크립트 성장의 역사</h4>

<p>
	자바스크립트는 <a href="https://ko.wikipedia.org/wiki/크로스_플랫폼">크로스 플랫폼</a>을 위한 가장 중요한 언어로 주목받고 있다.
	자바스크립트는 웹은 물론 모바일 하이브리드 앱(<a href="http://phonegap.com">PhoneGap</a>, <a href="https://ionicframework.com">Ionic</a>),
	서버 사이드(<a href="https://nodejs.org">NodeJS</a>),
	데스크톱(<a href="https://electronjs.org">Electron</a>),
	머신 러닝(<a href="https://js.tensorflow.org">TensorFlow.js</a>),
	로보틱스(<a href="http://johnny-five.io">Johnny-Five</a>)
	프로그래밍 언어로서 세계에서 가장 인기있는 프로그래밍 언어이다.
</p>

<p>
	이제 웹 애플리케이션은 데스크톱 애플리케이션과 비교해도 손색없는 성능과 사용자 경험을 제공하는 것이 필수가 되었고,
	개발 규모와 복잡도도 더불어 상승했다.
	이전의 개발 방식으로는 복잡해진 개발 과정을 수행하기 어려워졌고,
	이러한 필요에 따라 많은 패턴과 라이브러리가 출현하였다.
	이는 개발에 많은 도움을 주었지만 유연하면서 확장이 쉬운 애플리케이션 아키텍처 구축을 어렵게 하였고 필연적으로 프레임워크가 등장하게 되었다.
	SPA(Single Page Application)가 대중화되면서
	<a href="https://angular.io">Angular</a>,
	<a href="https://facebook.github.io/react">React</a>,
	<a href="https://vuejs.org">Vue.js</a> 등
	다양한 SPA 프레임워크/라이브러리 또한 많은 사용층을 확보하고 있다.
</p>

<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">4. JavaScript와 ECMAScript</h4>

<p>
	<strong class="h1 em big">ECMAScript</strong>는 자바스크립트의 표준 명세인 ECMA-262를 말하며
	프로그래밍 언어의 타입, 값, 객체와 프로퍼티, 함수, 빌트인 객체 등 핵심 문법(core syntax)을 규정한다.
	각 브라우저 제조사는 ECMAScript를 준수하여 브라우저에 내장되는 자바스크립트 엔진을 구현한다.
</p>

<p>
	<strong class="h1 em big">자바스크립트</strong>는 일반적으로 프로그래밍 언어로서 기본 뼈대를 이루는 ECMAScript와
	브라우저가 별도 지원하는 <strong><a href="https://www.w3.org/standards/webdesign/script">클라이언트 사이드 Web API</a></strong>,
	즉 DOM, BOM, Canvas, XMLHttpRequest, Fetch, requestAnimationFrame, SVG, Web Storage, Web Component, Web worker 등을 아우르는 개념이다.
</p>

<p>
	<b class="em0">클라이언트 사이드 Web API</b>는 ECMAScript와는 별도로 <a href="https://www.w3.org">World Wide Web Consortium (W3C)</a>에서 별도의 명세로 관리하고 있다.
	클라이언트 사이드 Web API의 자세한 내용은 <a href="https://developer.mozilla.org/ko/docs/Web/API">MDN web docs: Web API</a>를 참고하기 바란다.
</p>

<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">5. 자바스크립트의 특징</h4>

<ul class="bu">
<li>웹 브라우저에서 동작하는 유일한 프로그래밍 언어</li>
<li>인터프리터 언어(Interpreter language)</li>
<li>명령형(imperative), 함수형(functional), 프로토타입 기반(prototype-based) 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어</li>
<li>프로토타입 기반의 객체지향 언어</li>
</ul>

<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">6. ES6 브라우저 지원 현황</h4>

<a href="https://kangax.github.io/compat-table/es6">ECMAScript compatibility table</a></p>

<p>
	Internet Explorer를 제외한 모던 브라우저의 ES6 지원 비율은 96~ 99%로 거의 100%에 육박하지만
	Internet Explorer나 구형 브라우저는 ES6를 대부분 지원하지 않는다.
	따라서 Internet Explorer나 구형 브라우저를 고려해야 하는 상황이라면
	<a href="https://babeljs.io">babel</a>과 같은 트랜스파일러를 사용하여 ES6로 구현한 소스코드를 ES5 이하의 버전으로 다운그레이드할 필요가 있다.
	또한 ES6에서 도입된 모듈 import/export는 아직 대부분의 브라우저가 지원하고 있지 않다.
	따라서 프로젝트에서 모듈을 도입하려면 <a href="https://webpack.js.org">Webpack</a>과 같은 모듈 번들러를 사용해야 한다.
</p>

<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">Reference</h4>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-03">3 자바스크립트 개발 환경과 실행 방법</h3>


<pre class="mg0">
1. 웹 브라우저
	1.1 개발자 도구
	1.2 콘솔
	1.3 HTML에 포함된 자바스크립트를 브라우저에서 실행
	1.4 <b class="em">디버깅</b>
2. Node.js
	2.1 Node.js와 npm 소개
	2.2 Node.js 설치
	2.3 Node.js REPL
3. 비주얼 스튜디오 코드
	3.1 비주얼 스튜디오 코드 설치
	3.2 내장 터미널
	3.3 Code Runner 확장 플러그인
	3.4 Live Server 확장 플러그인
Reference
</pre>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-04">4 브라우저 동작 원리</h3>


<pre>
Reference
</pre>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-05">5 자바스크립트의 기본 문법</h3>


<pre>
1. 변수
2. 값
3. 연산자
4. 키워드
5. 주석
6. 문
7. 표현식
8. 문과 표현식의 비교
9. 함수
10. 객체
11. 배열
</pre>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-06">6 데이터 타입과 변수</h3>


<pre>
1. 데이터 타입
	1.1 원시 타입 (Primitive Data Type)
		1.1.1 number
		1.1.2 string
		1.1.3 boolean
		1.1.4 undefined
		1.1.5 null
		1.1.6 symbol
	1.2 객체 타입 (Object type, Reference type)
2. 변수
	2.1 변수의 선언
	2.1 변수의 중복 선언
	2.2 동적 타이핑 (Dynamic Typing)
	2.3 <b class="em">변수 호이스팅(Variable Hoisting)</b>
	2.4 var 키워드로 선언된 변수의 문제점
Reference
</pre>

<div class="brclear clearfix"></div>
<hr class="line1t dott" />


<p>
	타입을 나타내는 문자열을 반환하는 typeof 연산자로 null 값을 연산해 보면 null이 아닌 object가 나온다. 이는 자바스크립트의 설계상의 오류이다.
</p>

<pre class="mg0">
<code class="xmp">
var foo = null;
console.log(typeof foo); // object
</code>
</pre>

<p>
	따라서 <em class="em">null 타입을 확인할 때 typeof 연산자를 사용하면 안되고 일치 연산자(===)를 사용하여야 한다.</em>
</p>

<pre class="mg0">
<code class="xmp">
var foo = null;
console.log(typeof foo === null); // false
console.log(foo === null);        // true
</code>
</pre>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-07">7 연산자</h3>


<pre>
1. 표현식과 연산자
2. 문과 표현식
3. 연산자란?
4. 산술 연산자
	4.1. 이항 산술 연산자
	4.2. 단항 산술 연산자
	4.3. 문자열 연결 연산자
5. 할당 연산자
6. 비교 연산자
	6.1. 동등 / 일치 비교 연산자
	6.2. 대소 관계 비교 연산자
7. 삼항 조건 연산자
8. 논리 연산자
9. 쉼표 연산자
10. 그룹 연산자
11. typeof 연산
</pre>

<div class="brclear clearfix"></div>
<hr class="line1t dott" />


<p>
	<b class="em0">NaN</b>은 자신과 일치하지 않는 유일한 값이다. 따라서 숫자가 NaN인지 조사하려면 빌트인 함수 isNaN을 사용한다
</p>

<pre class="mg0">
<code class="xmp">
isNaN(NaN) // true
</code>
</pre>

<p>
	<b class="em0">typeof</b> 연산자는 자신의 뒤에 위치한 피연산자의 데이터 타입을 문자열로 반환한다.<br />
	typeof 연산자가 반환하는 문자열은 7개의 데이터 타입과 일치하지는 않는다.<br />
	typeof 연산자는 7가지 문자열 “string”, “number”, “boolean”, “undefined”, “symbol”, “object”, “function” 중 하나를 반환한다.<br />
	“null”을 반환하는 경우는 없으며 함수의 경우 “function”을 반환한다.<br />
</p>

<pre class="mg0">
<code class="xmp">
typeof ''              // "string"
typeof 1               // "number"
typeof NaN             // "number"
typeof true            // "boolean"
typeof undefined       // "undefined"
typeof Symbol()        // "symbol"
typeof null            // <em class="em">"object"</em>
typeof []              // "object"
typeof {}              // "object"
typeof new Date()      // "object"
typeof /test/gi        // "object"
typeof function () {}  // "function"
</code>
</pre>

<p>
	또 하나 주의해야 할 것이 있다. 선언하지 않은 식별자를 typeof 연산자로 연산해 보면 ReferenceError가 발생하지 않고 “undefined”를 반환한다.
</p>

<pre class="mg0">
<code class="xmp">
typeof undeclared  // <em class="em">"undefined"</em>
</code>
</pre>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-08">8 제어문</h3>


<pre>
1. 블록문
2. 조건문
	2.1 if..else 문
	2.2 switch 문
3. 반복문
	3.1 for 문
	3.2 while 문
	3.3 do…while 문
4. break 문
5. continue 문
</pre>


<div class="brclear clearfix"></div>
<hr class="line1t dott" />


<p>
	<b class="em0">삼항 조건 연산자</b>에서 <em class="em">세가지 경우의 수</em>를 경우
</p>

<pre class="mg0">
<code class="xmp">
var num = 2;

// 0은 false로 취급된다.
var kind = num ? (num > 0 ? '양수' : '음수') : '영';
console.log(kind); // 양수
</code>
</pre>

<p>
	<b class="em0">switch 문</b>에서 <em class="em">case 문을 중복해 사용</em>
</p>

<pre class="mg0">
<code class="xmp">
var year = 2000; // 2000년은 윤년으로 2월이 29일이다.
var month = 2;
var days = 0;

switch (month) {
  case 1: case 3: case 5: case 7: case 8: case 10: case 12:
    days = 31;
    break;
  case 4: case 6: case 9: case 11:
    days = 30;
    break;
  case 2:
    // 윤년 계산 알고리즘
    // 1. 년도가 4로 나누어 떨어지는 해는 윤년(2000, 2004, 2008, 2012, 2016, 2020…)
    // 2. 그 중에서 년도가 100으로 나누어 떨어지는 해는 평년(2000, 2100, 2200...)
    // 3. 그 중에서 년도가 400으로 나누어 떨어지는 해는 윤년(2000, 2400, 2800...)
    days = ((year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0)) ? 29 : 28;
    break;
  default:
    console.log('Invalid month');
}

console.log(days); // 29
</code>
</pre>

<p>
	중첩된 for 문의 내부 for 문에서 break 문을 실행하면 내부 for 문을 탈출하여 외부 for 문으로 진입한다.
	이때 <em class="em">내부 for 문이 아닌 외부 for 문을 탈출하려면</em> <b class="em0">레이블 문</b>을 사용한다.
</p>

<pre class="mg0">
<code class="xmp">
// outer라는 식별자가 붙은 레이블 for 문
outer: for (var i = 0; i < 3; i++) {
  for (var j = 0; j < 3; j++) {
    // i + j === 3이면 외부 for 문을 탈출한다.
    if (i + j === 3) break outer;
  }
}

console.log('Done!');
</code>
</pre>

<p>
	<b class="em0">continue 문</b> ::  if 문 내에서 실행해야 할 코드가 길다면 들여쓰기가 한 단계 더 깊어지므로 continue 문을 사용하는 것이 가독성이 더 좋다.
</p>

<pre class="mg0">
<code class="xmp">
// continue 문을 사용하지 않으면 if 문 내에 코드를 작성해야 한다.
for (var i = 0; i < string.length; i++) {
  // 'l'이면 카운트를 증가시킨다.
  if (string[i] === 'l') {
    count++;
    // code
    // code
    // code
  }
}

// continue 문을 사용면 if 문 밖에 코드를 작성할 수 있다.
for (var i = 0; i < string.length; i++) {
  // 'l'이 아니면 카운트를 증가시키지 않는다.
  if (string[i] !== 'l') continue;

  count++;
  // code
  // code
  // code
}
</code>
</pre>



<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-09">9 타입 변환과 단축 평가</h3>


<pre>
1. 타입 변환이란?
2. 암묵적 타입 변환
	2.1. 문자열 타입으로 변환
	2.2. 숫자 타입으로 변환
	2.3. 불리언 타입으로 변환
3. 명시적 타입 변환
	3.1 문자열 타입으로 변환
	3.2 숫자 타입으로 변환
	3.3 불리언 타입으로 변환
5. <b class="em">단축 평가</b>
</pre>


<div class="brclear clearfix"></div>
<hr class="line1t dott" />


<table class="t3 waha tttac lhD">
	<caption>
		<strong class="h1 blind">단축 평가</strong>
	</caption>
  <thead>
    <tr>
      <th>단축 평가 표현식</th>
      <th>평가 결과</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>true  || anything</td>
      <td>true</td>
    </tr>
    <tr>
      <td>false || anything</td>
      <td>anything</td>
    </tr>
    <tr>
      <td>true  &amp;&amp; anything</td>
      <td>anything</td>
    </tr>
    <tr>
      <td>false &amp;&amp; anything</td>
      <td>false</td>
    </tr>
  </tbody>
</table>


<p>
	<strong class="h1 em big">객체가 null인지 확인하고 프로퍼티를 참조할 때</strong>
</p>

<p>
	객체는 키(key)과 값(value)으로 구성된 프로퍼티(Property)들의 집합이다.<br />
	만약 객체가 null인 경우, 객체의 프로퍼티를 참조하면 타입 에러(TypeError)가 발생한다.<br />
	이때 단축 평가를 사용하면 에러를 발생시키지 않는다.<br />
</p>

<pre class="mg0">
<code class="xmp">
var elem = null;

console.log(elem.value); // TypeError: Cannot read property 'value' of null
console.log(elem && elem.value); // null
</code>
</pre>

<p>
	<strong class="h1 em big">함수의 인수(argument)를 초기화할 때</strong>
</p>
<p>
	함수를 호출할 때 인수를 전달하지 않으면 매개변수는 undefined를 갖는다.<br />
	이때 단축 평가를 사용하여 매개변수의 기본값을 설정하면 undefined로 인해 발생할 수 있는 에러를 방지할 수 있다.<br />
</p>

<pre class="mg0">
<code class="xmp">
// 단축 평가를 사용한 매개변수의 기본값 설정
function getStringLength(str) {
  str = str || '';
  return str.length;
}

getStringLength();     // 0
getStringLength('hi'); // 2

// ES6의 매개변수의 기본값 설정
function getStringLength(str = '') {
  return str.length;
}

getStringLength();     // 0
getStringLength('hi'); // 2
</code>
</pre>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-10">10 객체</h3>


<pre>
1. 객체(Object)란?
	1.1 프로퍼티
	1.2 메소드
2. 객체 생성 방법
	2.1 객체 리터럴
	2.2 Object 생성자 함수
	2.3 생성자 함수
3. 객체 프로퍼티 접근
	3.1 프로퍼티 키
	3.2 프로퍼티 값 읽기
	3.3 프로퍼티 값 갱신
	3.4 프로퍼티 동적 생성
	3.5 프로퍼티 삭제
	3.6 for-in 문
4. <b class="em">Pass-by-reference</b>
5. <b class="em">Pass-by-value</b>
6. 객체의 분류
Reference
</pre>


<div class="brclear clearfix"></div>
<hr class="line1t dott" />


<strong class="h1 em big">Pass-by-reference</strong>

<pre class="mg0">
<code class="xmp">
// Pass-by-reference
var foo = {
  val: 10
}

var bar = foo;
console.log(foo.val, bar.val); // 10 10
console.log(foo === bar);      // true

bar.val = 20;
console.log(foo.val, bar.val); // 20 20
console.log(foo === bar);      // true
</code>
</pre>


<strong class="h1 em big">Pass-by-value</strong>

<pre class="mg0">
<code class="xmp">
// Pass-by-value
var a = 1;
var b = a;

console.log(a, b);    // 1  1
console.log(a === b); // true

a = 10;
console.log(a, b);    // 1  10
console.log(a === b); // false
</code>
</pre>



<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-11">11 객체와 변경불가성(Immutability)</h3>


<pre>
1. immutable value vs. mutable value
2. 불변 데이터 패턴(immutable data pattern)
	2.1 Object.assign
	2.2 Object.freeze
	2.3 Immutable.js
Reference
</pre>


<div class="brclear clearfix"></div>
<hr class="line1t dott" />


<p>
	<a href="https://ko.wikipedia.org/wiki/옵서버_패턴" target="_blank"><strong class="h1 em big">Observer 패턴</strong></a>
</p>


<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">2.1 Object.assign</h5>


<p>
	Object.assign은 타킷 객체로 소스 객체의 프로퍼티를 복사한다.
	이때 소스 객체의 프로퍼티와 동일한 프로퍼티를 가진 타켓 객체의 프로퍼티들은 소스 객체의 프로퍼티로 덮어쓰기된다.
	리턴값으로 타킷 객체를 반환한다. <em class="em3">ES6에서 추가된 메소드이며 Internet Explorer는 지원하지 않는다.</em>
</p>

<pre class="mg0">
<code class="xmp">
// Syntax
Object.assign(target, ...sources)
</code>
</pre>

<pre class="mg0">
<code class="xmp">
// Copy
const obj = { a: 1 };
const copy = Object.assign({}, obj);
console.log(copy); // { a: 1 }
console.log(obj == copy); // false

// Merge
const o1 = { a: 1 };
const o2 = { b: 2 };
const o3 = { c: 3 };

const merge1 = Object.assign(o1, o2, o3);

console.log(merge1); // { a: 1, b: 2, c: 3 }
console.log(o1);     // { a: 1, b: 2, c: 3 }, 타겟 객체가 변경된다!

// Merge
const o4 = { a: 1 };
const o5 = { b: 2 };
const o6 = { c: 3 };

const merge2 = Object.assign({}, o4, o5, o6);

console.log(merge2); // { a: 1, b: 2, c: 3 }
console.log(o4);     // { a: 1 }
</code>
</pre>

<p>
	Object.assign을 사용하여 기존 객체를 변경하지 않고 객체를 복사하여 사용할 수 있다.
	<em class="em">Object.assign은 완전한 deep copy를 지원하지 않는다. 객체 내부의 객체(Nested Object)는 Shallow copy된다.</em>
</p>

<pre class="mg0">
<code class="xmp">
const user1 = {
  name: 'Lee',
  address: {
    city: 'Seoul'
  }
};

// 새로운 빈 객체에 user1을 copy한다.
const user2 = Object.assign({}, user1);
// user1과 user2는 참조값이 다르다.
console.log(user1 === user2); // false

user2.name = 'Kim';
console.log(user1.name); // Lee
console.log(user2.name); // Kim

// 객체 내부의 객체(Nested Object)는 Shallow copy된다.
console.log(user1.address === user2.address); // true

user1.address.city = 'Busan';
console.log(user1.address.city); // Busan
console.log(user2.address.city); // Busan
</code>
</pre>

<p>
	user1 객체를 빈객체에 복사하여 새로운 객체 user2를 생성하였다. user1과 user2는 어드레스를 공유하지 않으므로 한 객체를 변경하여도 다른 객체에 아무런 영향을 주지 않는다.
</p>
<p>
	주의할 것은 user1 객체는 const로 선언되어 재할당은 할 수 없지만 객체의 프로퍼티는 보호되지 않는다. 다시 말하자면 객체의 내용은 변경할 수 있다.
</p>


<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">2.2 Object.freeze</h5>

<p>
	Object.freeze()를 사용하여 불변(immutable) 객체로 만들수 있다.
</p>

<pre class="mg0">
<code class="xmp">
const user1 = {
  name: 'Lee',
  address: {
    city: 'Seoul'
  }
};

// Object.assign은 완전한 deep copy를 지원하지 않는다.
const user2 = Object.assign({}, user1, {name: 'Kim'});

console.log(user1.name); // Lee
console.log(user2.name); // Kim

Object.freeze(user1);

user1.name = 'Kim'; // 무시된다!

console.log(user1); // { name: 'Lee', address: { city: 'Seoul' } }

console.log(Object.isFrozen(user1)); // true
</code>
</pre>


<p>
	하지만 객체 내부의 객체(Nested Object)는 변경가능하다.
</p>


<pre class="mg0">
<code class="xmp">
const user = {
  name: 'Lee',
  address: {
    city: 'Seoul'
  }
};

Object.freeze(user);

user.address.city = 'Busan'; // 변경된다!
console.log(user); // { name: 'Lee', address: { city: 'Busan' } }
</code>
</pre>

<p>
	내부 객체까지 변경 불가능하게 만들려면 Deep freeze를 하여야 한다.
</p>

<pre class="mg0">
<code class="xmp">
function deepFreeze(obj) {
  const props = Object.getOwnPropertyNames(obj);

  props.forEach((name) => {
    const prop = obj[name];
    if(typeof prop === 'object' && prop !== null) {
      deepFreeze(prop);
    }
  });
  return Object.freeze(obj);
}

const user = {
  name: 'Lee',
  address: {
    city: 'Seoul'
  }
};

deepFreeze(user);

user.name = 'Kim';           // 무시된다
user.address.city = 'Busan'; // 무시된다

console.log(user); // { name: 'Lee', address: { city: 'Seoul' } }
</code>
</pre>


<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">2.3 Immutable.js</h5>


<p>
	Object.assign과 Object.freeze을 사용하여 불변 객체를 만드는 방법은 번거러울 뿐더러 성능상 이슈가 있어서 큰 객체에는 사용하지 않는 것이 좋다.<br />
	또 다른 대안으로 Facebook이 제공하는
	<b class="em0"><a href="https://facebook.github.io/immutable-js/" target="_blank">Immutable.js</a></b>를 사용하는 방법이 있다.<br />
	Immutable.js는 List, Stack, Map, OrderedMap, Set, OrderedSet, Record와 같은 영구 불변 (Permit Immutable) 데이터 구조를 제공한다.<br />
	npm을 사용하여 Immutable.js를 설치한다.<br />
</p>

<pre class="mg0">
<code class="xmp">
$ npm install immutable
</code>
</pre>

<p>
	Immutable.js의 Map 모듈을 임포트하여 사용한다.
</p>

<pre class="mg0">
<code class="xmp">
const { Map } = require('immutable')
const map1 = Map({ a: 1, b: 2, c: 3 })
const map2 = map1.set('b', 50)
map1.get('b') // 2
map2.get('b') // 50
</code>
</pre>

<p>
	map1.set(‘b’, 50)의 실행에도 불구하고 map1은 불변하였다. map1.set()은 결과를 반영한 새로운 객체를 반환한다.
</p>




<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-12">12 함수</h3>


<pre>
1. 함수 정의
	1.1 함수 선언문
	1.2 함수 표현식
	1.3 Function 생성자 함수
2. 함수 호이스팅
3. First-class object (일급 객체)
4. 매개변수(Parameter, 인자)
	4.1 매개변수(parameter, 인자) vs 인수(argument)
	4.2 Call-by-value
	4.3 Call-by-reference
5. 반환값
6. 함수 객체의 프로퍼티
	6.1 arguments 프로퍼티
	6.2 caller 프로퍼티
	6.3 length 프로퍼티
	6.4 name 프로퍼티
	6.5 __proto__ 접근자 프로퍼티
	6.6 prototype 프로퍼티
7. 함수의 다양한 형태
	7.1 즉시 실행 함수
	7.2 내부 함수
	7.3 재귀 함수
	7.4 콜백 함수
</pre>

<div class="brclear clearfix"></div>
<hr class="line1t dott" />


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">2. 함수 호이스팅</h4>

<p>
	3가지의 함수 정의 방식을 알아보았다.
	정의 방식은 달라도 결국 Function 생성자 함수를 통해 함수를 생성하는 것까지 확인하였다.
	그런데 이 3가지 함수 정의 방식은 동작 방식에 약간의 차이가 있다.
</p>

<p>
	<strong class="h1 em6"><b class="em0">함수 선언문</b>은 함수가 정의되기 이전에 함수 호출이 <em class="em4">가능</em>하다.</strong>
</p>

<pre class="mg0">
<code class="xmp">
var res = square(5);

function square(number) {
  return number * number;
}
</code>
</pre>

<p>
	함수 선언문으로 정의된 함수는 자바스크립트 엔진이 스크립트가 로딩되는 시점에 바로 초기화하고 이를 VO(variable object)에 저장한다.<br />
	즉, <em class="em">함수 선언, 초기화, 할당이 한번에 이루어진다.</em> 그렇기 때문에 함수 선언의 위치와는 상관없이 소스 내 어느 곳에서든지 호출이 가능하다.
</p>

<p>
	<strong class="h1 em6"><b class="em0">함수 표현식</b>은 함수가 정의되기 이전에 함수 호출이 <em class="em1">불가능</em>하다.</strong>
</p>

<pre class="mg0">
<code class="xmp">
var res = square(5); // TypeError: square is not a function

var square = function(number) {
  return number * number;
}
</code>
</pre>

<b class="em0">함수 표현식의 경우 함수 호이스팅이 아니라 <em class="em">변수 호이스팅</em>이 발생한다.</b>


<p class="panel0 bg-info">
	변수 호이스팅은 변수 생성 및 초기화와 할당이 분리되어 진행된다.
	호이스팅된 변수는 undefined로 초기화 되고 실제값의 할당은 할당문에서 이루어진다.
</p>

<p>
	JavaScript: The Good Parts의 저자이며 자바스크립트의 권위자인 더글러스 크락포드(Douglas Crockford)는
	이와 같은 문제 때문에 <em class="em">함수 표현식만을 사용할 것을 권고</em>하고 있다.
	함수 호이스팅이 함수 호출 전 반드시 함수를 선언하여야 한다는 규칙을 무시하므로 코드의 구조를 엉성하게 만들 수 있다고 지적한다.
</p>
<p>
	또한 함수 선언문으로 함수를 정의하면 사용하기에 쉽지만
	대규모 애플리케이션을 개발하는 경우 인터프리터가 너무 많은 코드를 변수 객체(VO)에 저장하므로
	애플리케이션의 응답속도는 현저히 떨어질 수 있으므로 주의해야 할 필요가 있다.
</p>

<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">3. First-class object (일급 객체)</h4>

<pre class="mg0">
<code class="xmp">
// <em class="em">1. 무명의 리터럴로 표현이 가능하다.</em>
// <em class="em">2. 변수나 자료 구조에 저장할 수 있다.</em>
var increase = function (num) {
  return ++num;
};

var decrease = function (num) {
  return --num;
};

var predicates = { increase, decrease };

// <em class="em">3. 함수의 매개변수에 전달할 수 있다.</em>
// <em class="em">4. 반환값으로 사용할 수 있다.</em>
function makeCounter(predicate) {
  var num = 0;

  return function () {
    num = predicate(num);
    return num;
  };
}

var increaser = makeCounter(predicates.increase);
console.log(increaser()); // 1
console.log(increaser()); // 2

var decreaser = makeCounter(predicates.decrease);
console.log(decreaser()); // -1
console.log(decreaser()); // -2
</code>
</pre>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">4. 매개변수(Parameter, 인자)</h4>


<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">4.1 매개변수(parameter, 인자) vs 인수(argument)</h5>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">5. 반환값</h4>

<p>
	함수는 자신을 호출한 코드에게 수행한 결과를 반환(return)할 수 있다. 이때 반환된 값을 반환값(return value)이라 한다.
</p>

<ul class="bu">
<li>return 키워드는 함수를 호출한 코드(caller)에게 값을 반환할 때 사용한다.</li>
<li>함수는 배열 등을 이용하여 한 번에 여러 개의 값을 리턴할 수 있다.</li>
<li>함수는 반환을 생략할 수 있다. 이때 함수는 암묵적으로 undefined를 반환한다.</li>
<li>자바스크립트 해석기는 return 키워드를 만나면 함수의 실행을 중단한 후, 함수를 호출한 코드로 되돌아간다. 만일 return 키워드 이후에 다른 구문이 존재하면 그 구문은 실행되지 않는다.</li>
</ul>

<pre class="mg0">
<code class="xmp">
function calculateArea(width, height) {
  var area = width * height;
  return area; // 단일 값의 반환
}
console.log(calculateArea(3, 5)); // 15
console.log(calculateArea(8, 5)); // 40

function getSize(width, height, depth) {
  var area = width * height;
  var volume = width * height * depth;
  return [area, volume]; // 복수 값의 반환
}

console.log('area is ' + <em class="em">getSize(3, 2, 3)[0]</em>);   // area is 6
console.log('volume is ' + <em class="em">getSize(3, 2, 3)[1]</em>); // volume is 18
</code>
</pre>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">6. 함수 객체의 프로퍼티</h4>

<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">6.1 arguments 프로퍼티</h5>


<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">6.2 caller 프로퍼티</h5>

<p>
	caller 프로퍼티는 자신을 호출한 함수를 의미한다.
</p>

<pre class="mg0">
<code class="xmp">
function foo(func) {
  var res = func();
  return res;
}

function bar() {
  return 'caller : ' + bar.caller;
}

console.log(foo(bar)); // caller : function foo(func) {...}
console.log(bar());    // null (browser에서의 실행 결과)
</code>
</pre>


<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">6.3 length 프로퍼티</h5>


<p>
	length 프로퍼티는 함수 정의 시 작성된 매개변수 갯수를 의미한다.
</p>

<pre class="mg0">
<code class="xmp">
function foo() {}
console.log(foo.length); // 0

function bar(x) {
  return x;
}
console.log(bar.length); // 1

function baz(x, y) {
  return x * y;
}
console.log(baz.length); // 2
</code>
</pre>

<p>
	arguments.length의 값과는 다를 수 있으므로 주의하여야 한다. arguments.length는 함수 호출시 인자의 갯수이다.
</p>


<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">6.4 name 프로퍼티</h5>

<p>
	함수명을 나타낸다. 기명함수의 경우 함수명을 값으로 갖고 익명함수의 경우 빈문자열을 값으로 갖는다.
</p>

<pre class="mg0">
<code class="xmp">
// 기명 함수 표현식(named function expression)
var namedFunc = function multiply(a, b) {
  return a * b;
};
// 익명 함수 표현식(anonymous function expression)
var anonymousFunc = function(a, b) {
  return a * b;
};

console.log(namedFunc.name);     // multiply
console.log(anonymousFunc.name); // ''
</code>
</pre>


<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">6.5 __proto__ 접근자 프로퍼티</h5>

<p>
	모든 객체는 [[Prototype]]이라는 내부 슬롯이 있다.<br />
	<b class="em0">[[Prototype]] 내부 슬롯</b>은 프로토타입 객체를 가리킨다.<br />
	<b class="em0">프로토타입 객체</b>란 프로토타입 기반 객체 지향 프로그래밍의 근간을 이루는 객체로서 객체간의 상속(Inheritance)을 구현하기 위해 사용된다.<br />
	즉, 프로토타입 객체는 다른 객체에 공유 프로퍼티를 제공하는 객체를 말한다.<br />
</p>
<p>
	<b class="em0"><strong class="h1 em6 big">__proto__ 프로퍼티</strong></b>는 [[Prototype]] 내부 슬롯이 가리키는 프로토타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티이다.<br />
	내부 슬롯에는 직접 접근할 수 없고 간접적인 접근 방법을 제공하는 경우에 한하여 접근할 수 있다.<br />
	[[Prototype]] 내부 슬롯에도 직접 접근할 수 없으며 __proto__ 접근자 프로퍼티를 통해 간접적으로 프로토타입 객체에 접근할 수 있다.<br />
</p>

<pre class="mg0">
<code class="xmp">
// __proto__ 접근자 프로퍼티를 통해 자신의 프로토타입 객체에 접근할 수 있다.
// 객체 리터럴로 셍성한 객체의 프로토타입 객체는 Object.prototype이다.
console.log({}.__proto__ === Object.prototype); // true
</code>
</pre>

<p>
	<b class="em0">__proto__ 프로퍼티</b>는 객체가 직접 소유하는 프로퍼티가 아니라 모든 객체의 프로토타입 객체인 Object.prototype 객체의 프로퍼티이다.<br />
	모든 객체는 상속을 통해 __proto__ 접근자 프로퍼티는 사용할 수 있다.<br />
</p>

<pre class="mg0">
<code class="xmp">
// 객체는 __proto__ 프로퍼티를 소유하지 않는다.
console.log(Object.getOwnPropertyDescriptor({}, '__proto__'));
// undefined

// __proto__ 프로퍼티는 모든 객체의 프로토타입 객체인 Object.prototype의 접근자 프로퍼티이다.
console.log(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__'));
// {get: ƒ, set: ƒ, enumerable: false, configurable: true}

// 모든 객체는 Object.prototype의 접근자 프로퍼티 __proto__를 상속받아 사용할 수 있다.
console.log({}.__proto__ === Object.prototype); // true
</code>
</pre>

<p>
	함수도 객체이므로 __proto__ 접근자 프로퍼티를 통해 프로토타입 객체에 접근할 수 있다.
</p>

<pre class="mg0">
<code class="xmp">
// 함수 객체의 프로토타입 객체는 Function.prototype이다.
console.log((function() {}).__proto__ === Function.prototype); // true
</code>
</pre>


<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">6.6 prototype 프로퍼티</h5>


<p>
	prototype 프로퍼티는 함수 객체만이 소유하는 프로퍼티이다. 즉 일반 객체에는 prototype 프로퍼티가 없다.
</p>

<pre class="mg0">
<code class="xmp">
// 함수 객체는 prototype 프로퍼티를 소유한다.
console.log(Object.getOwnPropertyDescriptor(function() {}, 'prototype'));
// {value: {…}, writable: true, enumerable: false, configurable: false}

// 일반 객체는 prototype 프로퍼티를 소유하지 않는다.
console.log(Object.getOwnPropertyDescriptor({}, 'prototype'));
// undefined
</code>
</pre>

<p>
	prototype 프로퍼티는 함수가 객체를 생성하는 생성자 함수로 사용될 때, 생성자 함수가 생성한 인스턴스의 프로토타입 객체를 가리킨다.
</p>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">7. 함수의 다양한 형태</h4>

<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">7.1 즉시 실행 함수</h5>
<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">7.2 내부 함수</h5>
<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">7.3 재귀 함수</h5>

<p>
	재귀 함수(Recusive function)는 자기 자신을 호출하는 함수를 말한다.
</p>

<pre class="mg0">
<code class="xmp">
// 피보나치 수열
// 피보나치 수는 0과 1로 시작하며, 다음 피보나치 수는 바로 앞의 두 피보나치 수의 합이 된다.
// 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, ...
function fibonacci(n) {
  if (n < 2) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

console.log(fibonacci(0)); // 0
console.log(fibonacci(1)); // 1
console.log(fibonacci(2)); // 1
console.log(fibonacci(3)); // 2
console.log(fibonacci(4)); // 3
console.log(fibonacci(5)); // 5
console.log(fibonacci(6)); // 8

// 팩토리얼
// 팩토리얼(계승)은 1부터 자신까지의 모든 양의 정수의 곱이다.
// n! = 1 * 2 * ... * (n-1) * n
function factorial(n) {
  if (n < 2) return 1;
  return factorial(n - 1) * n;
}

console.log(factorial(0)); // 1
console.log(factorial(1)); // 1
console.log(factorial(2)); // 2
console.log(factorial(3)); // 6
console.log(factorial(4)); // 24
console.log(factorial(5)); // 120
console.log(factorial(6)); // 720
</code>
</pre>

<p>
	재귀 함수는 자신을 무한히 연쇄 호출하므로 호출을 멈출 수 있는 탈출 조건을 반드시 만들어야 한다.
	탈출 조건이 없는 경우, 함수가 무한 호출되어 stackoverflow 에러가 발생한다.
	위의 두개의 예제 모두 조건식을 통해 재귀 호출을 중지하고 있다.
</p>
<p>
	재귀 함수는 반복 연산을 간단히 구현할 수 있다는 장점이 있지만 무한 반복에 빠질 수 있고, stackoverflow 에러를 발생시킬 수 있으므로 주의하여야 한다.
</p>
<p>
	대부분의 재귀 함수는 for나 while 문으로 구현이 가능하다. 반복문보다 재귀 함수를 통해 보다 직관적으로 이해하기 쉬운 구현이 가능한 경우에만 한정적으로 적용하는 것이 바람직하다.
</p>


<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">7.4 콜백 함수</h5>

<p>
	콜백 함수(Callback function)는 함수를 명시적으로 호출하는 방식이 아니라 특정 이벤트가 발생했을 때 시스템에 의해 호출되는 함수를 말한다.
</p>
<p>
	콜백 함수가 자주 사용되는 대표적인 예는 이벤트 핸들러 처리이다.
</p>

<xmp class="xmp">
<!DOCTYPE html>
<html>
<body>
  <button id="myButton">Click me</button>
  <script>
    var button = document.getElementById('myButton');
    button.addEventListener('click', function() {
      console.log('button clicked!');
    });
  </script>
</body>
</html>
</xmp>

<p>
	Javascript의 함수는 일급객체이다. 따라서 Javascript의 함수는 흡사 변수와 같이 사용될 수 있다.
</p>
<p>
	콜백 함수는 매개변수를 통해 전달되고 전달받은 함수의 내부에서 어느 특정시점에 실행된다.
</p>
<p>
	setTimeout()의 콜백 함수를 살펴보자. 두번째 매개변수에 전달된 시간이 경과되면 첫번째 매개변수에 전달한 콜백 함수가 호출된다.
</p>

<pre class="mg0">
<code class="xmp">
setTimeout(function () {
  console.log('1초 후 출력된다.');
}, 1000);
</code>
</pre>

<p>
	콜백 함수는 주로 비동기식 처리 모델(Asynchronous processing model)에 사용된다.
	비동기식 처리 모델이란 <!-- 처리가 종료하면 호출될 함수 -->(콜백함수)를 미리 매개변수에 전달하고 처리가 종료하면 콜백함수를 호출하는 것이다.
</p>
<p>
	콜백함수는 콜백 큐에 들어가 있다가 해당 이벤트가 발생하면 호출된다.
	콜백 함수는 클로저이므로 콜백 큐에 단독으로 존재하다가 호출되어도 콜백함수를 전달받은 함수의 변수에 접근할 수 있다.
</p>

<pre class="mg0">
<code class="xmp">
function doSomething() {
  var name = 'Lee';

  setTimeout(function () {
    console.log('My name is ' + name);
  }, 100);
}

doSomething(); // My name is Lee
</code>
</pre>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-13">13 타입 체크</h3>


<pre>
1. typeof
2. Object.prototype.toString
3. instanceof
4. 유사 배열 객체
</pre>


<div class="brclear clearfix"></div>
<hr class="line1t dott" />


<p>
	<strong class="h1 em6 big">타입을 반환하는 함수와 타입별로 체크하는 기능 만들기</strong>
</p>

<pre class="mg0">
<code class="xmp">
function getType(target) {
  return Object.prototype.toString.call(target).slice(8, -1);
}

function isString(target) {
  return getType(target) === 'String';
}

function isNumber(target) {
  return getType(target) === 'Number';
}

function isBoolean(target) {
  return getType(target) === 'Boolean';
}

function isNull(target) {
  return getType(target) === 'Null';
}

function isUndefined(target) {
  return getType(target) === 'Undefined';
}

function isObject(target) {
  return getType(target) === 'Object';
}

function isArray(target) {
  return getType(target) === 'Array';
}

function isDate(target) {
  return getType(target) === 'Date';
}

function isRegExp(target) {
  return getType(target) === 'RegExp';
}

function isFunction(target) {
  return getType(target) === 'Function';
}
</code>
</pre>


<p>
	<strong class="h1 em6 big">css 함수에 타입 체크 기능을 추가</strong>
</p>


<xmp class="xmp">
<!DOCTYPE html>
<html>
<body>
  <p>Hello</p>
  <script>
    function getType(target) {
      return Object.prototype.toString.call(target).slice(8, -1);
    }

    function isString(target) {
      return getType(target) === 'String';
    }

    function isElement(target) {
      return !!(target && target instanceof HTMLElement);
      // 또는 `nodeType`을 사용할 수도 있다.
      // return !!(target && target.nodeType === 1);
    }

    // HTMLElement를 상속받은 모든 DOM 요소에 css 프로퍼티를 추가하고 값을 할당한다.
    function css(elem, prop, val) {
      // type checking
      if (!(isElement(elem) && isString(prop) && isString(val))) {
        throw new TypeError('매개변수의 타입이 맞지 않습니다.');
      }
      elem.style[prop] = val;
    }

    css(document.querySelector('p'), 'color', 'red');
    css(document.querySelector('div'), 'color', 'red');
    // TypeError: 매개변수의 타입이 맞지 않습니다.
  </script>
</body>
</html>
</xmp>

<!-- ◇◆◇◆◇◆-->
<h4 class="hb1 h4">4. 유사 배열 객체</h4>

<p>
	배열인지 체크하기 위해서는 Array.isArray 메소드를 사용한다.
</p>

<pre class="mg0">
<code class="xmp">
console.log(Array.isArray([]));    // true
console.log(Array.isArray({}));    // false
console.log(Array.isArray('123')); // false
</code>
</pre>

<p>
	유사 배열 객체(array-like object)은 length 프로퍼티를 갖는 객체로
	문자열, arguments, HTMLCollection, NodeList 등은 유사 배열이다.
	유사 배열 객체는 length 프로퍼티가 있으므로 순회할 수 있으며
	call, apply 함수를 사용하여 배열의 메소드를 사용할 수도 있다.
</p>
<p>
	어떤 객체가 유사 배열인지 체크하려면 우선 length 프로퍼티를 갖는지 length 프로퍼티의 값이 정상적인 값인지 체크한다.
</p>

<xmp class="xmp">
<!DOCTYPE html>
<html>
<body>
  <ul>
    <li></li>
    <li></li>
    <li></li>
  </ul>
  <script>
    console.log(undefined == null)
    const isArrayLike = function (collection) {
      // 배열 인덱스: 32bit 정수(2의 32제곱 - 1)
      // 유사 배열 인덱스: 자바스크립트로 표현할 수 있는 양의 정수(2의 53제곱 - 1)
      const MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
      // 빈문자열은 유사배열이다. undefined == null => true
      const length = collection == null ? undefined : collection.length;
      return typeof length === 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
    };

    // true
    console.log(isArrayLike([]));
    console.log(isArrayLike('abc'));
    console.log(isArrayLike(''));
    console.log(isArrayLike(document.querySelectorAll('li')));
    console.log(isArrayLike(document.getElementsByName('li')));
    console.log(isArrayLike({ length: 0 }));
    (function () {
      console.log(isArrayLike(arguments));
    }());

    // false
    console.log(isArrayLike(123));
    console.log(isArrayLike(document.querySelector('li')));
    console.log(isArrayLike({ foo: 1 }));
    console.log(isArrayLike());
    console.log(isArrayLike(null));
  </script>
</body>
</html>
</xmp>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-14">14 프로토타입</h3>


<pre>
1. 프로토타입 객체
2. [[Prototype]] vs prototype 프로퍼티
3. constructor 프로퍼티
4. Prototype chain
	4.1 객체 리터럴 방식으로 생성된 객체의 프로토타입 체인
	4.2 생성자 함수로 생성된 객체의 프로토타입 체인
5. 프로토타입 객체의 확장
6. 원시 타입(Primitive data type)의 확장
7. 프로토타입 객체의 변경
8. 프로토타입 체인 동작 조건
</pre>


<div class="brclear clearfix"></div>
<hr class="line1t dott" />


<p>
	<strong class="h1 em big">프로토타입 체인 Prototype chain</strong>
</p>



<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-15">15 스코프</h3>


<pre>
1. 스코프란?
2. 스코프의 구분
3. 자바스크립트 스코프의 특징
4. 전역 스코프(Global scope)
5. 비 블록 레벨 스코프(Non block-level scope)
6. 함수 레벨 스코프(Function-level scope)
7. <b class="em">렉시컬 스코프 (Lexical scope)</b>
8. 암묵적 전역 (implicit global)
9. 최소한의 전역변수 사용
10. 즉시실행함수를 이용한 전역변수 사용 억제
Reference
</pre>


<div class="brclear clearfix"></div>
<hr class="line1t dott" />


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">7. 렉시컬 스코프</h4>

<p>
	아래 예제의 실행 결과를 예측해보자.
</p>

<pre class="mg0">
<code class="xmp">
var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // ?
bar(); // ?
</code>
</pre>

<p>
	위 예제의 실행 결과는 함수 bar의 상위 스코프가 무엇인지에 따라 결정된다.<br />
	두가지 패턴을 예측할 수 있는데<br />
	첫번째는 함수를 어디서 호출하였는지에 따라 상위 스코프를 결정하는 것이고<br />
	두번째는 함수를 어디서 선언하였는지에 따라 상위 스코프를 결정하는 것이다.<br />
	첫번째 방식으로 함수의 상위 스코프를 결정한다면 함수 bar의 상위 스코프는 함수 foo와 전역일 것이고,<br />
	두번째 방식으로 함수의 스코프를 결정한다면 함수 bar의 스코프는 전역일 것이다.<br />
</p>

<p>
	프로그래밍 언어는 이 두가지 방식 중 하나의 방식으로 함수의 상위 스코프를 결정한다.<br />
	첫번째 방식(<em class="em0">호출 위치에 따라 상위 스코프 결정</em>)을 <b class="em0">동적 스코프(Dynamic scope)</b>라 하고,<br />
	두번째 방식(<em class="em">선언 위치에 따라 상위 스코프 결정</em>)을 <b class="em">렉시컬 스코프(Lexical scope)</b> 또는 <b class="em">정적 스코프(Static scope)</b>라 한다.<br />
	자바스크립트를 비롯한 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다.<br />
</p>

<p>
	렉시컬 스코프는 함수를 어디서 호출하는지가 아니라 어디에 선언하였는지에 따라 결정된다.<br />
	자바스크립트는 렉시컬 스코프를 따르므로 함수를 선언한 시점에 상위 스코프가 결정된다.<br />
	함수를 어디에서 호출하였는지는 스코프 결정에 아무런 의미를 주지 않는다.<br />
	위 예제의 함수 bar는 전역에 선언되었다.<br />
	따라서 함수 bar의 상위 스코프는 전역 스코프이고 위 예제는 전역 변수 x의 값 1을 두번 출력한다.<br />
</p>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">8. 암묵적 전역</h4>

<pre class="mg0">
<code class="xmp">
var x = 10; // 전역 변수

function foo () {
  // 선언하지 않은 식별자
  y = 20;
  console.log(x + y);
}

foo(); // 30
</code>
</pre>

<p>
	위 예제의 y는 선언하지 않은 식별자이다.
</p>
<p>
	자바스크립트 엔진은 <code>y = 20</code>을 <code>window.y = 20</code>으로 해석하여 프로퍼티를 동적 생성한다.<br />
	결국 y는 <em class="em">전역 객체의 프로퍼티가 되어 마치 전역 변수처럼 동작</em>한다. 이러한 현상을 <b class="em0">암묵적 전역(implicit global)</b>이라 한다.<br />
</p>

<pre class="mg0">
<code class="xmp">
// 전역 변수 x는 호이스팅이 발생한다.
console.log(x); // undefined
// <em class="em">전역 변수가 아니라 단지 전역 프로퍼티인 y는 호이스팅이 발생하지 않는다.</em>
console.log(y); // ReferenceError: y is not defined

var x = 10; // 전역 변수

function foo () {
  // 선언하지 않은 변수
  y = 20;
  console.log(x + y);
}

foo(); // 30
</code>
</pre>

<pre class="mg0">
<code class="xmp">
var x = 10; // 전역 변수

function foo () {
  // 선언하지 않은 변수
  y = 20;
  console.log(x + y);
}

foo(); // 30

console.log(window.x); // 10
console.log(window.y); // 20

delete x; // <em class="em">전역 변수는 삭제되지 않는다.</em>
delete y; // <em class="em">프로퍼티는 삭제된다.</em>

console.log(window.x); // 10
console.log(window.y); // undefined
</code>
</pre>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">9. 최소한의 전역변수 사용</h4>


<pre class="mg0">
<code class="xmp">
var MYAPP = {};

MYAPP.student = {
  name: 'Lee',
  gender: 'male'
};

console.log(MYAPP.student.name);
</code>
</pre>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">10. 즉시실행함수를 이용한 전역변수 사용 억제</h4>


<pre class="mg0">
<code class="xmp">
(function () {
  var MYAPP = {};

  MYAPP.student = {
    name: 'Lee',
    gender: 'male'
  };

  console.log(MYAPP.student.name);
}());

console.log(MYAPP.student.name);
</code>
</pre>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-16">16 보다 안정적인 자바스크립트 개발 환경을 위한 Strict mode</h3>


<pre>
1. strict mode란?
2. strict mode의 적용
3. 전역에 strict mode를 적용하는 것은 피하자.
4. 함수 단위로 strict mode를 적용하는 것도 피하자.
5. strict mode가 발생시키는 에러
	5.1 암묵적 전역 변수
	5.2 변수, 함수, 매개변수의 삭제
	5.3 매개변수 이름의 중복
	5.3 with 문의 사용
	5.4 일반 함수의 this
6. 브라우저 호환성
</pre>


<div class="brclear clearfix"></div>
<hr class="line1t dott" />

<p>
	<b class="em0">ES5</b>부터 <b class="em0">strict mode</b>가 추가되었다.
</p>
<p>
	<b class="em0">ESLint</b>와 같은 린트 도구를 사용하여도 strict mode와 유사한 효과를 얻을 수 있다.<br />
	린트 도구는 정적 분석(static analysis) 기능을 통해 소스 코드를 실행하기 전에 소스 코드를 스캔하여
	문법적 오류만이 아니라 잠재적 오류까지 찾아내고 오류의 이유를 리포팅해주는 유용한 도구이다.<br />
</p>
<p>
	또한 strict mode가 제한하는 오류는 물론 코딩 컨벤션을 설정 파일 형태로 정의하고 강제할 수 있기 때문에 보다 강력한 효과를 얻을 수 있다.<br />
	필자는 <em class="em">개인적으로 strict mode보다 린트 도구의 사용을 선호</em>한다.
</p>
<p>
	<em class="em">strict mode는 즉시실행함수로 감싼 스크립트 단위로 적용하는 것이 바람직하다.</em>
</p>

<pre class="mg0">
<code class="xmp">
// 즉시실행 함수에 strict mode 적용
(function () {
  'use strict';

  // Do something...
}());
</code>
</pre>

<p>
	<em class="em">IE 9 이하는 지원하지 않는다.</em>
</p>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-17">17 함수 호출 방식에 의해 결정되는 this</h3>


<pre>
함수 호출 방식과 this 바인딩
1. 함수 호출
2. 메소드 호출
3. 생성자 함수 호출
	3.1 생성자 함수 동작 방식
	3.2 객체 리터럴 방식과 생성자 함수 방식의 차이
	3.3 생성자 함수에 new 연산자를 붙이지 않고 호출할 경우
4. apply/call/bind 호출
Reference
</pre>


<div class="brclear clearfix"></div>
<hr class="line1t dott" />


<p>
	자바스크립트의 함수는 호출될 때, 매개변수로 전달되는 인자값 이외에, arguments 객체와 this를 암묵적으로 전달 받는다.
</p>
<p>
	<em class="em">자바스크립트의 <code>this</code> keyword는 Java와 같은 익숙한 언어의 개념과 달라 개발자에게 혼란을 준다.</em>
</p>
<p>
	함수를 호출할 때 함수가 어떻게 호출되었는지에 따라 this에 바인딩할 객체가 동적으로 결정된다.
</p>
<p class="pd1em-rv bg-info">
	함수의 상위 스코프를 결정하는 방식인 렉시컬 스코프(Lexical scope)는 함수를 선언할 때 결정된다. this 바인딩과 혼동하지 않도록 주의하기 바란다.
</p>
<p>
	함수의 호출하는 방식은 아래와 같이 다양하다.
</p>

<pre class="mg0">
<code class="xmp">
var foo = function () {
  console.dir(this);
};

// 1. 함수 호출
foo(); // window
// window.foo();

// 2. 메소드 호출
var obj = { foo: foo };
obj.foo(); // obj

// 3. 생성자 함수 호출
var instance = new foo(); // instance

// 4. apply/call/bind 호출
var bar = { name: 'bar' };
foo.call(bar);   // bar
foo.apply(bar);  // bar
foo.bind(bar)(); // bar
</code>
</pre>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">1. 함수 호출</h4>


<p>
	기본적으로 this는 전역객체(Global object)에 바인딩된다.
	전역함수는 물론이고 심지어 내부함수의 경우도 this는 외부함수가 아닌 전역객체에 바인딩된다.
</p>

<p>
	<b class="em0"><em class="em">내부함수</em>는 일반 함수, 메소드, 콜백함수 어디에서 선언되었든 관게없이 <em class="em"><code>this</code>는 전역객체를 바인딩</em>한다.</b><br />
	더글라스 크락포드는
	“이것은 설계 단계의 결함으로 메소드가 내부함수를 사용하여 자신의 작업을 돕게 할 수 없다는 것을 의미한다” 라고 말한다.<br />
	내부함수의 this가 전역객체를 참조하는 것을 회피방법은 아래와 같다.<br />
</p>

<pre class="mg0">
<code class="xmp">
var value = 1;

var obj = {
  value: 100,
  foo: function() {
    <b class="em">var that = this;</b>  // Workaround : this === obj

    console.log("foo's this: ",  this);  // obj
    console.log("foo's this.value: ",  this.value); // 100
    function bar() {
      console.log("bar's this: ",  this); // window
      console.log("bar's this.value: ", this.value); // 1

      console.log("bar's that: ",  that); // obj
      console.log("bar's that.value: ", that.value); // 100
    }
    bar();
  }
};

obj.foo();
</code>
</pre>

<p>
	위 방법 이외에도 자바스크립트는 this를 명시적으로 바인딩할 수 있는 <code>apply, call, bind</code> 메소드를 제공한다.
</p>

<pre class="mg0">
<code class="xmp">
var value = 1;

var obj = {
  value: 100,
  foo: function() {
    console.log("foo's this: ",  this);  // obj
    console.log("foo's this.value: ",  this.value); // 100
    function bar(a, b) {
      console.log("bar's this: ",  this); // obj
      console.log("bar's this.value: ", this.value); // 100
      console.log("bar's arguments: ", arguments);
    }
    bar.apply(obj, [1, 2]); //
    bar.call(obj, 1, 2); //
    bar.bind(obj)(1, 2); // ES5
  }
};

obj.foo();
</code>
</pre>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">2. 메소드 호출</h4>

<p>
	함수가 객체의 프로퍼티 값이면 메소드로서 호출된다.
	이때 메소드 내부의 <code>this</code>는 해당 메소드를 소유한 객체, 즉 해당 메소드를 호출한 객체에 바인딩된다.
</p>

<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">3. 생성자 함수 호출</h4>

<p>
	자바스크립트의 생성자 함수는 말 그대로 객체를 생성하는 역할을 한다.
	하지만 자바와 같은 객체지향 언어의 생성자 함수와는 다르게 그 형식이 정해져 있는 것이 아니라
	<em class="em">기존 함수에 new 연산자를 붙여서 호출하면 해당 함수는 생성자 함수로 동작한다.</em>
</p>

<pre class="mg0">
<code class="xmp">
// 생성자 함수
function Person(name) {
  this.name = name;
}

var me = new Person('Lee');
console.log(me); // Person&nbsp;{name: "Lee"}

// new 연산자와 함께 생성자 함수를 호출하지 않으면 생성자 함수로 동작하지 않는다.
var you = Person('Kim');
console.log(you); // undefined
</code>
</pre>


<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">3.1 생성자 함수 동작 방식</h5>
<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">3.2 객체 리터럴 방식과 생성자 함수 방식의 차이</h5>

<p>
	객체 리터럴 방식과 생성자 함수 방식의 차이는 프로토타입 객체([[Prototype]])에 있다.<br />
	<b class="em0">객체 리터럴 방식</b>의 경우, 생성된 객체의 프로토타입 객체는 <em class="em">Object.prototype</em>이다.<br />
	<b class="em0">생성자 함수 방식</b>의 경우, 생성된 객체의 프로토타입 객체는 <em class="em">Person.prototype</em>이다.<br />
</p>


<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">3.3 생성자 함수에 new 연산자를 붙이지 않고 호출할 경우</h5>


<pre class="mg0">
<code class="xmp">
// <strong class="h1 em6">Scope-Safe Constructor Pattern</strong>
function A(arg) {
  // 생성자 함수가 new 연산자와 함께 호출되면 함수의 선두에서 빈객체를 생성하고 this에 바인딩한다.

  /*
  this가 호출된 함수(arguments.callee, 본 예제의 경우 A)의 인스턴스가 아니면 new 연산자를 사용하지 않은 것이므로
	이 경우 new와 함께 생성자 함수를 호출하여 인스턴스를 반환한다.
  arguments.callee는 호출된 함수의 이름을 나타낸다.
	이 예제의 경우 A로 표기하여도 문제없이 동작하지만 특정함수의 이름과 의존성을 없애기 위해서 arguments.callee를 사용하는 것이 좋다.
  */
  if (!(this instanceof arguments.callee)) {
    return new arguments.callee(arg);
  }

  // 프로퍼티 생성과 값의 할당
  this.value = arg ? arg : 0;
}

var a = new A(100);
var b = A(10);

console.log(a.value); // 100
console.log(b.value); // 10
</code>
</pre>

<p class="panel0 bg-info">
	<code>arguments.callee</code>는 함수 바디 내에서 현재 실행 중인 함수를 참조할 때 사용한다.
	다시 말해, 함수 바디 내에서 <em class="em">현재 실행 중인 함수의 이름을 반환</em>한다.
</p>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">4. apply/call/bind 호출</h4>


<pre class="mg0">
<code class="xmp">
func.apply(thisArg, [argsArray])

// thisArg: 함수 내부의 this에 바인딩할 객체
// argsArray: 함수에 전달할 argument의 배열
</code>
</pre>

<p>
	기억해야 할 것은 apply() 메소드를 호출하는 주체는 함수이며 apply() 메소드는 this를 특정 객체에 바인딩할 뿐 본질적인 기능은 함수 호출이라는 것이다.
</p>

<pre class="mg0">
   <code class="xmp">
   var Person = function (name) {
  this.name = name;
};

var foo = {};

// apply 메소드는 생성자함수 Person을 호출한다. 이때 this에 객체 foo를 바인딩한다.
Person.apply(foo, ['name']);

console.log(foo); // { name: 'name' }
</code>
</pre>

<p>
	call() 메소드의 경우, apply()와 기능은 같지만 apply()의 두번째 인자에서 배열 형태로 넘긴 것을 각각 하나의 인자로 넘긴다.
</p>

<pre class="mg0">
<code class="xmp">
Person.apply(foo, [1, 2, 3]);

Person.call(foo, 1, 2, 3);
</code>
</pre>

<p>
	<em class="em">apply()와 call() 메소드는 콜백함수 내부의 this를 콜백함수를 호출하는 함수 내부의 this와 일치시켜주기 위해서 사용되기도 한다.</em>
</p>

<pre class="mg0">
<code class="xmp">
function Person(name) {
  this.name = name;
}

Person.prototype.doSomething = function (callback) {
  if (typeof callback == 'function') {
		// callback();
		// 위 코드로 하면.. 콜백함수를 호출하는 외부 함수 내부의 this와 콜백함수 내부의 this가 상이하기 때문에 문맥상 문제가 발생한다.
		// 따라서 아래 방법처럼 콜백함수 내부의 this를 콜백함수를 호출하는 함수 내부의 this와 일치시켜 주어야 하는 번거로움이 발생한다. .
    callback.call(this); // callback.bind(this)(); // ES5에 추가된 this가 바인딩된 새로운 함수를 호출
  }
};

function foo() {
  console.log('#', this.name);
}

var p = new Person('Lee');
p.doSomething(foo);  // 'Lee'
</code>
</pre>




<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-18">18 실행 컨텍스트와 자바스크립트의 동작 원리</h3>


<pre>
1. 실행 컨텍스트
2. 실행 컨텍스트의 3가지 객체
	2.1 Variable Object (VO / 변수객체)
	2.2 Scope Chain (SC)
	2.3 this value
3. 실행 컨텍스트의 생성 과정
	3.1 전역 코드에의 진입
		3.1.1 스코프 체인의 생성과 초기화
		3.1.2 Variable Instantiation(변수 객체화) 실행
			3.1.2.1 함수 foo의 선언 처리
			3.1.2.2 변수 x의 선언 처리
		3.1.3 this value 결정
	3.2. 전역 코드의 실행
		3.2.1 변수 값의 할당
		3.2.2 함수 foo의 실행
			3.2.2.1 스코프 체인의 생성과 초기화
			3.2.2.2 Variable Instantiation 실행
			3.2.2.3 this value 결정
	3.3 foo 함수 코드의 실행
		3.3.1 변수 값의 할당
		3.3.2 함수 bar의 실행
Reference
</pre>


<div class="brclear clearfix"></div>
<hr class="line1t dott" />


<p class="panel0 bg-info">
	이 포스팅의 내용은 ES3를 기반으로 하고 있다.
</p>

<p>
	실행 컨텍스트(Execution Context)는 scope, hoisting, this, function, closure 등의 동작원리를 담고 있는 자바스크립트의 핵심원리이다.<br />
	실행 컨텍스트를 바로 이해하지 못하면 코드 독해가 어려워지며 디버깅도 매우 곤란해 질 것이다.<br />
</p>



<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-19">19 클로저</h3>


<pre>
1. 클로저(closure)의 개념
2. 클로저의 활용
	2.1 상태 유지
	2.2 전역 변수의 사용 억제
	2.3 정보의 은닉
	2.4 자주 발생하는 실수
Reference
</pre>

<div class="brclear clearfix"></div>
<hr class="line1t dott" />


<pre class="mg0">
<code class="xmp">
function outerFunc() {
  var x = 10;
  var innerFunc = function () { console.log(x); };
  innerFunc();
}

outerFunc(); // 10
</code>
</pre>


<pre class="mg0">
<code class="xmp">
function outerFunc() {
  var x = 10;
  var innerFunc = function () { console.log(x); };
  <em class="em">return</em> innerFunc;
}

/**
 *  함수 outerFunc를 호출하면 내부 함수 innerFunc가 반환된다.
 *  그리고 함수 outerFunc의 실행 컨텍스트는 소멸한다.
 */
var inner = outerFunc();
inner(); // 10
</code>
</pre>


<p>
	함수 outerFunc는 내부함수 innerFunc를 반환하고 생을 마감했다.
	즉, 함수 outerFunc는 실행된 이후 콜스택(실행 컨텍스트 스택)에서 제거되었으므로
	함수 outerFunc의 변수 x 또한 더이상 유효하지 않게 되어 변수 x에 접근할 수 있는 방법은 달리 없어 보인다.
	그러나 위 코드의 실행 결과는 변수 x의 값인 10이다.
	이미 life-cycle이 종료되어 실행 컨텍스트 스택에서 제거된 함수 outerFunc의 지역변수 x가 다시 부활이라도 한 듯이 동작하고 있다.
	뭔가 특별한 일이 일어나고 있는 것 같다.
</p>
<p>
	이처럼 자신을 포함하고 있는 외부함수보다 내부함수가 더 오래 유지되는 경우,
	외부 함수 밖에서 내부함수가 호출되더라도 외부함수의 지역 변수에 접근할 수 있는데 이러한 함수를 <b class="em0">클로저(Closure)</b>라고 부른다.
</p>

<p>
	<b class="em0">클로저는 반환된 내부함수가 자신이 선언됐을 때의 환경(Lexical environment)인 스코프를 기억하여
	자신이 선언됐을 때의 환경(스코프) 밖에서 호출되어도 그 환경(스코프)에 접근할 수 있는 함수</b>를 말한다.
	이를 조금 더 간단히 말하면 <b class="em0">클로저는 자신이 생성될 때의 환경(Lexical environment)을 기억하는 함수</b>다라고 말할 수 있겠다.
</p>


<p>
	<strong class="h1 em6 big">클로저를 사용한 Counting</strong>
</p>

<xmp class="xmp">
<!DOCTYPE html>
<html>
  <body>
  <p>클로저를 사용한 Counting</p>
  <button id="inclease">+</button>
  <p id="count">0</p>
  <script>
    var incleaseBtn = document.getElementById('inclease');
    var count = document.getElementById('count');

    var increase = (function () {
      // 카운트 상태를 유지하기 위한 자유 변수
      var counter = 0;
      // 클로저를 반환
      return function () {
        return ++counter;
      };
    }());

    incleaseBtn.onclick = function () {
      count.innerHTML = increase();
    };
  </script>
</body>
</html>
</xmp>


<p>
	아래는 함수형 프로그래밍에서 클로저를 활용하는 간단한 예제이다.
</p>


<pre class="mg0">
<code class="xmp">
// 함수를 인자로 전달받고 함수를 반환하는 고차 함수
// 이 함수가 반환하는 함수는 클로저로서 카운트 상태를 유지하기 위한 자유 변수 counter을 기억한다.
function makeCounter(predicate) {
  // 카운트 상태를 유지하기 위한 자유 변수
  var counter = 0;
  // 클로저를 반환
  return function () {
    counter = predicate(counter);
    return counter;
  };
}

// 보조 함수
function increase(n) {
  return ++n;
}

// 보조 함수
function decrease(n) {
  return --n;
}

// 함수로 함수를 생성한다.
// makeCounter 함수는 보조 함수를 인자로 전달받아 함수를 반환한다
const increaser = makeCounter(increase);
console.log(increaser()); // 1
console.log(increaser()); // 2

// increaser 함수와는 별개의 독립된 렉시컬 환경을 갖기 때문에 카운터 상태가 연동하지 않는다.
const decreaser = makeCounter(decrease);
console.log(decreaser()); // -1
console.log(decreaser()); // -2
</code>
</pre>


<p>
	이번에는 생성자 함수 Counter를 생성하고 이를 통해 counter 객체를 만들어보자.
</p>


<pre class="mg0">
<code class="xmp">
function Counter() {
  // 카운트를 유지하기 위한 자유 변수
  var counter = 0;

  // 클로저
  this.increase = function () {
    return ++counter;
  };

  // 클로저
  this.decrease = function () {
    return --counter;
  };
}

const counter = new Counter();

console.log(counter.increase()); // 1
console.log(counter.decrease()); // 0
</code>
</pre>


<p>
	생성자 함수 Counter는 increase, decrease 메소드를 갖는 인스턴스를 생성한다.
	이 메소드들은 모두 자신이 생성됐을 때의 렉시컬 환경인 생성자 함수 Counter의 스코프에 속한 변수 counter를 기억하는 클로저이며 	렉시컬 환경을 공유한다.
	생성자 함수가 함수가 생성한 객체의 메소드는 객체의 프로퍼티에만 접근할 수 있는 것이 아니며
	자신이 기억하는 렉시컬 환경의 변수에도 접근할 수 있다.
</p>
<p>
	이때 생성자 함수 Counter의 변수 counter는 this에 바인딩된 프로퍼티가 아니라 변수다.
	counter가 this에 바인딩된 프로퍼티라면 생성자 함수 Counter가 생성한 인스턴스를 통해 외부에서 접근이 가능한 <b class="em">public</b> 프로퍼티가 되지만
	생성자 함수 Counter 내에서 선언된 변수 counter는 생성자 함수 Counter 외부에서 접근할 수 없다.
	하지만 생성자 함수 Counter가 생성한 인스턴스의 메소드인 increase, decrease는 클로저이기 때문에 자신이 생성됐을 때의 렉시컬 환경인 생성자 함수 Counter의 변수 counter에 접근할 수 있다.
	이러한 클로저의 특징을 사용해 클래스 기반 언어의 <b class="em">private</b> 키워드를 흉내낼 수 있다.
</p>


<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">자주 발생하는 실수</h5>


<p>
	아래의 예제는 클로저를 사용할 때 자주 발생할 수 있는 실수에 관련한 예제다.
</p>

<pre class="mg0">
<code class="xmp">
var arr = [];

for (var i = 0; i < 5; i++) {
  arr[i] = function () {
    return i;
  };
}

for (var j = 0; j < arr.length; j++) {
  console.log(arr[j]());
}
</code>
</pre>

<p>
	배열 arr에 5개의 함수가 할당되고 각각의 함수는 순차적으로 0, 1, 2, 3, 4를 반환할 것으로 기대하겠지만 결과는 그렇지않다. for 문에서 사용한 변수 i는 전역 변수이기 때문이다. 이러한 문제를 클로저를 사용해 바르게 동작하는 코드로 만들어보자.
</p>

<pre class="mg0">
<code class="xmp">
var arr = [];

for (var i = 0; i < 5; i++){
  arr[i] = (function (id) { // ②
    return function () {
      return id; // ③
    };
  }(i)); // ①
}

for (var j = 0; j < arr.length; j++) {
  console.log(arr[j]());
}
</code>
</pre>

<p>
	① 배열 arr에는 즉시실행함수에 의해 함수가 반환된다.<br />
	② 이때 즉시실행함수는 i를 인자로 전달받고 매개변수 id에 할당한 후 내부 함수를 반환하고 life-cycle이 종료된다. 매개변수 id는 자유변수가 된다.<br />
	③ 배열 arr에 할당된 함수는 id를 반환한다. 이때 id는 상위 스코프의 자유변수이므로 그 값이 유지된다.<br />
</p>

<p>
	위 예제는 자바스크립트의 함수 레벨 스코프 특성으로 인해 for 루프의 초기문에서 사용된 변수의 스코프가 전역이 되기 때문에 발생하는 현상이다.<br />
	<b class="em">ES6의 let 키워드</b>를 사용하면 이와 같은 문제는 말끔히 해결된다.
</p>

<pre class="mg0">
<code class="xmp">
const arr = [];

for (let i = 0; i < 5; i++) {
  arr[i] = function () {
    return i;
  };
}

for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]());
}
</code>
</pre>

<p>
	또는 함수형 프로그래밍 기법인 <b class="em">고차 함수를 사용하는 방법</b>이 있다.
	이 방법은 변수와 반복문의 사용을 억제할 수 있기 때문에 에플리케이션의 오류를 줄이고 가독성을 좋게 만든다.
</p>

<pre class="mg0">
<code class="xmp">
const arr = new Array(5).fill();

arr.forEach((v, i, array) => array[i] = () => i);

arr.forEach(f => console.log(f()));
</code>
</pre>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-20">20 자바스크립트 객체지향 프로그래밍</h3>


<pre>
1. 객체지향 프로그래밍 (Object-Oriented Programming) 개요
2. 클래스 기반 vs. 프로토타입 기반
	2.1 클래스 기반 언어
	2.2 프로토타입 기반 언어
3. 생성자 함수와 인스턴스의 생성
4. 프로토타입 체인과 메소드의 정의
5. 상속 (Inheritance)
	5.1 의사 클래스 패턴 상속 (Pseudo-classical Inheritance)
	5.2 프로토타입 패턴 상속 (Prototypal Inheritance)
6. 캡슐화(Encapsulation)와 모듈 패턴(Module Pattern)
Reference
</pre>

<div class="brclear clearfix"></div>
<hr class="line1t dott" />


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">4. 프로토타입 체인과 메소드의 정의</h4>

<p>
	아래는 더글라스 크락포드가 제안한 프로토타입 객체에 메소드를 추가하는 방식이다.
</p>


<pre class="mg0">
<code class="xmp">
/**
 * 모든 생성자 함수의 프로토타입은 Function.prototype이다. 따라서 모든 생성자 함수는 Function.prototype.method()에 접근할 수 있다.
 * @method Function.prototype.method
 * @param ({string}) (name) - (메소드 이름)
 * @param ({function}) (func) - (추가할 메소드 본체)
 */
Function.prototype.method = function (name, func) {
  // 생성자함수의 프로토타입에 동일한 이름의 메소드가 없으면 생성자함수의 프로토타입에 메소드를 추가
  // this: 생성자함수
  if (!this.prototype[name]) {
    this.prototype[name] = func;
  }
};

/**
 * 생성자 함수
 */
function Person(name) {
  this.name = name;
}

/**
 * 생성자함수 Person의 프로토타입에 메소드 setName을 추가
 */
Person.method('setName', function (name) {
  this.name = name;
});

/**
 * 생성자함수 Person의 프로토타입에 메소드 getName을 추가
 */
Person.method('getName', function () {
  return this.name;
});

var me  = new Person('Lee');
var you = new Person('Kim');
var him = new Person('choi');

console.log(Person.prototype);
// Person { setName: [Function], getName: [Function] }

console.log(me);  // Person { name: 'Lee' }
console.log(you); // Person { name: 'Kim' }
console.log(him); // Person { name: 'choi' }
</code>
</pre>

<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">5. 상속 (Inheritance)</h4>

<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">5.1 의사 클래스 패턴 상속 (Pseudo-classical Inheritance)</h5>
<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">5.2 프로토타입 패턴 상속 (Prototypal Inheritance)</h5>

<pre class="mg0">
<code class="xmp">
// 부모 생성자 함수
var Parent = (function () {
  // Constructor
  function Parent(name) {
    this.name = name;
  }

  // method
  Parent.prototype.sayHi = function () {
    console.log('Hi! ' + this.name);
  };

  // return constructor
  return Parent;
}());

// create 함수의 인수는 프로토타입이다.
var child = <em class="em">Object.create</em>(Parent.prototype);
child.name = 'child';

child.sayHi();  // Hi! child

console.log(child instanceof Parent); // true
</code>
</pre>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">6. 캡슐화(Encapsulation)와 모듈 패턴(Module Pattern)</h4>

<p>
	<b class="em0">캡슐화</b>는 관련있는 멤버 변수와 메소드를 클래스와 같은 하나의 틀 안에 담고 외부에 공개될 필요가 없는 정보는 숨기는 것을 말하며
	다른 말로 <b class="em0">정보 은닉(information hiding)</b>이라고 한다.
</p>

<pre class="mg0">
<code class="xmp">
var Person = function(arg) {
  var name = arg ? arg : ''; // ①

  this.getName = function() {
    return name;
  };

  this.setName = function(arg) {
    name = arg;
  };
}

var me = new Person('Lee');

var name = me.getName();

console.log(name);

me.setName('Kim');
name = me.getName();

console.log(name);
</code>
</pre>

<p>
	<strong class="h1 em6 big">모듈 패턴</strong>
</p>

<pre class="mg0">
<code class="xmp">
var person = function(arg) {
  var name = arg ? arg : '';

  return {
    getName: function() {
      return name;
    },
    setName: function(arg) {
      name = arg;
    }
  }
}

var me = person('Lee'); /* or var me = new person('Lee'); */

var name = me.getName();

console.log(name);

me.setName('Kim');
name = me.getName();

console.log(name);
</code>
</pre>


<p>
	person 함수는 객체를 반환한다.<br />
	이 객체 내의 메소드 getName, setName은 클로저로서 private 변수 name에 접근할 수 있다.<br />
	이러한 방식을 모듈 패턴이라 하며 캡슐화와 정보 은닉를 제공한다.<br />
	많은 라이브러리에서 사용되는 유용한 패턴이다.<br />
</p>
<p>
	이 모듈 패턴은 다음과 같은 주의할 점이 있다.
</p>
<p>
	<em class="em">private 멤버가 객체나 배열일 경우, 반환된 해당 멤버의 변경이 가능하다.</em>
</p>

<pre class="mg0">
<code class="xmp">
var person = function (personInfo) {
  var o = personInfo;

  return {
    getPersonInfo: function() {
      return o;
    }
  };
};

var me = person({ name: 'Lee', gender: 'male' });

var myInfo = me.getPersonInfo();
console.log('myInfo: ', myInfo);
// myInfo:  { name: 'Lee', gender: 'male' }

myInfo.name = 'Kim';

myInfo = me.getPersonInfo();
console.log('myInfo: ', myInfo);
// myInfo:  { name: 'Kim', gender: 'male' }
</code>
</pre>

<p>
	객체를 반환하는 경우 반환값은 얕은 복사(shallow copy)로 private 멤버의 참조값을 반환하게 된다.<br />
	따라서 외부에서도 private 멤버의 값을 변경할 수 있다.<br />
	이를 회피하기 위해서는 객체를 그대로 반환하지 않고 반환해야 할 객체의 정보를 새로운 객체에 담아 반환해야 한다.<br />
	반드시 객체 전체가 그대로 반환되어야 하는 경우에는 깊은 복사(deep copy)로 복사본을 만들어 반환한다.<br />
</p>
 
<p>
	<em class="em">person 함수가 반환한 객체는 person 함수 객체의 프로토타입에 접근할 수 없다.</em><br />
	이는 상속을 구현할 수 없음을 의미한다.<br />
</p>

<pre class="mg0">
<code class="xmp">
var person = function(arg) {
  var name = arg ? arg : '';

  return {
    getName: function() {
      return name;
    },
    setName: function(arg) {
      name = arg;
    }
  }
}

var me = person('Lee');

console.log(person.prototype === me.__proto__); // false
console.log(me.__proto__ === Object.prototype); // true: 객체 리터럴 방식으로 생성된 객체와 동일하다
</code>
</pre>


<p>
	앞에서 살펴본 모듈 패턴은 생성자 함수가 아니며 단순히 메소드를 담은 객체를 반환한다.<br />
	반환된 객체는 객체 리터럴 방식으로 생성된 객체로 함수 person의 프로토타입에 접근할 수 없다.<br />
</p>

<p>
	반환된 객체가 함수 person의 프로토타입에 접근할 수 없다는 것은<br />
	person을 부모 객체로 상속할 수 없다는 것을 의미한다.<br />
</p>
<p>
	함수 person을 부모 객체로 상속할 수 없다는 것은<br />
	함수 person이 반환하는 객체에 모든 메소드를 포함시켜야한다는 것을 의미한다.<br />
</p>
<p>
	이 문제를 해결하기 위해서는 <em class="em">객체를 반환하는 것이 아닌 함수를 반환해야 한다.</em><br />
</p>


<pre class="mg0">
<code class="xmp">
var Person = function() {
  var name;

  var F = function(arg) { name = arg ? arg : ''; };

  F.prototype = {
    getName: function() {
      return name;
    },
    setName: function(arg) {
      name = arg;
    }
  };

  return F;
}();

var me = new Person('Lee');

console.log(Person.prototype === me.__proto__); // true

console.log(me.getName()); // Lee
me.setName('Kim')
console.log(me.getName()); // Kim
</code>
</pre>


<p>
	<em class="em">캡슐화를 구현하는 패턴은 다양하며 각각의 패턴에는 장단점이 있다.</em>
	다양한 패턴의 장단점을 분석하고 파악하는 것이 보다 효율적인 코드를 작성하는데 중요하다.
</p>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-21">21 빌트인 객체</h3>


<pre>
1. 네이티브 객체
	1.1 Object
	1.2 Function
	1.3 Boolean
	1.4 Number
	1.5 Math
	1.6 Date
	1.7 String
	1.8 RegExp
	1.9 Array
	1.10 Error
	1.11 Symbol
	1.12 원시 타입과 래퍼객체(Wrapper Object)
2. 호스트 객체
	2.1 전역 객체(Global Object)
	2.2 BOM (Browser Object Model)
	2.2 DOM (Document Object Model)
Reference
</pre>


<div class="brclear clearfix"></div>
<hr class="line1t dott" />


<p>
	자바스크립트의 객체는 아래와 같이 크게 3개의 객체로 분류할 수 있다.
</p>


<figure class="box1 mg0 pd10px tac">
	<img src="https://poiemaweb.com/img/objects.png" alt="자바스크립트 객체의 분류" />
	<figcaption>자바스크립트 객체의 분류</figcaption>
</figure>


<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">1.10 Error</h5>

<p>
	Error 생성자는 error 객체를 생성한다. error 객체의 인스턴스는 런타임 에러가 발생하였을 때 throw된다.
</p>

<pre class="mg0">
<code class="xmp">
try {
  // foo();
  throw new Error('Whoops!');
} catch (e) {
  console.log(e.name + ': ' + e.message);
}
</code>
</pre>

<p>
	Error 이외에 Error에 관련한 객체는 아래와 같다.
</p>

<ul class="bu">
<li>EvalError</li>
<li>InternalError</li>
<li>RangeError</li>
<li>ReferenceError</li>
<li>SyntaxError</li>
<li>TypeError</li>
<li>URIError</li>
</ul>

<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">1.11 Symbol</h5>

<p>
	Symbol은 ECMAScript 6(Javascript 2015) 에서 추가된 유일하고 변경 불가능한(immutable) 원시 타입으로 Symbol 객체는 원시 타입 Symbol 값을 생성한다.
</p>


<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">1.12 원시 타입과 래퍼객체(Wrapper Object)</h5>

<p>
	앞서 살펴본 바와 같이 각 네이티브 객체는 각자의 프로퍼티와 메소드를 가진다.
	정적(static) 프로퍼티, 메소드는 해당 인스턴스를 생성하지 않아도 사용할 수 있고
	prototype에 속해있는 메소드는 해당 prototype을 상속받은 인스턴스가 있어야만 사용할 수 있다.
</p>
<p>
	그런데 원시 타입 값에 대해 표준 빌트인 객체의 메소드를 호출하면 정상적으로 작동한다.
</p>

<pre class="mg0">
<code class="xmp">
var str = 'Hello world!';
var res = str.toUpperCase();
console.log(res); // 'HELLO WORLD!'

var num = 1.5;
console.log(num.toFixed()); // 2
</code>
</pre>

<p>
	이는 원시 타입 값에 대해 표준 빌트인 객체의 메소드를 호출할 때,
	원시 타입 값은 연관된 객체(Wrapper 객체)로 일시 변환 되기 때문에 가능한 것이다.
	그리고 메소드 호출이 종료되면 객체로 변환된 원시 타입 값은 다시 원시 타입 값으로 복귀한다.
</p>
<p>
	자세한 내용은 Prototype: 6.원시 타입(Primitive data type)의 확장을 참조 바란다.
</p>
<p>
	<em class="em">Wrapper 객체는 String, Number, Boolean이 있다.</em>
</p>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-22">22 전역 객체</h3>


<pre>
1. 전역 프로퍼티(Global property)
	1.1. Infinity
	1.2. NaN
	1.3. undefined
2. 전역 함수(Global function)
	2.1. eval()
	2.2. isFinite()
	2.3. isNaN()
	2.4. parseFloat()
	2.5. parseInt()
	2.6. encodeURI() / decodeURI()
	2.7. encodeURIComponent() / decodeURIComponent()
</pre>


<div class="brclear clearfix"></div>
<hr class="line1t dott" />


<p>
	전역 객체(Global Object)는 모든 객체의 유일한 최상위 객체를 의미하며
	일반적으로
	<b class="em0">Browser-side</b> 에서는 <em class="em">window</em>,
	<b class="em0">Server-side(Node.js)</b> 에서는 <em class="em">global</em> 객체를 의미한다.
</p>

<pre class="mg0">
<code class="xmp">
// in browser console
this === window // true

// in Terminal
node
this === global // true
</code>
</pre>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">1. 전역 프로퍼티(Global property)</h4>

1.1. <code>Infinity</code> :: 양/음의 무한대를 나타내는 숫자값 Infinity를 갖는다.<br />
1.2. <code>NaN</code> :: 숫자가 아님(Not-a-Number)을 나타내는 숫자값 NaN을 갖는다. <br />
1.3. <code>undefined</code> :: 원시 타입 undefined를 값으로 갖는다.<br />


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">2. 전역 함수(Global function)</h4>

<div class="ofh">
<span class="fl mgr025em">2.1. <code>eval()</code> :: </span>
<div class="ofh">
	매개변수에 전달된 문자열 구문 또는 표현식을 평가 또는 실행한다.<br />
	사용자로 부터 입력받은 콘텐츠(untrusted data)를 eval()로 실행하는 것은 보안에 매우 취약하다.<br />
	eval()의 사용은 가급적으로 금지되어야 한다.<br />
</div>
</div>

2.2. <code>isFinite()</code> :: 매개변수에 전달된 값이 정상적인 유한수인지 검사하여 그 결과를 Boolean으로 반환한다. 매개변수에 전달된 값이 숫자가 아닌 경우, 숫자로 변환한 후 검사를 수행한다.<br />
2.3. <code>isNaN()</code> :: 매개변수에 전달된 값이 NaN인지 검사하여 그 결과를 Boolean으로 반환한다. 매개변수에 전달된 값이 숫자가 아닌 경우, 숫자로 변환한 후 검사를 수행한다.<br />
2.4. <code>parseFloat()</code> :: 매개변수에 전달된 문자열을 부동소수점 숫자(floating point number)로 변환하여 반환한다.<br />
2.5. <code>parseInt()</code> :: 매개변수에 전달된 문자열을 정수형 숫자(Integer)로 해석(parsing)하여 반환한다. 반환값은 언제나 10진수이다.<br />
2.6. <code>encodeURI() / decodeURI()</code> :: 매개변수로 전달된 URI(Uniform Resource Identifier)를 인코딩한다.<br />
2.7. <code>encodeURIComponent() / decodeURIComponent()</code> ::<br />

<figure class="box1 mg0 mgt15em mgb15em pd20px tac">
	<img src="https://poiemaweb.com/img/uri.png" width="auto" height="auto" alt="URI(Uniform Resource Identifier)" />
	<figcaption>URI(Uniform Resource Identifier)</figcaption>
</figure>


<p>
	여기서 인코딩이란 URI의 문자들을 이스케이프 처리하는 것을 의미한다.
</p>

<div class="pd20px-rv bgcf7">
	<strong class="h1 em6">이스케이프 처리</strong>
	<p>
		네트워크를 통해 정보를 공유할 때 어떤 시스템에서도 읽을 수 있는 ASCII Character-set로 변환하는 것이다. UTF-8 특수문자의 경우, 1문자당 1~3byte, UTF-8 한글 표현의 경우, 1문자당 3btye이다. 예를 들어 특수문자 공백(space)은 %20, 한글 ‘가’는 %EC%9E%90으로 인코딩된다.
	</p>
	<strong class="h1 em6">이스케이프 처리 이유</strong>
	<p>
		URI 문법 형식 표준 RFC3986에 따르면 URL은 ASCII Character-set으로만 구성되어야 하며 한글을 포함한 대부분의 외국어나 ASCII에 정의되지 않은 특수문자의 경우 URL에 포함될 수 없다. 따라서 URL 내에서 의미를 갖고 있는 문자(%, ?, #)나 URL에 올 수 없는 문자(한글, 공백 등) 또는 시스템에 의해 해석될 수 있는 문자(<, >)를 이스케이프 처리하여 야기될 수 있는 문제를 예방하기 위함이다.
	</p>
</div>

<p>
	단 아래의 문자는 이스케이프 처리에서 제외된다.
</p>
<ul class="bu">
<li>알파벳, 0~9의 숫자, - _ . ! ~ * ‘ ( )</li>
</ul>
<p>
	decodeURI()은 매개변수로 전달된 URI을 디코딩한다.
</p>

<p>
	<b class="em0">encodeURIComponent()</b>는 인수를 쿼리스트링의 일부라고 간주한다. 따라서 <em class="em">=, ?, &를 인코딩한다.</em><br />
	반면 <b class="em0">encodeURI()</b>는 인수를 URI 전체라고 간주하며 파라미터 구분자인 <em class="em">=, ?, &를 인코딩하지 않는다.</em><br />
</p>

<pre class="mg0">
<code class="xmp">
var uriComp = '이웅모&job=programmer&teacher';

// encodeURI / decodeURI
var enc = encodeURI(uriComp);
var dec = decodeURI(enc);
console.log(enc);
// %EC%9D%B4%EC%9B%85%EB%AA%A8&job=programmer&teacher
console.log(dec);
// 이웅모&job=programmer&teacher

// encodeURIComponent / decodeURIComponent
enc = encodeURIComponent(uriComp);
dec = decodeURIComponent(enc);
console.log(enc);
// %EC%9D%B4%EC%9B%85%EB%AA%A8%26job%3Dprogrammer%26teacher
console.log(dec);
// 이웅모&job=programmer&teacher
</code>
</pre>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-23">23 Number 레퍼 객체</h3>


<pre>
1. Number Constructor
2. Number Property
	2.1 Number.EPSILON ES6
	2.2 Number.MAX_VALUE ES1
	2.3 Number.MIN_VALUE ES1
	2.4 Number.POSITIVE_INFINITY ES1
	2.5 Number.NEGATIVE_INFINITY ES1
	2.6 Number.NaN ES1
3. Number Method
	3.1 Number.isFinite(testValue: number): boolean ES6
	3.2 Number.isInteger(testValue: number): boolean ES6
	3.3 Number.isNaN(testValue: number): boolean ES6
	3.4 Number.isSafeInteger(testValue: number): boolean ES6
	3.5 Number.prototype.toExponential(fractionDigits?: number): string ES3
	3.6 Number.prototype.toFixed(fractionDigits?: number): string ES3
	3.7 Number.prototype.toPrecision(precision?: number): string ES3
	3.8 Number.prototype.toString(radix?: number): string ES1
	3.9 Number.prototype.valueOf(): number ES1
Reference
</pre>

<div class="brclear clearfix"></div>
<hr class="line1t dott" />

<p>
	Number 객체는 원시 타입 number를 다룰 때 유용한 프로퍼티와 메소드를 제공하는 래퍼(wrapper) 객체이다.<br />
	변수 또는 객체의 프로퍼티가 숫자를 값으로 가지고 있다면 Number 객체의 별도 생성없이 Number 객체의 프로퍼티와 메소드를 사용할 수 있다.<br />
</p>
<p>
	<em class="em">원시 타입이 wrapper 객체의 메소드를 사용할 수 있는 이유</em>는<br />
	원시 타입으로 프로퍼티나 메소드를 호출할 때<br />
	<em class="em">원시 타입과 연관된 wrapper 객체로 일시적으로 변환되어 프로토타입 객체를 공유하게 되기 때문이다.</em><br />
</p>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">1. Number Constructor</h4>

<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">2. Number Property</h4>

2.1 <code>Number.EPSILON</code> :: ES6 :: JavaScript에서 표현할 수 있는 가장 작은 수. 약 2.2204460492503130808472633361816E-16 또는 2<sup>-52</sup>이다.<br />
2.2 <code>Number.MAX_VALUE</code> :: ES1 :: 자바스크립트에서 사용 가능한 가장 큰 숫자(1.7976931348623157e+308)를 반환한다. MAX_VALUE보다 큰 숫자는 Infinity이다.<br />
2.3 <code>Number.MIN_VALUE</code> :: ES1 :: 자바스크립트에서 사용 가능한 가장 작은 숫자(5e-324)를 반환한다. <br />
2.4 <code>Number.POSITIVE_INFINITY</code> :: ES1 :: 양의 무한대 Infinity를 반환한다.<br />
2.5 <code>Number.NEGATIVE_INFINITY</code> :: ES1 :: 음의 무한대 -Infinity를 반환한다.<br />
2.6 <code>Number.NaN</code> :: ES1 :: 숫자가 아님(Not-a-Number)을 나타내는 숫자값이다. Number.NaN 프로퍼티는 window.NaN 프로퍼티와 같다.<br />

	<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">3. Number Method</h4>

3.1 <code>Number.isFinite</code>(testValue: number): boolean :: ES6 :: 매개변수에 전달된 값이 정상적인 유한수인지를 검사하여 그 결과를 Boolean으로 반환한다.<br />
3.2 <code>Number.isInteger</code>(testValue: number): boolean :: ES6 :: 매개변수에 전달된 값이 정수(Integer)인지 검사하여 그 결과를 Boolean으로 반환한다.<br />
3.3 <code>Number.isNaN</code>(testValue: number): boolean :: ES6 :: 매개변수에 전달된 값이 NaN인지를 검사하여 그 결과를 Boolean으로 반환한다.<br />
<div class="ofh">
	<span class="fl mgr025em">3.4 <code>Number.isSafeInteger</code>(testValue: number): boolean :: ES6 ::</span>
	<div class="ofh">
		매개변수에 전달된 값이 안전한(safe) 정수값인지 검사하여 그 결과를 Boolean으로 반환한다.<br />
		안전한 정수값은 -(253 - 1)와 253 - 1 사이의 정수값이다.<br />
	</div>
</div>
3.5 <code>Number.prototype.toExponential</code>(fractionDigits?: number): string :: ES3 :: 대상을 지수 표기법으로 변환하여 문자열로 반환한다.<br />
3.6 <code>Number.prototype.toFixed</code>(fractionDigits?: number): string :: ES3 :: 매개변수로 지정된 소숫점자리를 반올림하여 문자열로 반환한다.<br />
<div class="ofh">
	<span class="fl mgr025em">3.7 <code>Number.prototype.toPrecision</code>(precision?: number): string :: ES3 ::</span>
	<div class="ofh">
		매개변수로 지정된 전체 자릿수까지 유효하도록 나머지 자릿수를 반올림하여 문자열로 반환한다.<br />
		지정된 전체 자릿수로 표현할 수 없는 경우 지수 표기법으로 결과를 반환한다.<br />
	</div>
</div>
3.8 <code>Number.prototype.toString</code>(radix?: number): string :: ES1 :: 숫자를 문자열로 변환하여 반환한다.<br />
3.9 <code>Number.prototype.valueOf()</code>: number :: ES1 :: Number 객체의 원시 타입 값(primitive value)을 반환한다.<br />


<!-- panel1 -->
<div class="panel1">
<p class="mg0">
	<strong class="h1 em6">정수 리터럴과 함께 메소드를 사용할 경우</strong>
</p>
<pre class="mg0">
<code class="xmp">
77.toString(); // SyntaxError: Invalid or unexpected token
1.23.toString (); // '1.23'
(77).toString(); // '77'
77 .toString(); // '77'
</code>
</pre>
</div>
<!-- /panel1 -->




<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-24">24 수학 상수와 함수를 위한 Math 객체</h3>


<pre>
1. Math Property
	1.1 Math.PI
2. Math Method
	2.1 Math.abs(x: number): number ES1
	2.2 Math.round(x: number): number ES1
	2.3 Math.ceil(x: number): number ES1
	2.4 Math.floor(x: number): number ES1
	2.5 Math.sqrt(x: number): number ES1
	2.6 Math.random(): number ES1
	2.7 Math.pow(x: number, y: number): number ES1
	2.8 Math.max(…values: number[]): number ES1
	2.9 Math.min(…values: number[]): number ES1
Reference
</pre>


<div class="brclear clearfix"></div>
<hr class="line1t dott" />


<p>
	Math 객체는 수학 상수와 함수를 위한 프로퍼티와 메소드를 제공하는 빌트인 객체이다.
	<em class="em">Math 객체는 생성자 함수가 아니다.</em>
	따라서 Math 객체는 정적(static) 프로퍼티와 메소드만을 제공한다.
</p>
<p>
	사용 빈도가 높은 프로퍼티와 메소드만을 설명한다.
</p>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">1. Math Property</h4>

1.1 <code>Math.PI</code> :: PI 값(π ≈ 3.141592653589793)을 반환한다.<br />

<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">2. Math Method</h4>

2.1 <code>Math.abs</code>(x: number): number :: ES1 :: 인수의 절댓값(absolute value)을 반환한다. 절댓값은 반드시 0 또는 양수이어야 한다.<br />
2.2 <code>Math.round</code>(x: number): number :: ES1 :: 인수의 소수점 이하를 반올림한 정수를 반환한다.<br />
2.3 <code>Math.ceil</code>(x: number): number :: ES1 :: 인수의 소수점 이하를 올림한 정수를 반환한다.<br />
2.4 <code>Math.floor</code>(x: number): number :: ES1 :: 인수의 소수점 이하를 내림한 정수를 반환한다. Math.ceil의 반대 개념이다.<br />
2.5 <code>Math.sqrt</code>(x: number): number :: ES1 :: 인수의 제곱근을 반환한다.<br />
2.6 <code>Math.random()</code>: number :: ES1 :: 의의 부동 소수점을 반환한다. 반환된 부동 소수점은 0부터 1 미만이다. 즉, 0은 포함되지만 1은 포함되지 않는다.<br />
2.7 <code>Math.pow</code>(x: number, y: number): number :: ES1 :: 첫번째 인수를 밑(base), 두번째 인수를 지수(exponent)로하여 거듭제곱을 반환한다.<br />
2.8 <code>Math.max</code>(…values: number[]): number :: ES1 :: 인수 중에서 가장 큰 수를 반환한다.<br />
2.9 <code>Math.min</code>(…values: number[]): number :: ES1 :: 인수 중에서 가장 작은 수를 반환한다.<br />


<pre class="mgtbD">
<code class="xmp">
Math.random(); // 0 ~ 1 미만의 부동 소수점 (0.8208720231391746)

// 1 ~ 10의 랜덤 정수 취득
// 1) Math.random로 0 ~ 1 미만의 부동 소수점을 구한 다음, 10을 곱해 0 ~ 10 미만의 부동 소수점을 구한다.
// 2) 0 ~ 10 미만의 부동 소수점에 1을 더해 1 ~ 10까지의 부동 소수점을 구한다.
// 3) Math.floor으로 1 ~ 10까지의 부동 소수점의 소수점 이하를 떼어 버린 다음 정수를 반환한다.
const random = Math.floor((Math.random() * 10) + 1);
console.log(random); // 1 ~ 10까지의 정수
</code>
</pre>

<pre class="mgtbD">
<code class="xmp">
Math.pow(2, 8);  // 256
Math.pow(2, -1); // 0.5
Math.pow(2);     // NaN

// ES7(ECMAScript 2016) Exponentiation operator(거듭 제곱 연산자)
2 ** 8; // 256
</code>
</pre>

<pre class="mgtbD">
<code class="xmp">
Math.max(1, 2, 3); // 3

// 배열 요소 중에서 최대값 취득
const arr = [1, 2, 3];
const max = Math.max.apply(null, arr); // 3

// ES6 Spread operator
Math.max(...arr); // 3
</code>
</pre>

<pre class="mgtbD">
<code class="xmp">
Math.min(1, 2, 3); // 1

// 배열 요소 중에서 최소값 취득
const arr = [1, 2, 3];
const min = Math.min.apply(null, arr); // 1

// ES6 Spread operator
Math.min(...arr); // 1
</code>
</pre>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-25">25 날짜와 시간을 위한 Date 객체</h3>


<pre>
1. Date Constructor
	1.1 new Date()
	1.2 new Date(milliseconds)
	1.3 new Date(dateString)
	1.4 new Date(year, month[, day, hour, minute, second, millisecond])
	1.5 Date 생성자 함수를 new 연산자없이 호출
2. Date 메소드
	2.1 Date.now
	2.2 Date.parse
	2.3 Date.UTC
	2.4 Date.prototype.getFullYear
	2.5 Date.prototype.setFullYear
	2.6 Date.prototype.getMonth
	2.7 Date.prototype.setMonth
	2.8 Date.prototype.getDate
	2.9 Date.prototype.setDate
	2.10 Date.prototype.getDay
	2.11 Date.prototype.getHours
	2.12 Date.prototype.setHours
	2.13 Date.prototype.getMinutes
	2.14 Date.prototype.setMinutes
	2.15 Date.prototype.getSeconds
	2.16 Date.prototype.setSeconds
	2.17 Date.prototype.getMilliseconds
	2.18 Date.prototype.setMilliseconds
	2.19 Date.prototype.getTime
	2.20 Date.prototype.setTime
	2.21 Date.prototype.getTimezoneOffset
	2.22 Date.prototype.toDateString
	2.23 Date.prototype.toTimeString
3. Date Example
Reference
</pre>


<div class="brclear clearfix"></div>
<hr class="line1t dott" />

<p>
	Date 객체는 날짜와 시간(년, 월, 일, 시, 분, 초, 밀리초(천분의 1초(millisecond, ms)))을 위한 메소드를 제공하는 빌트인 객체이면서 생성자 함수이다.
</p>
<p>
	<em class="em">Date 생성자 함수로 생성한 Date 객체는 내부적으로 숫자값을 갖는다. 이 값은 1970년 1월 1일 00:00(UTC)을 기점으로 현재 시간까지의 밀리초를 나타낸다.</em>
</p>
<p>
	UTC(협정 세계시: Coordinated Universal Time)는 GMT(그리니치 평균시: Greenwich Mean Time)로 불리기도 하는데 UTC와 GMT는 초의 소숫점 단위에서만 차이가 나기 때문에 일상에서는 혼용되어 사용된다. 기술적인 표기에서는 UTC가 사용된다.
</p>
<p>
	KST(Korea Standard Time)는 UTC/GMT에 9시간을 더한 시간이다. 즉, KST는 UTC/GMT보다 9시간이 빠르다. 예를 들어, UTC 00:00 AM은 KST 09:00 AM이다.
</p>
<p>
	현재의 날짜와 시간은 자바스크립트 코드가 동작한 시스템의 시계에 의해 결정된다. 시스템 시계의 설정(timezone, 시간)에 따라 서로 다른 값을 가질 수 있다.
</p>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">1. Date Constructor</h4>

1.1 <code>new Date()</code> :: 인수를 전달하지 않으면 현재 날짜와 시간을 가지는 인스턴스를 반환한다.<br />
1.2 <code>new Date(milliseconds)</code> :: 1970년 1월 1일 00:00(UTC)을 기점으로 인수로 전달된 milliseconds 만큼 경과한 날짜와 시간을 가지는 인스턴스를 반환한다.<br />
<div class="ofh">
	<span class="fl mgr025em">1.3 <code>new Date(dateString)</code> ::</span>
	<div class="ofh">
		인수로 날짜와 시간을 나타내는 문자열을 전달하면 지정된 날짜와 시간을 가지는 인스턴스를 반환한다.<br />
		이때 인수로 전달한 문자열은 Date.parse 메소드에 의해 해석 가능한 형식이어야 한다.<br />
	</div>
</div>
<div class="ofh">
	<span class="dpib mgr025em">1.4 <code>new Date(year, month[, day, hour, minute, second, millisecond])</code> ::</span>
	<div class="ofh mgl2em">
		인수로 년, 월, 일, 시, 분, 초, 밀리초를 의미하는 숫자를 전달하면 날짜와 시간을 가지는 인스턴스를 반환한다.<br />
		이때 년, 월은 반드시 지정하여야 한다. 지정하지 않은 옵션 정보는 0 또는 1으로 초기화된다.<br />
		년, 월을 지정하지 않은 경우 1970년 1월 1일 00:00(UTC)을 가지는 인스턴스를 반환한다.<br />
	</div>
</div>
1.5 Date 생성자 함수를 new 연산자없이 호출


<pre class="mgtbD">
<code class="xmp">
const date = new Date();
console.log(date); // Thu May 16 2019 17:16:13 GMT+0900 (한국 표준시)
</code>
</pre>

<pre class="mgtbD">
<code class="xmp">
// KST(Korea Standard Time)는 GMT(그리니치 평균시: Greenwich Mean Time)에 9시간을 더한 시간이다.
let date = new Date(0);
console.log(date); // Thu Jan 01 1970 09:00:00 GMT+0900 (한국 표준시)

// 86400000ms는 1day를 의미한다.
// 1s = 1,000ms
// 1m = 60s * 1,000ms = 60,000ms
// 1h = 60m * 60,000ms = 3,600,000ms
// 1d = 24h * 3,600,000ms = 86,400,000ms
date = new Date(86400000);
console.log(date); // FFri Jan 02 1970 09:00:00 GMT+0900 (한국 표준시)
</code>
</pre>

<pre class="mgtbD">
<code class="xmp">
let date = new Date('May 16, 2019 17:22:10');
console.log(date); // Thu May 16 2019 17:22:10 GMT+0900 (한국 표준시)

date = new Date('2019/05/16/17:22:10');
console.log(date); // Thu May 16 2019 17:22:10 GMT+0900 (한국 표준시)
</code>
</pre>


<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">1.4 new Date(year, month[, day, hour, minute, second, millisecond])</h5>


<table class="t2 waha">
  <thead>
    <tr>
      <th>인수</th>
      <th>내용</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>year</td>
      <td>1900년 이후의 년</td>
    </tr>
    <tr>
      <td>month</td>
      <td>월을 나타내는 <b class="em1">0 ~ 11</b>까지의 정수 (주의: 0부터 시작, 0 = 1월)</td>
    </tr>
    <tr>
      <td>day</td>
      <td>일을 나타내는 1 ~ 31까지의 정수</td>
    </tr>
    <tr>
      <td>hour</td>
      <td>시를 나타내는 0 ~ 23까지의 정수</td>
    </tr>
    <tr>
      <td>minute</td>
      <td>분을 나타내는 0 ~ 59까지의 정수</td>
    </tr>
    <tr>
      <td>second</td>
      <td>초를 나타내는 0 ~ 59까지의 정수</td>
    </tr>
    <tr>
      <td>millisecond</td>
      <td>밀리초를 나타내는 0 ~ 999까지의 정수</td>
    </tr>
  </tbody>
</table>


<pre class="mgtbD">
<code class="xmp">
// 월을 나타내는 4는 5월을 의미한다.
// 2019/5/1/00:00:00:00
let date = new Date(2019, 4);
console.log(date); // Wed May 01 2019 00:00:00 GMT+0900 (한국 표준시)

// 월을 나타내는 4는 5월을 의미한다.
// 2019/5/16/17:24:30:00
date = new Date(2019, 4, 16, 17, 24, 30, 0);
console.log(date); // Thu May 16 2019 17:24:30 GMT+0900 (한국 표준시)

// 가독성이 훨씬 좋다.
date = new Date('2019/5/16/17:24:30:10');
console.log(date); // Thu May 16 2019 17:24:30 GMT+0900 (한국 표준시)
</code>
</pre>


<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">1.5 Date 생성자 함수를 new 연산자없이 호출</h5>

<p>
	Date 생성자 함수를 new 연산자없이 호출하면 인스턴스를 반환하지 않고 결과값을 문자열로 반환한다.
</p>

<pre class="mgtbD">
<code class="xmp">
let date = <em class="em">new Date()</em>;
console.log(typeof date, date); // object Fri Feb 21 2020 11:19:34 GMT+0900 (대한민국 표준시)

let strDate = <em class="em">Date()</em>;
console.log(typeof strDate, strDate); // string Fri Feb 21 2020 11:19:34 GMT+0900 (대한민국 표준시)

const numNow = <em class="em">Date.now()</em>;
console.log(typeof numNow, numNow); // number 1582251574487

const today = new Date();
const numTime = today.<em class="em">getTime()</em>;
console.log(typeof numTime, numTime);  // number 1582251574487
</code>
</pre>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">2. Date 메소드</h4>

2.1 <code>Date.now</code> :: 1970년 1월 1일 00:00:00(UTC)을 기점으로 현재 시간까지 경과한 밀리초를 숫자로 반환한다.<br />
2.2 <code>Date.parse</code> :: 1970년 1월 1일 00:00:00(UTC)을 기점으로 인수로 전달된 지정 시간(new Date(dateString)의 인수와 동일한 형식)까지의 밀리초를 숫자로 반환한다.<br />
2.3 <code>Date.UTC</code> :: 1970년 1월 1일 00:00:00(UTC)을 기점으로 인수로 전달된 지정 시간까지의 밀리초를 숫자로 반환한다.<br />
2.4 <code>Date.prototype.getFullYear</code> :: 년도를 나타내는 4자리 숫자를 반환한다. // <samp>2019</samp><br />
2.5 <code>Date.prototype.setFullYear</code> :: 년도를 나타내는 4자리 숫자를 설정한다. 년도 이외 월, 일도 설정할 수 있다. // <samp>setFullYear(1900, 0, 1)</samp><br />
2.6 <code>Date.prototype.getMonth</code> :: 월을 나타내는 0 ~ 11의 정수를 반환한다. 1월은 0, 12월은 11이다. // <samp>4</samp><br />
2.7 <code>Date.prototype.setMonth</code> :: 을 나타내는 0 ~ 11의 정수를 설정한다. 1월은 0, 12월은 11이다. 월 이외 일도 설정할 수 있다. // <samp>setMonth(11, 1)</samp><br />
2.8 <code>Date.prototype.getDate</code> :: 날짜(1 ~ 31)를 나타내는 정수를 반환한다. // <samp>16</samp><br />
2.9 <code>Date.prototype.setDate</code> :: 날짜(1 ~ 31)를 나타내는 정수를 설정한다. // <samp>setDate(1)</samp><br />
2.10 <code>Date.prototype.getDay</code> :: 요일(0 ~ 6)를 나타내는 정수를 반환한다. 반환값은 일요일 0 ~ 토요일 6 이다. // <samp>4</samp><br />
2.11 <code>Date.prototype.getHours</code> :: 시간(0 ~ 23)를 나타내는 정수를 반환한다. // <samp>17</samp><br />
2.12 <code>Date.prototype.setHours</code> :: 시간(0 ~ 23)를 나타내는 정수를 설정한다. 시간 이외 분, 초, 밀리초도 설정할 수 있다. // <samp>setHours(0, 0, 0, 0)</samp><br />
2.13 <code>Date.prototype.getMinutes</code> :: 분(0 ~ 59)를 나타내는 정수를 반환한다. // <samp>50</samp><br />
2.14 <code>Date.prototype.setMinutes</code> :: 분(0 ~ 59)를 나타내는 정수를 설정한다. 분 이외 초, 밀리초도 설정할 수 있다. // <samp>setMinutes(5, 10, 999)</samp><br />
2.15 <code>Date.prototype.getSeconds</code> :: 초(0 ~ 59)를 나타내는 정수를 반환한다. // <samp>17</samp><br />
2.16 <code>Date.prototype.setSeconds</code> :: 초(0 ~ 59)를 나타내는 정수를 설정한다. 초 이외 밀리초도 설정할 수 있다. // <samp>setSeconds(10, 0)</samp><br />
2.17 <code>Date.prototype.getMilliseconds</code> :: 밀리초(0 ~ 999)를 나타내는 정수를 반환한다. // <samp>905</samp><br />
2.18 <code>Date.prototype.setMilliseconds</code> :: 밀리초(0 ~ 999)를 나타내는 정수를 설정한다. // <samp>setMilliseconds(123)</samp><br />
2.19 <code>Date.prototype.getTime</code> :: 1970년 1월 1일 00:00:00(UTC)를 기점으로 현재 시간까지 경과된 밀리초를 반환한다. // <samp>1557996968335</samp><br />
2.20 <code>Date.prototype.setTime</code> :: 1970년 1월 1일 00:00:00(UTC)를 기점으로 현재 시간까지 경과된 밀리초를 설정한다. // <samp>setTime(86400000)</samp><br />
2.21 <code>Date.prototype.getTimezoneOffset</code> :: UTC와 지정 로케일(Locale) 시간과의 차이를 분단위로 반환한다. UTC - KST = -9h = -540 분이다.<br />
2.22 <code>Date.prototype.toDateString</code> :: 사람이 읽을 수 있는 형식의 문자열로 날짜를 반환한다. // <samp>Thu May 16 2019</samp><br />
2.23 <code>Date.prototype.toTimeString</code> :: 	사람이 읽을 수 있는 형식의 문자열로 시간을 반환한다. // <samp>18:30:00 GMT+0900 (한국 표준시)</samp><br />


<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">2.1 Date.now</h5>

<pre class="mgtbD">
<code class="xmp">
const now = Date.now();
console.log(now);
</code>
</pre>

<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">2.2 Date.parse</h5>

<p>
	1970년 1월 1일 00:00:00(UTC)을 기점으로 인수로 전달된 지정 시간(new Date(dateString)의 인수와 동일한 형식)까지의 밀리초를 숫자로 반환한다.<br />
</p>

<pre class="mgtbD">
<code class="xmp">
let d = Date.parse('Jan 2, 1970 00:00:00 UTC'); // UTC
console.log(d); // 86400000

d = Date.parse('Jan 2, 1970 09:00:00'); // KST
console.log(d); // 86400000

d = Date.parse('1970/01/02/09:00:00'); // KST
console.log(d); // 86400000
</code>
</pre>

<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">2.3 Date.UTC</h5>

<p>
	1970년 1월 1일 00:00:00(UTC)을 기점으로 인수로 전달된 지정 시간까지의 밀리초를 숫자로 반환한다.
</p>
<p>
	Date.UTC 메소드는 <code>new Date(year, month[, day, hour, minute, second, millisecond])</code>와 같은 형식의 인수를 사용해야 한다.<br />
	Date.UTC 메소드의 인수는 local time(KST)가 아닌 UTC로 인식된다.<br />
</p>

<pre class="mgtbD">
<code class="xmp">
let d = Date.UTC(1970, 0, 2);
console.log(d); // 86400000

d = Date.UTC('1970/1/2');
console.log(d); // NaN
</code>
</pre>

<p>
	month는 월을 의미하는 0~11까지의 정수이다. 0부터 시작하므로 주의가 필요하다.
</p>


<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">2.22 Date.prototype.toDateString</h5>


<p>
	사람이 읽을 수 있는 형식의 문자열로 날짜를 반환한다.
</p>

<pre class="mgtbD">
<code class="xmp">
const d = new Date('2019/5/16/18:30');

console.log(d.toString());     // Thu May 16 2019 18:30:00 GMT+0900 (한국 표준시)
console.log(d.toDateString()); // Thu May 16 2019
</code>
</pre>


<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">2.23 Date.prototype.toTimeString </h5>


<p>
	사람이 읽을 수 있는 형식의 문자열로 시간을 반환한다.
</p>

<pre class="mgtbD">
<code class="xmp">
const d = new Date('2019/5/16/18:30');

console.log(d.toString());     // Thu May 16 2019 18:30:00 GMT+0900 (한국 표준시)
console.log(d.toTimeString()); // 18:30:00 GMT+0900 (한국 표준시)
</code>
</pre>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">3. Date Example</h4>


<strong class="h1 em6 big">현재 날짜와 시간을 초단위로 반복 출력하는 예제</strong>


<pre class="mgtbD">
<code class="xmp">
// 2020년 2월 21일 (금요일) 11:50:10 AM
// 2020년 2월 21일 (금요일) 11:50:11 AM
// …
(function printNow() {
  const today = new Date();

  const dayNames = ['(일요일)', '(월요일)', '(화요일)', '(수요일)', '(목요일)', '(금요일)', '(토요일)'];
  // getDay: 해당 요일(0 ~ 6)를 나타내는 정수를 반환한다.
  const day = dayNames[today.getDay()];

  const year = today.getFullYear();
  const month = today.getMonth() + 1;
  const date = today.getDate();
  let hour = today.getHours();
  let minute = today.getMinutes();
  let second = today.getSeconds();
  const ampm = hour >= 12 ? 'PM' : 'AM';

  // 12시간제로 변경
  hour %= 12;
  hour = hour || 12; // 0 => 12

  // 10미만인 분과 초를 2자리로 변경
  minute = minute < 10 ? '0' + minute : minute;
  second = second < 10 ? '0' + second : second;

  const now = `${year}년 ${month}월 ${date}일 ${day} ${hour}:${minute}:${second} ${ampm}`;

  console.log(now);
  setTimeout(printNow, 1000);
}());
</code>
</pre>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-26">26 정규표현식</h3>


<pre>
1. 정규표현식(Regular Expression)
	1.2 플래그
	1.2 패턴
	1.3 자주 사용하는 정규표현식
2. Javascript Regular Expression
	2.1 RegExp Constructor
	2.2 RegExp Method
		2.2.1 RegExp.prototype.exec(target: string): RegExpExecArray | null ES3
		2.2.2 RegExp.prototype.test(target: string): boolean ES3
Reference
</pre>

<div class="brclear clearfix"></div>
<hr class="line1t dott" />


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">1. 정규표현식(Regular Expression)</h4>

<figure class="box1 mg0 pd10px tac">
	<img src="https://poiemaweb.com/img/regular_expression.png" width="auto" height="auto" alt="정규표현식 리터럴 표기법" />
	<figcaption>정규표현식 리터럴 표기법</figcaption>
</figure>

<pre class="mgtbD">
<code class="xmp">
const targetStr = 'This is a pen.';
const regexr = /is/ig;

<b class="em0">// RegExp 객체의 메소드</b>
console.log(regexr.<em class="em">exec</em>(targetStr)); // [ 'is', index: 2, input: 'This is a pen.' ]
console.log(regexr.<em class="em">test</em>(targetStr)); // true

<b class="em0">// String 객체의 메소드</b>
console.log(targetStr.<em class="em">match</em>(regexr)); // [ 'is', 'is' ]
console.log(targetStr.<em class="em">replace</em>(regexr, 'IS')); // ThIS IS a pen.
// String.prototype.search는 검색된 문자열의 첫번째 인덱스를 반환한다.
console.log(targetStr.<em class="em">search</em>(regexr)); // 2 ← index
console.log(targetStr.<em class="em">split</em>(regexr));  // [ 'Th', ' ', ' a pen.' ]
</code>
</pre>

<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">1.2 플래그</h5>

<table class="t2 w100">
  <thead>
    <tr>
      <th>Flag</th>
      <th>Meaning</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>i</td>
      <td>Ignore Case</td>
      <td>대소문자를 구별하지 않고 검색한다.</td>
    </tr>
    <tr>
      <td>g</td>
      <td>Global</td>
      <td>문자열 내의 모든 패턴을 검색한다.</td>
    </tr>
    <tr>
      <td>m</td>
      <td>Multi Line</td>
      <td>문자열의 행이 바뀌더라도 검색을 계속한다.</td>
    </tr>
  </tbody>
</table>

<pre class="mgtbD">
<code class="xmp">
const targetStr = 'Is this all there is?';

// 문자열 is를 대소문자를 구별하여 한번만 검색한다.
let regexr = /is/;

console.log(targetStr.match(regexr)); // [ 'is', index: 5, input: 'Is this all there is?' ]

// 문자열 is를 대소문자를 구별하지 않고 대상 문자열 끝까지 검색한다.
regexr = /is/ig;

console.log(targetStr.match(regexr)); // [ 'Is', 'is', 'is' ]
console.log(targetStr.match(regexr).length); // 3
</code>
</pre>


<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">1.2 패턴</h5>

<p>
	패턴에는 검색하고 싶은 문자열을 지정한다.
	이때 문자열의 따옴표는 생략한다.
	따옴표를 포함하면 따옴표까지도 검색한다.
	또한 패턴은 특별한 의미를 가지는 메타문자(Metacharacter) 또는 기호로 표현할 수 있다. 몇가지 패턴 표현 방법을 소개한다.
</p>
<p>
	<code>.</code>은 임의의 문자 한 개를 의미한다.
	문자의 내용은 무엇이든지 상관없다.
	아래 예제의 경우 <code>.</code>를 3개 연속하여 패턴을 생성하였으므로 3자리 문자를 추출한다.
</p>

<pre class="mgtbD">
<code class="xmp">
const targetStr = 'AA BB Aa Bb';

// 임의의 문자 3개
const regexr = /.../;

console.log(targetStr.match(regexr)); // [ 'AA ', index: 0, input: 'AA BB Aa Bb' ]
</code>
</pre>

<p>
	이때 추출을 반복하지 않는다. 반복하기 위해서는 플래그 <code>g</code>를 사용한다.
</p>

<pre class="mgtbD">
<code class="xmp">
const targetStr = 'AA BB Aa Bb';

// 임의의 문자 3개를 반복하여 검색
const regexr = /.../g;

console.log(targetStr.match(regexr)); // [ 'AA ', 'BB ', 'Aa ' ]
</code>
</pre>

<p>
	모든 문자를 선택하려면 <code>.</code>와 <code>g</code>를 동시에 지정한다.
</p>

<pre class="mgtbD">
<code class="xmp">
const targetStr = 'AA BB Aa Bb';

// 임의의 한문자를 반복 검색
const regexr = /./g;

console.log(targetStr.match(regexr));
// [ 'A', 'A', ' ', 'B', 'B', ' ', 'A', 'a', ' ', 'B', 'b' ]
</code>
</pre>

<p>
	패턴에 문자 또는 문자열을 지정하면 일치하는 문자 또는 문자열을 추출한다.
</p>

<pre class="mgtbD">
<code class="xmp">
const targetStr = 'AA BB Aa Bb';

// 'A'를 검색
const regexr = /A/;

console.log(targetStr.match(regexr)); // 'A'
</code>
</pre>

<p>
	이때 대소문자를 구별하며 패턴과 일치한 첫번째 결과만 반환된다.
	대소문자를 구별하지 않게 하려면 플래그 <code>i</code>를 사용한다.
</p>

<pre class="mgtbD">
<code class="xmp">
const targetStr = 'AA BB Aa Bb';

// 'A'를 대소문자 구분없이 반복 검색
const regexr = /A/ig;

console.log(targetStr.match(regexr)); // [ 'A', 'A', 'A', 'a' ]
</code>
</pre>

<p>
	앞선 패턴을 최소 한번 반복하려면 앞선 패턴 뒤에 <code>+</code>를 붙인다.
	아래 예제의 경우, 앞선 패턴은 A이므로 A+는 A만으로 이루어진 문자열(‘A’, ‘AA’, ‘AAA’, …)를 의미한다.
</p>

<pre class="mgtbD">
<code class="xmp">
const targetStr = 'AA AAA BB Aa Bb';

// 'A'가 한번이상 반복되는 문자열('A', 'AA', 'AAA', ...)을 반복 검색
const regexr = /A+/g;

console.log(targetStr.match(regexr)); // [ 'AA', 'AAA', 'A' ]
</code>
</pre>

<p>
	<code>|</code>를 사용하면 or의 의미를 가지게 된다.
</p>

<pre class="mgtbD">
<code class="xmp">
const targetStr = 'AA BB Aa Bb';

// 'A' 또는 'B'를 반복 검색
const regexr = /A|B/g;

console.log(targetStr.match(regexr)); // [ 'A', 'A', 'B', 'B', 'A', 'B' ]
</code>
</pre>

<p>
	분해되지 않은 단어 레벨로 추출하기 위해서는 <code>+</code>를 같이 사용하면 된다.
</p>

<pre class="mgtbD">
<code class="xmp">
const targetStr = 'AA AAA BB Aa Bb';

// 'A' 또는 'B'가 한번 이상 반복되는 문자열을 반복 검색
// 'A', 'AA', 'AAA', ... 또는 'B', 'BB', 'BBB', ...
const regexr = /A+|B+/g;

console.log(targetStr.match(regexr)); // [ 'AA', 'AAA', 'BB', 'A', 'B' ]
</code>
</pre>

<p>
	위 예제는 패턴을 or로 한번 이상 반복하는 것인데 간단히 표현하면 아래와 같다.
	<em class="em"><code>[]</code>내의 문자는 or로 동작한다.</em>
	그 뒤에 <code>+</code>를 사용하여 앞선 패턴을 한번 이상 반복하게 한다.
</p>

<pre class="mgtbD">
<code class="xmp">
const targetStr = 'AA BB Aa Bb';

// 'A' 또는 'B'가 한번 이상 반복되는 문자열을 반복 검색
// 'A', 'AA', 'AAA', ... 또는 'B', 'BB', 'BBB', ...
const regexr = /[AB]+/g;

console.log(targetStr.match(regexr)); // [ 'AA', 'BB', 'A', 'B' ]
</code>
</pre>

<p>
	범위를 지정하려면 <code>[]</code>내에 <code>-</code>를 사용한다.
	아래의 경우 대문자 알파벳을 추출한다.
</p>

<pre class="mgtbD">
<code class="xmp">
const targetStr = 'AA BB ZZ Aa Bb';

// 'A' ~ 'Z'가 한번 이상 반복되는 문자열을 반복 검색
// 'A', 'AA', 'AAA', ... 또는 'B', 'BB', 'BBB', ... ~ 또는 'Z', 'ZZ', 'ZZZ', ...

const regexr = /[A-Z]+/g;

console.log(targetStr.match(regexr)); // [ 'AA', 'BB', 'ZZ', 'A', 'B' ]
</code>
</pre>

<p>
	대소문자를 구별하지 않고 알파벳을 추출하려면 아래와 같이 한다.
</p>

<pre class="mgtbD">
<code class="xmp">
const targetStr = 'AA BB Aa Bb';

// 'A' ~ 'Z' 또는 'a' ~ 'z'가 한번 이상 반복되는 문자열을 반복 검색
const regexr = /[A-Za-z]+/g;
// 아래와 동일하다.
// const regexr = /[A-Z]+/gi;

console.log(targetStr.match(regexr)); // [ 'AA', 'BB', 'Aa', 'Bb' ]
</code>
</pre>

<p>
	숫자를 추출하는 방법이다.
</p>

<pre class="mgtbD">
<code class="xmp">
const targetStr = 'AA BB Aa Bb 24,000';

// '0' ~ '9'가 한번 이상 반복되는 문자열을 반복 검색
const regexr = /[0-9]+/g;

console.log(targetStr.match(regexr)); // [ '24', '000' ]
</code>
</pre>

<p>
	컴마 때문에 결과가 분리되므로 패턴에 포함시킨다.
</p>

<pre class="mgtbD">
<code class="xmp">
const targetStr = 'AA BB Aa Bb 24,000';

// '0' ~ '9' 또는 ','가 한번 이상 반복되는 문자열을 반복 검색
const regexr = /[0-9,]+/g;

console.log(targetStr.match(regexr)); // [ '24,000' ]
</code>
</pre>

<p>
	이것을 간단히 표현하면 아래와 같다. <code>\d</code>는 숫자를 의미한다. <code>\D</code>는 <code>\d</code>와 반대로 동작한다.
</p>

<pre class="mgtbD">
<code class="xmp">
const targetStr = 'AA BB Aa Bb 24,000';

// '0' ~ '9' 또는 ','가 한번 이상 반복되는 문자열을 반복 검색
let regexr = /[\d,]+/g;

console.log(targetStr.match(regexr)); // [ '24,000' ]

// '0' ~ '9'가 아닌 문자(숫자가 아닌 문자) 또는 ','가 한번 이상 반복되는 문자열을 반복 검색
regexr = /[\D,]+/g;

console.log(targetStr.match(regexr)); // [ 'AA BB Aa Bb ', ',' ]
</code>
</pre>

<p>
	<code>\w</code>는 알파벳과 숫자를 의미한다. <code>\W</code>는 <code>\w</code>와 반대로 동작한다.
</p>

<pre class="mgtbD">
<code class="xmp">
const targetStr = 'AA BB Aa Bb 24,000';

// 알파벳과 숫자 또는 ','가 한번 이상 반복되는 문자열을 반복 검색
let regexr = /[\w,]+/g;

console.log(targetStr.match(regexr)); // [ 'AA', 'BB', 'Aa', 'Bb', '24,000' ]

// 알파벳과 숫자가 아닌 문자 또는 ','가 한번 이상 반복되는 문자열을 반복 검색
regexr = /[\W,]+/g;

console.log(targetStr.match(regexr)); // [ ' ', ' ', ' ', ' ', ',' ]
</code>
</pre>


<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">1.3 자주 사용하는 정규표현식</h5>


<p>
	<strong class="h1 em6">특정 단어로 시작하는지 검사한다.</strong>
</p>

<pre class="mgtbD">
<code class="xmp">
const url = 'http://example.com';

// 'http'로 시작하는지 검사
// ^ : 문자열의 처음을 의미한다.
const regexr = /^http/;

console.log(regexr.test(url)); // true
</code>
</pre>

<p>
	<strong class="h1 em6">특정 단어로 끝나는지 검사한다.</strong>
</p>

<pre class="mgtbD">
<code class="xmp">
const fileName = 'index.html';

// 'html'로 끝나는지 검사
// $ : 문자열의 끝을 의미한다.
const regexr = /html$/;

console.log(regexr.test(fileName)); // true
</code>
</pre>

<p>
	<strong class="h1 em6">숫자인지 검사한다.</strong>
</p>

<pre class="mgtbD">
<code class="xmp">
const targetStr = '12345';

// 모두 숫자인지 검사
// [^]: 부정(not)을 의미한다. 얘를 들어 [^a-z]는 알파벳 소문자로 시작하지 않는 모든 문자를 의미한다.
// [] 바깥의 ^는 문자열의 처음을 의미한다.
const regexr = /^\d+$/;

console.log(regexr.test(targetStr)); // true
</code>
</pre>

<p>
	<strong class="h1 em6">하나 이상의 공백으로 시작하는지 검사한다.</strong>
</p>

<pre class="mgtbD">
<code class="xmp">
const targetStr = ' Hi!';

// 1개 이상의 공백으로 시작하는지 검사
// \s : 여러 가지 공백 문자 (스페이스, 탭 등) => [\t\r\n\v\f]
const regexr = /^[\s]+/;

console.log(regexr.test(targetStr)); // true
</code>
</pre>

<p>
	<strong class="h1 em6">아이디로 사용 가능한지 검사한다. (영문자, 숫자만 허용, 4~10자리)</strong>
</p>

<pre class="mgtbD">
<code class="xmp">
const id = 'abc123';

// 알파벳 대소문자 또는 숫자로 시작하고 끝나며 4 ~10자리인지 검사
// {4,10}: 4 ~ 10자리
const regexr = /^[A-Za-z0-9]{4,10}$/;

console.log(regexr.test(id)); // true
</code>
</pre>

<p>
	<strong class="h1 em6">메일 주소 형식에 맞는지 검사한다.</strong>
</p>

<pre class="mgtbD">
<code class="xmp">
const email = 'ungmo2@gmail.com';

const regexr = /^[0-9a-zA-Z]([-_\.]?[0-9a-zA-Z])*@[0-9a-zA-Z]([-_\.]?[0-9a-zA-Z])*\.[a-zA-Z]{2,3}$/;

console.log(regexr.test(email)); // true
</code>
</pre>

<p>
	<strong class="h1 em6">핸드폰 번호 형식에 맞는지 검사한다.</strong>
</p>

<pre class="mgtbD">
<code class="xmp">
const cellphone = '010-1234-5678';

const regexr = /^\d{3}-\d{3,4}-\d{4}$/;

console.log(regexr.test(cellphone)); // true
</code>
</pre>

<p>
	<strong class="h1 em6">특수 문자 포함 여부를 검사한다.</strong>
</p>

<pre class="mgtbD">
<code class="xmp">
const targetStr = 'abc#123';

// A-Za-z0-9 이외의 문자가 있는지 검사
let regexr = /[^A-Za-z0-9]/gi;

console.log(regexr.test(targetStr)); // true

// 아래 방식도 동작한다. 이 방식의 장점은 특수 문자를 선택적으로 검사할 수 있다.
regexr = /[\{\}\[\]\/?.,;:|\)*~`!^\-_+<>@\#$%&\\\=\(\'\"]/gi;

console.log(regexr.test(targetStr)); // true

// 특수 문자 제거
console.log(targetStr.replace(regexr, '')); // abc123
</code>
</pre>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">2. Javascript Regular Expression</h4>

<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">2.1 RegExp Constructor</h5>

<pre class="box2 em6 big">
new RegExp(pattern[, flags])
</pre>

<pre class="mgtbD">
<code class="xmp">
// 정규식 리터럴
/ab+c/i;

new RegExp('ab+c', 'i');

new RegExp(/ab+c/, 'i');

new RegExp(/ab+c/i); // ES6
</code>
</pre>


<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">2.2 RegExp Method</h5>
<!-- ◇◆ -->
<h6 class="hb1 h6">2.2.1 RegExp.prototype.exec(target: string): RegExpExecArray | null (( ES3 ))</h6>

<p>
	문자열을 검색하여 매칭 결과를 반환한다. 반환값은 배열 또는 null이다.
</p>

<pre class="mgtbD">
<code class="xmp">
<pre class="mgtbD">
<code class="xmp">
const target = 'Is this all there is?';
const regExp = /is/;

const res = regExp.exec(target);
console.log(res); // [ 'is', index: 5, input: 'Is this all there is?' ]
</code>
</pre>
</code>
</pre>

<p>
	exec 메소드는 g 플래그를 지정하여도 첫번째 메칭 결과만을 반환한다.
</p>

<pre class="mgtbD">
<code class="xmp">
const target = 'Is this all there is?';
const regExp = /is/g;

const res = regExp.exec(target);
console.log(res); // [ 'is', index: 5, input: 'Is this all there is?' ]
</code>
</pre>


<!-- ◇◆ -->
<h6 class="hb1 h6">2.2.2 RegExp.prototype.test(target: string): boolean (( ES3 ))</h6>

<p>
	문자열을 검색하여 매칭 결과를 반환한다. 반환값은 true 또는 false이다.
</p>

<pre class="mgtbD">
<code class="xmp">
const target = 'Is this all there is?';
const regExp = /is/;

const res = regExp.test(target);
console.log(res); // true
</code>
</pre>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">Reference</h4>

<ul class="bu">
<li>
	<a href="https://ko.wikipedia.org/wiki/%EC%A0%95%EA%B7%9C_%ED%91%9C%ED%98%84%EC%8B%9D" target="_blank" rel="noopener" title="새 창" class="a1">
		정규 표현식
	</a>
</li>
</ul>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-27">27 String 레퍼 객체</h3>


<pre>
1. String Constructor
2. String Property
	2.1 String.length
3. String Method
	3.1 String.prototype.charAt(pos: number): string ES1
	3.2 String.prototype.concat(…strings: string[]): string ES3
	3.3 String.prototype.indexOf(searchString: string, fromIndex=0): number ES1
	3.4 String.prototype.lastIndexOf(searchString: string, fromIndex=this.length-1): number ES1
	3.5 String.prototype.replace(searchValue: string | RegExp, replaceValue: string | replacer: (substring: string, …args: any[]) => string): string): string ES3
	3.6 String.prototype.split(separator: string | RegExp, limit?: number): string[] ES3
	3.7 String.prototype.substring(start: number, end=this.length): string ES3
	3.8 String.prototype.slice(start?: number, end?: number): string ES3
	3.9 String.prototype.toLowerCase(): string ES1
	3.10 String.prototype.toUpperCase(): string ES1
	3.11 String.prototype.trim(): string ES5
	3.12 String.prototype.repeat(count: number): string ES6
	3.13 String​.prototype​.includes(searchString: string, position?: number): boolean ES6
Reference
</pre>


<div class="brclear clearfix"></div>
<hr class="line1t dott" />


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">1. String Constructor</h4>

<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">2. String Property</h4>

<p>
	2.1 String.length :: 문자열 내의 문자 갯수를 반환한다. String 객체는 length 프로퍼티를 소유하고 있으므로 유사 배열 객체이다.
</p>

<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">3. String Method</h4>

3.1 String.prototype.<code>charAt</code>(pos: number): string :: ES1 :: 인수로 전달한 index를 사용하여 index에 해당하는 위치의 문자를 반환한다. <br />
3.2 String.prototype.<code>concat</code>(…strings: string[]): string :: ES3 :: 인수로 전달한 1개 이상의 문자열과 연결하여 새로운 문자열을 반환한다.<br />
<div class="ofh">
	<span class="dpib">3.3 String.prototype.<code>indexOf</code>(searchString: string, fromIndex=0): number :: ES1 ::</span>
	<div class="ofh mgl2em">
		인수로 전달한 문자 또는 문자열을 대상 문자열에서 검색하여 처음 발견된 곳의 index를 반환한다.<br />
		발견하지 못한 경우 -1을 반환한다.<br />
	</div>
</div>
<div class="ofh">
	<span class="dpib">3.4 String.prototype.<code>lastIndexOf</code>(searchString: string, fromIndex=this.length-1): number :: ES1 ::</span>
	<div class="ofh mgl2em">
		인수로 전달한 문자 또는 문자열을 대상 문자열에서 검색하여 마지막으로 발견된 곳의 index를 반환한다.<br />
		발견하지 못한 경우 -1을 반환한다.<br />
	</div>
</div>
<div class="ofh">
	<span class="mgr025em">3.5 String.prototype.<code>replace</code>(searchValue: string | RegExp, replaceValue: string | replacer: (substring: string, …args: any[]) => string): string): string :: ES3 ::</span>
	<div class="ofh mgl2em">
		첫번째 인수로 전달한 문자열 또는 정규표현식을 대상 문자열에서 검색하여 두번째 인수로 전달한 문자열로 대체한다.<br />
		원본 문자열은 변경되지 않고 결과가 반영된 새로운 문자열을 반환한다.<br />
		검색된 문자열이 여럿 존재할 경우 첫번째로 검색된 문자열만 대체된다.<br />
	</div>
</div>
<div class="ofh">
	<span class="dpib">3.6 String.prototype.<code>split</code>(separator: string | RegExp, limit?: number): string[] :: ES3 ::</span>
	<div class="ofh mgl2em">
		첫번째 인수로 전달한 문자열 또는 정규표현식을 대상 문자열에서 검색하여 문자열을 구분한 후 분리된 각 문자열로 이루어진 배열을 반환한다.<br />
		원본 문자열은 변경되지 않는다.<br />
	</div>
</div>
<div class="ofh">
<span class="dpib">3.7 String.prototype.<code>substring</code>(start: number, end=this.length): string :: ES3 ::</span>
	<div class="ofh mgl2em">
		첫번째 인수로 전달한 start 인덱스에 해당하는 문자부터 두번째 인자에 전달된 end 인덱스에 해당하는 문자의 바로 이전 문자까지를 모두 반환한다.<br />
		이때 첫번째 인수 &lt; 두번째 인수의 관계가 성립된다.<br />
	</div>
</div>
<div class="ofh">
	<span class="dpib">3.8 String.prototype.<code>slice</code>(start?: number, end?: number): string :: ES3 ::</span>
	<div class="ofh mgl2em">
		String.prototype.substring과 동일하다.<br />
		단, String.prototype.slice는 <em class="em">음수의 인수를 전달할 수 있다.</em><br />
	</div>
</div>
3.9 String.prototype.<code>toLowerCase</code>(): string :: ES1 :: 대상 문자열의 모든 문자를 소문자로 변경한다.<br />
3.10 String.prototype.<code>toUpperCase</code>(): string :: ES1 :: 대상 문자열의 모든 문자를 대문자로 변경한다.<br />
3.11 String.prototype.<code>trim</code>(): string :: ES5 :: 대상 문자열 양쪽 끝에 있는 공백 문자를 제거한 문자열을 반환한다.<br />
<div class="ofh">
	<span class="dpib">3.12 String.prototype.<code>repeat</code>(count: number): string :: ES6 ::</span>
	<div class="ofh mgl2em">
		인수로 전달한 숫자만큼 반복해 연결한 새로운 문자열을 반환한다.<br />
		count가 0이면 빈 문자열을 반환하고 음수이면 RangeError를 발생시킨다.<br />
	</div>
</div>
<div class="ofh">
	<span class="dpib">3.13 String​.prototype​.<code>includes</code>(searchString: string, position?: number): boolean :: ES6 ::</span>
	<div class="ofh mgl2em">
		인수로 전달한 문자열이 포함되어 있는지를 검사하고 결과를 불리언 값으로 반환한다.<br />
		두번째 인수는 옵션으로 검색할 위치를 나타내는 정수이다.<br />
	</div>
</div>


<div class="bdt1px mgt2em mgb15em"></div>


<pre class="mgtbD">
<code class="xmp">
const str = 'Hello';

console.log(str.charAt(0)); // H
console.log(str.charAt(1)); // e
console.log(str.charAt(2)); // l
console.log(str.charAt(3)); // l
console.log(str.charAt(4)); // o
// 지정한 index가 범위(0 ~ str.length-1)를 벗어난 경우 빈문자열을 반환한다.
console.log(str.charAt(5)); // ''

// 문자열 순회. 문자열은 length 프로퍼티를 갖는다.
for (let i = 0; i < str.length; i++) {
  console.log(str.charAt(i));
}

// String 객체는 유사 배열 객체이므로 배열과 유사하게 접근할 수 있다.
for (let i = 0; i < str.length; i++) {
  console.log(str[i]); // str['0']
}
</code>
</pre>

<p>
	concat 메소드를 사용하는 것보다는 +, += 할당 연산자를 사용하는 것이 성능상 유리하다.
</p>

<pre class="mgtbD">
<code class="xmp">
const str = 'Hello World';

console.log(str.indexOf('l'));  // 2
console.log(str.indexOf('or')); // 7
console.log(str.indexOf('or' , 8)); // -1

if (str.indexOf('Hello') !== -1) {
  // 문자열 str에 'hello'가 포함되어 있는 경우에 처리할 내용
}

// ES6: String.prototype.includes
if (str.includes('Hello')) {
  // 문자열 str에 'hello'가 포함되어 있는 경우에 처리할 내용
}
</code>
</pre>

<pre class="mgtbD">
<code class="xmp">
const str = 'hello world';

// 인수 < 0 또는 NaN인 경우 : 0으로 취급된다.
console.log(str.substring(-5)); // 'hello world'
// 뒤에서 5자리를 잘라내어 반환한다.
console.log(str.slice(-5)); // 'world'

// 2번째부터 마지막 문자까지 잘라내어 반환
console.log(str.substring(2)); // llo world
console.log(str.slice(2)); // llo world

// 0번째부터 5번째 이전 문자까지 잘라내어 반환
console.log(str.substring(0, 5)); // hello
console.log(str.slice(0, 5)); // hello
</code>
</pre>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-28">28 배열</h3>


<pre>
1. 배열의 생성
	1.1 배열 리터럴
	1.2 Array() 생성자 함수
2. 배열 요소의 추가와 삭제
	2.1 배열 요소의 추가
	2.2 배열 요소의 삭제
3. 배열의 순회
4. Array Property
	4.1 Array.length
5. Array Method
	5.1 Array.isArray(arg: any): boolean ES5
	5.2 Array.from ES6
	5.3 Array.of ES6
	5.4 Array.prototype.indexOf(searchElement: T, fromIndex?: number): number 🔒 ES5
	5.5 Array.prototype.concat(…items: Array<T[] | T>): T[] 🔒 ES3
	5.6 Array.prototype.join(separator?: string): string 🔒 ES1
	5.7 Array.prototype.pop(): T | undefined ✏️ ES3
	5.8 Array.prototype.push(…items: T[]): number ✏️ ES3
	5.9 Array.prototype.reverse(): this ✏️ ES1
	5.10 Array.prototype.shift(): T | undefined ✏️ ES3
	5.11 Array.prototype.slice(start=0, end=this.length): T[] 🔒 ES3
	5.12 Array.prototype.splice(start: number, deleteCount=this.length-start, …items: T[]): T[] ✏️ ES3
Reference
</pre>


<div class="brclear clearfix"></div>
<hr class="line1t dott" />


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">1. 배열의 생성</h4>

<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">1.1 배열 리터럴</h5>

<p>
	대부분의 프로그래밍 언어에서 배열의 요소들은 모두 같은 데이터 타입이어야 하지만,
	자바스크립트 배열은 어떤 데이터 타입의 조합이라도 포함할 수 있다.
</p>

<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">1.2 Array() 생성자 함수</h5>

<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">2. 배열 요소의 추가와 삭제</h4>

<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">2.1 배열 요소의 추가</h5>
<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">2.2 배열 요소의 삭제</h5>

<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">3. 배열의 순회</h4>

<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">4. Array Property</h4>

<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">4.1 Array.lengthas</h5>

<p>
	주의할 것은 배열 요소의 개수와 length 프로퍼티의 값이 반드시 일치하지는 않는다는 것이다.
</p>

<div class="pd20px-rv bg-info">
배열 요소의 개수와 length 프로퍼티의 값이 일치하지 않는 배열을 <b class="em0">희소 배열(sparse array)</b>이라 한다.
희소 배열은 배열의 요소가 연속적이지 않은 배열을 의미한다.
희소 배열이 아닌 일반 배열은 배열의 요소 개수와 length 프로퍼티의 값이 언제나 일치하지만
희소 배열은 배열의 요소 개수보다 length 프로퍼티의 값이 언제나 크다.
희소 배열은 일반 배열보다 느리며 메모리를 낭비한다.
</div>

<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">5. Array Method</h4>

<ul class="bu">
<li>✏️ 메소드는 <code>this</code>(원본 배열)를 변경한다.</li>
<li>🔒 메소드는 <code>this</code>(원본 배열)를 변경하지 않는다.</li>
</ul>
<p>
	Array 객체가 제공하는 유용한 고차 함수에 대해서는 배열 고차 함수에서 살펴보도록 하자.
</p>

5.1 Array.<code>isArray</code>(arg: any): boolean :: ES5 :: 객체가 배열이면 true, 배열이 아니면 false를 반환한다.<br />
5.2 Array.<code>from</code> :: ES6 :: 이터러블을 배열로 변환하여 반환한다.<br />
5.3 Array.<code>of</code> :: ES6 :: 주어진 인수로 새로운 배열을 생성하여 반환한다.<br />
5.4 Array.prototype.<code>indexOf</code>(searchElement: T, fromIndex?: number): number 🔒 :: ES5 ::<br />
<div class="mgl2em">
	indexOf 메소드의 인자로 지정된 요소를 배열에서 검색하여 인덱스를 반환한다.<br />
	중복되는 요소가 있는 경우 첫번째 인덱스만 반환된다.<br />
	만일 해당하는 요소가 없는 경우, -1을 반환한다.<br />
</div>
5.5 Array.prototype.<code>concat</code>(…items: Array<T[] | T>): T[] 🔒 :: ES3 ::
<div class="mgl2em">
	concat 메소드의 인수로 넘어온 값들(배열 또는 값)을 자신의 복사본에 요소로 추가하고 반환한다.<br />
	이때 원본 배열은 변경되지 않는다.<br />
</div>
5.6 Array.prototype.<code>join</code>(separator?: string): string 🔒 :: ES1 ::
<div class="mgl2em">
	배열 요소 전체를 연결하여 생성한 문자열을 반환한다.
	구분자(separator)는 생략 가능하며 기본 구분자는 ,이다.<br />
</div>
5.7 Array.prototype.<code>pop</code>(): T | undefined ✏️ :: ES3 ::
<div class="mgl2em">
	배열에서 마지막 요소를 제거하고 제거한 요소를 반환한다.<br />
	만약 빈 배열일 경우 undefined를 반환한다.<br />
	pop 메소드는 대상 배열 자체를 변경한다.<br />
</div>
5.8 Array.prototype.<code>push</code>(…items: T[]): number ✏️ :: ES3 :: <br />
<div class="mgl2em">
	인자로 전달된 항목을 배열의 마지막에 추가한다.<br />
	concat 메소드와 다르게 인자로 전달된 항목을 마지막 요소로 추가한다.<br />
	반환값은 배열의 새로운 length 값이다.<br />
	push 메소드는 대상 배열 자체를 변경한다.<br />
</div>
5.9 Array.prototype.<code>reverse</code>(): this ✏️ :: ES1 ::
<div class="mgl2em">
	배열 요소의 순서를 반대로 변경한다.<br />
	이때 원본 배열이 변경된다.<br />
	반환값은 변경된 배열이다.<br />
</div>
5.10 Array.prototype.<code>shift</code>(): T | undefined ✏️ :: ES3 ::
<div class="mgl2em">
	배열에서 첫요소를 제거하고 제거한 요소를 반환한다.<br />
	만약 빈 배열일 경우 undefined를 반환한다.<br />
	shift 메소드는 대상 배열 자체를 변경한다.<br />
</div>
5.11 Array.prototype.<code>slice</code>(start=0, end=this.length): T[] 🔒 :: ES3 ::
<div class="mgl2em">
	인자로 지정된 배열의 부분을 복사하여 반환한다.<br />
	원본 배열은 변경되지 않는다.<br />
</div>
5.12 Array.prototype.<code>splice</code>(start: number, deleteCount=this.length-start, …items: T[]): T[] ✏️ :: ES3 ::
<div class="mgl2em">
	기존의 배열의 요소를 제거하고 그 위치에 새로운 요소를 추가한다.<br />
	배열 중간에 새로운 요소를 추가할 때도 사용된다.<br />
</div>

<div class="brclear clearfix"></div>
<div class="bdt1px mgt2em mgb15em"></div>


<p>
	배열의 마지막에 값을 추가 할 때는 Array.prototype.push,<br />
	선두에 추가 할 때는 Array.prototype.unshift,<br />
	중간에 추가할 때는 Array.prototype.splice 메소드를 사용한다.<br />
</p>
<p>
	단, push, unshift 메소드는 사용하기 간편하나 performance 면에서는 좋은 방법은 아니다.
</p>

<pre class="mgtbD">
<code class="xmp">
var arr = [1, 2, 3, 4, 5];

arr.push(6);
arr[arr.length] = 6; // 43% faster in Chrome 47.0.2526.106 on Mac OS X 10.11.1

arr.unshift(0);
[0].concat(arr); // 98% faster in Chrome 47.0.2526.106 on Mac OS X 10.11.1
</code>
</pre>


<figure class="box1 mg0 pd10px tac">
	<img src="https://poiemaweb.com/img/array-method.png" alt="★대체텍스트필수" />
	<figcaption>
		<code>shift</code>는 <code>push</code>와 함께 배열을 <b class="em0">큐</b>(FIFO: First In First Out)처럼 동작하게 한다.<br />
		<code>pop</code>은 <code>push</code>와 함께 배열을 <b class="em0">스택</b>(LIFO: Last In First Out)처럼 동작하게 한다.<br />
	</figcaption>
</figure>


<p>
	slice 메소드에 인자를 전달하지 않으면 원본 배열의 복사본을 생성하여 반환한다.
</p>
<p>
	이때 원본 배열의 각 요소를 얕은 복사(shallow copy)하여 새로운 복사본을 생성한다.
</p>
<p>
	이를 이용하여 arguments, HTMLCollection, NodeList와 같은 유사 배열 객체(Array-like Object)를 배열로 변환할 수 있다.
</p>

<pre class="mgtbD">
<code class="xmp">
function sum() {
  // 유사 배열 객체 => Array
  var arr = Array.prototype.slice.call(arguments);
  console.log(arr); // [1, 2, 3]

  return arr.reduce(function (pre, cur) {
    return pre + cur;
  });
}

console.log(sum(1, 2, 3));
</code>
</pre>

<p>
	ES6에서 유사 배열 객체를 배열로 변환하는 방법은 아래와 같다.
</p>

<pre class="mgtbD">
<code class="xmp">
// 유사 배열 객체 => Array
function sum() {
  ...
  // Spread 문법
  var arr = [...arguments];
  // Array.from 메소드는 유사 배열 객체를 복사하여 배열을 생성한다.
  var arr = Array.from(arguments);
  ...
}
</code>
</pre>



<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-29">29 자바스크립트 배열은 배열이 아니다</h3>




<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-30">30 배열 고차 함수</h3>


<pre>
1. Array.prototype.sort(compareFn?: (a: T, b: T) => number): this ✏️ ES1
2. Array.prototype.forEach(callback: (value: T, index: number, array: T[]) => void, thisArg?: any): void 🔒 ES5
3. Array.prototype.map&lt;U&gt;(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any): U[] 🔒 ES5
4. Array.prototype.filter(callback: (value: T, index: number, array: Array) => any, thisArg?: any): T[] 🔒 ES5
5. Array.prototype.reduce&lt;U&gt;(callback: (state: U, element: T, index: number, array: T[]) => U, firstState?: U): U 🔒 ES5
6. Array.prototype.some(callback: (value: T, index: number, array: Array) => boolean, thisArg?: any): boolean 🔒 ES5
7. Array.prototype.every(callback: (value: T, index: number, array: Array) => boolean, thisArg?: any): boolean 🔒 ES5
8. Array.prototype.find(predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?: any): T | undefined 🔒 ES6
9. Array.prototype.findIndex(predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?: any): number 🔒 ES6
Reference
</pre>


<div class="brclear clearfix"></div>
<hr class="line1t dott" />


<p>
	<em class="em">고차 함수(Higher order function)는 함수를 인자로 전달받거나 함수를 결과로 반환하는 함수를 말한다.</em><br />
	다시 말해, 고차 함수는 인자로 받은 함수를 필요한 시점에 호출하거나 <b class="em0">클로저</b>를 생성하여 반환한다.<br />
	자바스크립트의 함수는 <b class="em0">일급 객체</b>이므로 값처럼 인자로 전달할 수 있으며 반환할 수도 있다.<br />
</p>

<ul class="bu">
<li>✏️ 메소드는 this(원본 배열)를 변경한다.</li>
<li>🔒 메소드는 this(원본 배열)를 변경하지 않는다.</li>
</ul>


1. Array.prototype.<code>sort</code>(compareFn?: (a: T, b: T) => number): this ✏️ :: ES1 :: <br />
<p class="mgl2em">
	[IE9+]<br />
	배열의 요소를 적절하게 정렬한다. 원본 배열을 직접 변경하며 <em class="em">정렬된 배열을 반환한다.</em><br />
</p>

2. Array.prototype.<code>forEach</code>(callback: (value: T, index: number, array: T[]) => void, thisArg?: any): void 🔒 :: ES5 :: <br />
<p class="mgl2em">
	[IE9+]<br />
	배열을 순회하며 배열의 각 요소에 대하여 <em class="em">인자로 주어진 콜백함수를 실행한다.</em><br />
</p>

3. Array.prototype.<code>map&lt;U&gt;</code>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any): U[] 🔒 :: ES5 :: <br />
<p class="mgl2em">
	[IE9+]<br />
	배열을 순회하며 각 요소에 대하여 인자로 주어진 콜백 함수의 <em class="em">반환값(결과값)으로 새로운 배열을 생성하여 반환한다.</em><br />
	이때 원본 배열은 변경되지 않는다.<br />
</p>

4. Array.prototype.<code>filter</code>(callback: (value: T, index: number, array: Array) => any, thisArg?: any): T[] 🔒 :: ES5 :: <br />
<p class="mgl2em">
	[IE9+]<br />
	filter 메소드를 사용하면 if 문을 대체할 수 있다.<br />
	배열을 순회하며 각 요소에 대하여 인자로 주어진 콜백함수의 실행 결과가 true인 배열 요소의 값만을 추출한 새로운 <em class="em">배열을 반환한다.</em><br />
</p>

5. Array.prototype.<code>reduce&lt;U&gt;</code>(callback: (state: U, element: T, index: number, array: T[]) => U, firstState?: U): U 🔒 :: ES5 :: <br />
<p class="mgl2em">
	[IE9+]<br />
	배열을 순회하며 각 요소에 대하여 이전의 콜백함수 실행 반환값을 전달하여 콜백함수를 실행하고 그 결과를 반환한다.<br />
	객체의 프로퍼티 값을 합산하는 경우에는 반드시 초기값을 전달해야 한다.<br />
	따라서 reduce를 호출할 때는 <em class="em">언제나 초기값을 전달하는 것이 보다 안전하다.</em><br />
</p>

6. Array.prototype.<code>some</code>(callback: (value: T, index: number, array: Array) => boolean, thisArg?: any): boolean 🔒 :: ES5 :: <br />
<p class="mgl2em">
	[IE9+]<br />
	<em class="em">배열 내 일부 요소</em>가 콜백 함수의 테스트를 통과하는지 확인하여 그 결과를 boolean으로 반환한다. 
</p>

7. Array.prototype.<code>every</code>(callback: (value: T, index: number, array: Array) => boolean, thisArg?: any): boolean 🔒 :: ES5 :: <br />
<p class="mgl2em">
	[IE9+]<br />
	<em class="em">배열 내 모든 요소</em>가 콜백함수의 테스트를 통과하는지 확인하여 그 결과를 boolean으로 반환한다.
</p>

8. Array.prototype.<code>find</code>(predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?: any): T | undefined 🔒 :: ES6 :: <br />
<p class="mgl2em">
	[~IE11](X)<br />
	배열을 순회하며 각 요소에 대하여 인자로 주어진 콜백함수를 실행하여 그 결과가 <em class="em">참인 첫번째 요소를 반환한다.</em><br />
	콜백함수의 실행 결과가 참인 요소가 존재하지 않는다면 undefined를 반환한다.<br />
	참고로 <code>filter</code>는 콜백함수의 실행 결과가 true인 배열 요소의 값만을 추출한 새로운 <em class="em">배열을 반환한다.</em><br />
</p>

9. Array.prototype.<code>findIndex</code>(predicate: (value: T, index: number, obj: T[]) => boolean, thisArg?: any): number 🔒 :: ES6 :: <br />
<p class="mgl2em">
	[~IE11](X)<br />
	배열을 순회하며 각 요소에 대하여 인자로 주어진 콜백함수를 실행하여 그 결과가 <em class="em">참인 첫번째 요소의 인덱스를 반환한다.</em><br />
	콜백함수의 실행 결과가 참인 요소가 존재하지 않는다면 -1을 반환한다.<br />
</p>


<div class="brclear clearfix"></div>
<div class="bdt1px mgt2em mgb15em"></div>


<pre class="mgtbD">
<code class="xmp">
const points = [40, 100, 1, 5, 2, 25, 10];

// 숫자 배열 오름차순 정렬
// 비교 함수의 반환값이 0보다 작은 경우, a를 우선하여 정렬한다.
points.sort(function (a, b) { return a - b; });
// ES6 화살표 함수
// points.sort((a, b) => a - b);
console.log(points); // [ 1, 2, 5, 10, 25, 40, 100 ]

// 숫자 배열에서 최소값 취득
console.log(points[0]); // 1

// 숫자 배열 내림차순 정렬
// 비교 함수의 반환값이 0보다 큰 경우, b를 우선하여 정렬한다.
points.sort(function (a, b) { return b - a; });
// ES6 화살표 함수
// points.sort((a, b) => b - a);
console.log(points); // [ 100, 40, 25, 10, 5, 2, 1 ]

// 숫자 배열에서 최대값 취득
console.log(points[0]); // 100
</code>
</pre>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-31">31 문서 객체 모델(Document Object Model)</h3>


<pre>
1. DOM (Document Object Model)
2. DOM tree
3. DOM Query / Traversing (요소에의 접근)
	3.1 하나의 요소 노드 선택(DOM Query)
	3.2 여러 개의 요소 노드 선택(DOM Query)
	3.3 DOM Traversing (탐색)
4. DOM Manipulation (조작)
	4.1 텍스트 노드에의 접근/수정
	4.2 어트리뷰트 노드에의 접근/수정
	4.3 HTML 콘텐츠 조작(Manipulation)
	4.4 DOM 조작 방식
	4.5 insertAdjacentHTML()
	4.6 innerHTML vs. DOM 조작 방식 vs. insertAdjacentHTML()
5. style
Reference
</pre>


<div class="brclear clearfix"></div>
<hr class="line1t dott" />

<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">1. DOM (Document Object Model)</h4>

<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">2. DOM tree</h4>

<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">3. DOM Query / Traversing (요소에의 접근)</h4>

<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">3.1 하나의 요소 노드 선택(DOM Query)</h5>

<div class="panel2">
document.<b class="em9">getElementById</b>(id)<br />
</div>

id 어트리뷰트 값으로 요소 노드를 한 개 선택한다.<br />
복수개가 선택된 경우, 첫번째 요소만 반환한다.<br />
Return: HTMLElement를 상속받은 객체<br />
모든 브라우저에서 동작<br />

<div class="panel2">
document.<b class="em9">querySelector</b>(cssSelector)<br />
</div>

CSS 셀렉터를 사용하여 요소 노드를 한 개 선택한다.<br />
복수개가 선택된 경우, 첫번째 요소만 반환한다.<br />
Return: HTMLElement를 상속받은 객체<br />
IE8 이상의 브라우저에서 동작<br />


<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">3.2 여러 개의 요소 노드 선택(DOM Query)</h5>

<div class="panel2">
document.<b class="em9">getElementsByClassName</b>(class)<br />
</div>

class 속성 값으로 요소 노드를 모두 선택한다.<br />
공백으로 구분하여 여러 개의 class를 지정할 수 있다.<br />
Return: <em class="em2">HTMLCollection (live)</em><br />
IE9 이상의 브라우저에서 동작<br />
<br />

<xmp class="xmp">
<ul>
	<li id="one" class="red">Seoul</li>
	<li id="two" class="red">London</li>
	<li id="three" class="red">Newyork</li>
	<li id="four">Tokyo</li>
</ul>
</xmp>

<pre class="mgtbD">
<code class="xmp">
// HTMLCollection을 반환한다. HTMLCollection은 live하다.
const elems = document.getElementsByClassName('red');

for (let i = 0; i < elems.length; i++) {
  // 클래스 어트리뷰트의 값을 변경한다.
  elems[i].className = 'blue';
}
</code>
</pre>

위 예제를 실행해 보면 예상대로 동작하지 않는다. (두번째 요소만 클래스 변경이 되지 않는다.)<br />
아래와 같은 방법으로 회피할 수 있다.<br />
<br />
1) 반복문을 역방향으로 돌린다.<br />

<pre class="mgtbD">
<code class="xmp">
const elems = document.getElementsByClassName('red');

for (let i = elems.length - 1; i >= 0; i--) {
  elems[i].className = 'blue';
}
</code>
</pre>

2) while 반복문을 사용한다.<br />

<pre class="mgtbD">
<code class="xmp">
const elems = document.getElementsByClassName('red');

let i = 0;
while (elems.length > i) { // elems에 요소가 남아 있지 않을 때까지 무한반복
  elems[i].className = 'blue';
  // i++;
}
</code>
</pre>

3) HTMLCollection을 배열로 변경한다. 이 방법을 권장한다.<br />

<pre class="mgtbD">
<code class="xmp">
const elems = document.getElementsByClassName('red');

// 유사 배열 객체인 HTMLCollection을 배열로 변환한다.
// 배열로 변환된 HTMLCollection은 더 이상 live하지 않다.
console.log([...elems]); // [li#one.red, li#two.red, li#three.red]

[...elems].forEach(elem => elem.className = 'blue');
</code>
</pre>

4) querySelectorAll 메소드를 사용하여 HTMLCollection(live)이 아닌 NodeList(non-live)를 반환하게 한다.<br />

<pre class="mgtbD">
<code class="xmp">
// querySelectorAll는 Nodelist(non-live)를 반환한다. IE8+
const elems = document.querySelectorAll('.red');

[...elems].forEach(elem => elem.className = 'blue');
</code>
</pre>

<br />

<div class="panel2">
document.<b class="em9">getElementsByTagName</b>(tagName)
</div>

태그명으로 요소 노드를 모두 선택한다.<br />
Return: HTMLCollection (live)<br />
모든 브라우저에서 동작<br />

<div class="panel2">
document.<b class="em9">querySelectorAll</b>(selector)
</div>

지정된 CSS 선택자를 사용하여 요소 노드를 모두 선택한다.<br />
Return: NodeList (non-live)<br />
IE8 이상의 브라우저에서 동작<br />




<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">3.3 DOM Traversing (탐색)</h5>

<table class="t3 w100 ttpdtb1em tdpdlr2pct thcv0 lhD ttvat ttwa-small-only">
	<caption>
		<strong class="h1 blind">DOM Traversing</strong>
		<span class="summary1 blind">: Property, Method, Note, Return, Comptable</span>
	</caption>
	<col style="width:10em;" /><col />
	<thead>
	<tr>
	<th scope="col">Property, Method</th>
	<th scope="col">Comptable</th>
	<th scope="col">Note</th>
	<th scope="col">Return</th>
	</tr>
	</thead>
	<tbody class="ttbgcf">
	<tr>
	<th scope="row">parentNode</th>
	<td>All</td>
	<td>부모 노드를 탐색</td>
	<td>HTMLElement를 상속받은 객체</td>
	</tr>
	<tr>
	<th scope="row">firstChild, lastChild</th>
	<td>IE9+</td>
	<td>자식 노드를 탐색<br />
		<blockquote cite=""><div>
			예제를 실행해 보면 예상대로 동작하지 않는다.<br />
			IE를 제외한 대부분의 브라우저들은 요소 사이의 공백 또는 줄바꿈 문자를 텍스트 노드로 취급하기 때문이다.<br />
			이것을 회피하기 위해서는 HTML 사이의 공백을 제거하거나<br />
			jQuery 의 .prev()와 .next()를 사용한다.<br />
			또는 <span lang="ls0"><b class="em9">firstElementChild</b>, <b class="em9">lastElementChild</b></span>를 사용할 수도 있다.<br />
			이 두가지 프로퍼티는 모든 IE9 이상에서 정상 동작한다.<br />
		</div></blockquote>
	</td>
	<td>HTMLElement를 상속받은 객체</td>
	</tr>
	<tr>
	<th scope="row">hasChildNodes()</th>
	<td>All</td>
	<td>자식 노드가 있는지 확인하고 Boolean 값을 반환한다.</td>
	<td>Boolean 값</td>
	</tr>
	<tr>
	<th scope="row">childNodes</th>
	<td>All</td>
	<td>자식 노드의 컬렉션을 반환한다. 텍스트 요소를 포함한 모든 자식 요소를 반환한다.</td>
	<td>NodeList (non-live)</td>
	</tr>
	<tr>
	<th scope="row">children</th>
	<td>IE9+</td>
	<td>자식 노드의 컬렉션을 반환한다. 자식 요소 중에서 Element type 요소만을 반환한다.</td>
	<td>HTMLCollection (live)</td>
	</tr>
	<tr>
	<th scope="row">previousSibling, nextSibling</th>
	<td>All</td>
	<td>형제 노드를 탐색한다. text node를 포함한 모든 형제 노드를 탐색한다.</td>
	<td>HTMLElement를 상속받은 객체</td>
	</tr>
	<tr>
	<th scope="row">previousElementSibling, nextElementSibling</th>
	<td>IE9+</td>
	<td>형제 노드를 탐색한다. 형제 노드 중에서 Element type 요소만을 탐색한다.</td>
	<td>HTMLElement를 상속받은 객체</td>
	</tr>
	</tbody>
</table>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">4. DOM Manipulation (조작)</h4>

<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">4.1 텍스트 노드에의 접근/수정</h5>


<div class="panel2">
<b class="em9">nodeValue</b>
</div>

노드의 값을 반환한다.<br />
Return: 텍스트 노드의 경우는 문자열, 요소 노드의 경우 null 반환<br />
IE6 이상의 브라우저에서 동작한다.<br />

<p>요소의 텍스트는 텍스트 노드에 저장되어 있다. 텍스트 노드에 접근하려면 아래와 같은 수순이 필요하다.</p>

<ol class="bo">
<li>해당 텍스트 노드의 부모 노드를 선택한다. 텍스트 노드는 요소 노드의 자식이다.</li>
<li>firstChild 프로퍼티를 사용하여 텍스트 노드를 탐색한다.</li>
<li>텍스트 노드의 유일한 프로퍼티(nodeValue)를 이용하여 텍스트를 취득한다.</li>
<li>nodeValue를 이용하여 텍스트를 수정한다.</li>
</ol>

<p>nodeName, nodeType을 통해 노드의 정보를 취득할 수 있다.</p>

<pre class="mgtbD">
<code class="xmp">
// 해당 텍스트 노드의 부모 요소 노드를 선택한다.
const one = document.getElementById('one');
console.dir(one); // HTMLLIElement: li#one.red

// nodeName, nodeType을 통해 노드의 정보를 취득할 수 있다.
console.log(one.nodeName); // LI
console.log(one.nodeType); // 1: Element node

// firstChild 프로퍼티를 사용하여 텍스트 노드를 탐색한다.
const textNode = one.firstChild;

// nodeName, nodeType을 통해 노드의 정보를 취득할 수 있다.
console.log(textNode.nodeName); // #text
console.log(textNode.nodeType); // 3: Text node

// nodeValue 프로퍼티를 사용하여 노드의 값을 취득한다.
console.log(textNode.nodeValue); // Seoul

// nodeValue 프로퍼티를 이용하여 텍스트를 수정한다.
textNode.nodeValue = 'Pusan';
</code>
</pre>


<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">4.2 어트리뷰트 노드에의 접근/수정</h5>

<table class="t3 w100 ttpdtb1em tdpdlr2pct thcv0 lhD ttvat ttwa-small-only">
	<caption>
		<strong class="h1 blind">어트리뷰트 노드에의 접근/수정</strong>
		<span class="summary1 blind">: Property, Method, Note, Return, Comptable</span>
	</caption>
	<thead>
	<tr>
	<th scope="col">Property, Method</th>
	<th scope="col">Comptable</th>
	<th scope="col">Note</th>
	<th scope="col">Return</th>
	</tr>
	</thead>
	<tbody class="ttbgcf">
	<tr>
	<th scope="row">className</th>
	<td>All</td>
	<td>
		class 어트리뷰트의 값을 취득 또는 변경한다.<br />
		className 프로퍼티에 값을 할당하는 경우,<br /> class 어트리뷰트가 존재하지 않으면 class 어트리뷰트를 생성하고 지정된 값을 설정한다.<br />
		class 어트리뷰트의 값이 여러 개일 경우,<br /> 공백으로 구분된 문자열이 반환되므로 String 메소드 split(' ')를 사용하여 배열로 변경하여 사용한다.<br />
	</td>
	<td></td>
	</tr>
	<tr>
	<th scope="row">classList</th>
	<td>IE10+</td>
	<td>add, remove, item, toggle, contains, replace 메소드를 제공한다.</td>
	<td></td>
	</tr>
	<tr>
	<th scope="row">id</th>
	<td>All</td>
	<td>
		id 어트리뷰트의 값을 취득 또는 변경한다.
		id 프로퍼티에 값을 할당하는 경우,<br /> id 어트리뷰트가 존재하지 않으면 id 어트리뷰트를 생성하고 지정된 값을 설정한다.<br />
	</td>
	<td></td>
	</tr>
	<tr>
	<th scope="row">hasAttribute(attribute)</th>
	<td>IE8+</td>
	<td>지정한 어트리뷰트를 가지고 있는지 검사</td>
	<td>Boolean</td>
	</tr>
	<tr>
	<th scope="row">getAttribute(attribute)</th>
	<td>All</td>
	<td>어트리뷰트의 값을 취득</td>
	<td>문자열</td>
	</tr>
	<tr>
	<th scope="row">setAttribute(attribute, value)</th>
	<td>All</td>
	<td>어트리뷰트와 어트리뷰트 값을 설정</td>
	<td>undefined</td>
	</tr>
	<tr>
	<th scope="row">removeAttribute(attribute)</th>
	<td>All</td>
	<td>지정한 어트리뷰트를 제거</td>
	<td>undefined</td>
	</tr>
	<tr>
	<th scope="row">@@@</th>
	<td></td>
	<td></td>
	<td></td>
	</tr>
	</tbody>
</table>

<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">4.3 HTML 콘텐츠 조작(Manipulation)</h5>

HTML 콘텐츠를 조작(Manipulation)하기 위해 아래의 프로퍼티 또는 메소드를 사용할 수 있다.<br />
마크업이 포함된 콘텐츠를 추가하는 행위는 <em class="em">크로스 스크립팅 공격(XSS: Cross-Site Scripting Attacks)</em>에 취약하므로 주의가 필요하다.<br />

<table class="t3 w100 ttpdtb1em tdpdlr2pct thcv0 lhD ttvat ttwa-small-only">
	<caption>
		<strong class="h1 blind">HTML 콘텐츠 조작(Manipulation)</strong>
		<span class="summary1 blind">: Property, Method, Note, Return, Comptable</span>
	</caption>
	<thead>
	<tr>
	<th scope="col">Property, Method</th>
	<th scope="col">Comptable</th>
	<th scope="col">Note</th>
	<th scope="col">Return</th>
	</tr>
	</thead>
	<tbody class="ttbgcf">
	<tr>
	<th scope="row">textContent</th>
	<td>IE9+</td>
	<td>
		요소의 텍스트 콘텐츠를 취득 또는 변경한다.<br />
		이때 마크업은 무시된다.<br />
		textContent를 통해 요소에 새로운 텍스트를 할당하면 텍스트를 변경할 수 있다.<br />
		이때 순수한 텍스트만 지정해야 하며 마크업을 포함시키면 문자열로 인식되어 그대로 출력된다.<br />
	</td>
	<td></td>
	</tr>
	<tr>
	<th scope="row">innerText</th>
	<td></td>
	<td>
		innerText 프로퍼티를 사용하여도 요소의 텍스트 콘텐츠에만 접근할 수 있다.<br />
		하지만 아래의 이유로 사용하지 않는 것이 좋다.<br />
		<ul class="bu">
		<li>비표준이다.</li>
		<li>CSS에 순종적이다. 예를 들어 CSS에 의해 비표시(visibility: hidden;)로 지정되어 있다면 텍스트가 반환되지 않는다.</li>
		<li>CSS를 고려해야 하므로 textContent 프로퍼티보다 느리다</li>
		</ul>
	</td>
	<td></td>
	</tr>
	<tr>
	<th scope="row">innerHTML</th>
	<td></td>
	<td>
		해당 요소의 모든 자식 요소를 포함하는 모든 콘텐츠를 하나의 문자열로 취득할 수 있다.<br />
		이 문자열은 마크업을 포함한다.<br />
	</td>
	<td></td>
	</tr>
	<tr>
	<th scope="row">@@@</th>
	<td></td>
	<td></td>
	<td></td>
	</tr>
	</tbody>
</table>

<p>innerHTML 프로퍼티를 사용하여 마크업이 포함된 새로운 콘텐츠를 지정하면 새로운 요소를 DOM에 추가할 수 있다.</p>

<xmp class="xmp">
const one = document.getElementById('one');

// 마크업이 포함된 콘텐츠 취득
console.log(one.innerHTML); // Seoul

// 마크업이 포함된 콘텐츠 변경
one.innerHTML += '<em class="blue">, Korea</em>';

// 마크업이 포함된 콘텐츠 취득
console.log(one.innerHTML); // Seoul <em class="blue">, Korea</em>
</xmp>

<p>위와 같이 마크업이 포함된 콘텐츠를 추가하는 것은 크로스 스크립팅 공격(XSS: Cross-Site Scripting Attacks)에 취약하다.</p>

<xmp class="xmp">
// 크로스 스크립팅 공격 사례

// 스크립트 태그를 추가하여 자바스크립트가 실행되도록 한다.
// HTML5에서 innerHTML로 삽입된 <script> 코드는 실행되지 않는다.
// 크롬, 파이어폭스 등의 브라우저나 최신 브라우저 환경에서는 작동하지 않을 수도 있다.
elem.innerHTML = '<script>alert("XSS!")</script>';

// 에러 이벤트를 발생시켜 스크립트가 실행되도록 한다.
// 크롬에서도 실행된다!
elem.innerHTML = '<img src="#" onerror="alert(\'XSS\')">';
</xmp>


<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">4.4 DOM 조작 방식</h5>

<table class="t3 w100 ttpdtb1em tdpdlr2pct thcv0 lhD ttvat ttwa-small-only">
	<caption>
		<strong class="h1 blind">DOM 조작 방식</strong>
		<span class="summary1 blind">: Property, Method, Note, Return, Comptable</span>
	</caption>
	<thead>
	<tr>
	<th scope="col">Property, Method</th>
	<th scope="col">Comptable</th>
	<th scope="col">Note</th>
	<th scope="col">Return</th>
	</tr>
	</thead>
	<tbody class="ttbgcf">
	<tr>
	<th scope="row">createElement(tagName)</th>
	<td>All</td>
	<td>태그이름을 인자로 전달하여 요소를 생성</td>
	<td>HTMLElement를 상속받은 객체</td>
	</tr>
	<tr>
	<th scope="row">createTextNode(text)</th>
	<td>All</td>
	<td>텍스트를 인자로 전달하여 텍스트 노드를 생성</td>
	<td>Text 객체</td>
	</tr>
	<tr>
	<th scope="row">appendChild(Node)</th>
	<td>All</td>
	<td>인자로 전달한 노드를 마지막 자식 요소로 DOM 트리에 추가</td>
	<td>추가한 노드</td>
	</tr>
	<tr>
	<th scope="row">removeChild(Node)</th>
	<td>All</td>
	<td>인자로 전달한 노드를 DOM 트리에 제거</td>
	<td>추가한 노드</td>
	</tr>
	<tr>
	<th scope="row">@@@</th>
	<td></td>
	<td></td>
	<td></td>
	</tr>
	</tbody>
</table>


<xmp class="xmp">
// 태그이름을 인자로 전달하여 요소를 생성
const newElem = document.createElement('li');
// const newElem = document.createElement('<li>test</li>');
// Uncaught DOMException: Failed to execute 'createElement' on 'Document': The tag name provided ('<li>test</li>') is not a valid name.

// 텍스트 노드를 생성
const newText = document.createTextNode('Beijing');

// 텍스트 노드를 newElem 자식으로 DOM 트리에 추가
newElem.appendChild(newText);

const container = document.querySelector('ul');

// newElem을 container의 자식으로 DOM 트리에 추가. 마지막 요소로 추가된다.
container.appendChild(newElem);

const removeElem = document.getElementById('one');

// container의 자식인 removeElem 요소를 DOM 트리에 제거한다.
container.removeChild(removeElem);
</xmp>


<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">4.5 insertAdjacentHTML()</h5>


<div class="panel1">
<b class="em9">insertAdjacentHTML(position, string)</b>
</div>

인자로 전달한 텍스트를 HTML로 파싱하고 그 결과로 생성된 노드를 DOM 트리의 지정된 위치에 삽입한다.<br />
첫번째 인자는 삽입 위치, 두번째 인자는 삽입할 요소를 표현한 문자열이다.<br />
모든 브라우저에서 동작한다.<br />
첫번째 인자로 올 수 있는 값은 아래와 같다.<br />
<br />
‘beforebegin’ ‘afterbegin’ ‘beforeend’ ‘afterend’<br />
<br />
<figure class="box1 mg0 pd10px tac">
	<img src="https://poiemaweb.com/img/insertAdjacentHTML-position.png" alt="insertAdjacentHTML-position">
	<figcaption>insertAdjacentHTML 메소드의 position 파라미터</figcaption>
</figure>

<br />

<xmp class="xmp">
const one = document.getElementById('one');

// 마크업이 포함된 요소 추가
one.insertAdjacentHTML('beforeend', '<em class="blue">, Korea</em>');
</xmp>


<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">4.6 innerHTML vs. DOM 조작 방식 vs. insertAdjacentHTML()</h5>


<table class="t3 w100 ttpdtb1em tdpdlr2pct thcv0 lhD ttvat ttwa-small-only">
	<caption>
		<strong class="h1 blind">innerHTML vs. DOM 조작 방식 vs. insertAdjacentHTML()</strong>
	</caption>
	<thead>
	<tr>
	<th scope="col">Property, Method</th>
	<th scope="col">장점</th>
	<th scope="col">단점</th>
	</tr>
	</thead>
	<tbody class="ttbgcf">
	<tr>
	<th scope="row">innerHTML</th>
	<td>
		DOM 조작 방식에 비해 빠르고 간편하다.<br />
		간편하게 문자열로 정의한 여러 요소를 DOM에 추가할 수 있다.<br />
		콘텐츠를 취득할 수 있다.<br />
	</td>
	<td>
		XSS공격에 취약점이 있기 때문에 사용자로 부터 입력받은<br /> 콘텐츠(untrusted data: 댓글, 사용자 이름 등)를 추가할 때 주의하여야 한다.<br />
		해당 요소의 내용을 덮어 쓴다. 즉, HTML을 다시 파싱한다. 이것은 비효율적이다.<br />
	</td>
	</tr>
	<tr>
	<th scope="row">DOM 조작 방식</th>
	<td>
		특정 노드 한 개(노드, 텍스트, 데이터 등)를 DOM에 추가할 때 적합하다.<br />
	</td>
	<td>
		innerHTML보다 느리고 더 많은 코드가 필요하다.<br />
	</td>
	</tr>
	<tr>
	<th scope="row">insertAdjacentHTML()</th>
	<td>
		간편하게 문자열로 정의된 여러 요소를 DOM에 추가할 수 있다.<br />
		삽입되는 위치를 선정할 수 있다.<br />
	</td>
	<td>
		XSS공격에 취약점이 있기 때문에 사용자로 부터 입력받은<br /> 콘텐츠(untrusted data: 댓글, 사용자 이름 등)를 추가할 때 주의하여야 한다.<br />
	</td>
	</tr>
	<tr>
	<th scope="row">@@@</th>
	<td></td>
	<td></td>
	</tr>
	</tbody>
</table>


<div class="panel1">
	결론 :<br />
	innerHTML과 insertAdjacentHTML()은 크로스 스크립팅 공격(XSS: Cross-Site Scripting Attacks)에 취약하다.<br />
	따라서 untrusted data의 경우, 주의하여야 한다.<br />
	텍스트를 추가 또는 변경시에는 <em class="em">textContent</em>,
	새로운 요소의 추가 또는 삭제시에는 <em class="em">DOM 조작 방식</em>을 사용하도록 한다.
</div>

<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">5. style</h4>

<p>
	<b class="em9">style</b> 프로퍼티를 사용하면 inline 스타일 선언을 생성한다. 특정 요소에 inline 스타일을 지정하는 경우 사용한다.
</p>

<pre class="mgtbD">
<code class="xmp">
const four = document.getElementById('four');

// inline 스타일 선언을 생성
four.style.color = 'blue';

// font-size와 같이 '-'으로 구분되는 프로퍼티는 카멜케이스로 변환하여 사용한다.
four.style.fontSize = '2em';
</code>
</pre>

<p>
	style 프로퍼티의 값을 취득하려면 window.getComputedStyle을 사용한다.<br />
	<b class="em9">window.getComputedStyle</b> 메소드는 인자로 주어진 요소의 모든 CSS 프로퍼티 값을 반환한다.
</p>

<xmp class="xmp">
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>style 프로퍼티 값 취득</title>
  <style>
    .box {
      width: 100px;
      height: 50px;
      background-color: red;
      border: 1px solid black;
    }
  </style>
</head>
<body>
  <div class="box"></div>
  <script>
    const box = document.querySelector('.box');

    const width = getStyle(box, 'width');
    const height = getStyle(box, 'height');
    const backgroundColor = getStyle(box, 'background-color');
    const border = getStyle(box, 'border');

    console.log('width: ' + width);
    console.log('height: ' + height);
    console.log('backgroundColor: ' + backgroundColor);
    console.log('border: ' + border);

    /**
     * 요소에 적용된 CSS 프로퍼티를 반환한다.
     * @param {HTTPElement} elem - 대상 요소 노드.
     * @param {string} prop - 대상 CSS 프로퍼티.
     * @returns {string} CSS 프로퍼티의 값.
     */
    function getStyle(elem, prop) {
      return window.getComputedStyle(elem, null).getPropertyValue(prop);
    }
  </script>
</body>
</html>
</xmp>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-32">32 동기식 처리 모델 vs 비동기식 처리 모델</h3>


<p>
	동기식 처리 모델(Synchronous processing model)은 직렬적으로 태스크(task)를 수행한다.<br />
	즉, 태스크는 순차적으로 실행되며 어떤 작업이 수행 중이면 다음 작업은 대기하게 된다.<br />
</p>
<p>
	예를 들어 서버에서 데이터를 가져와서 화면에 표시하는 작업을 수행할 때,<br />
	서버에 데이터를 요청하고 데이터가 응답될 때까지 이후 태스크들은 블로킹(blocking, 작업 중단)된다.<br />
</p>

<p>
	비동기식 처리 모델(Asynchronous processing model 또는 Non-Blocking processing model)은 병렬적으로 태스크를 수행한다.<br />
	즉, 태스크가 종료되지 않은 상태라 하더라도 대기하지 않고 다음 태스크를 실행한다.<br />
	예를 들어 서버에서 데이터를 가져와서 화면에 표시하는 태스크를 수행할 때,<br />
	서버에 데이터를 요청한 이후 서버로부터 데이터가 응답될 때까지 대기하지 않고(Non-Blocking) 즉시 다음 태스크를 수행한다.<br />
	이후 서버로부터 데이터가 응답되면 이벤트가 발생하고 이벤트 핸들러가 데이터를 가지고 수행할 태스크를 계속해 수행한다.
</p>

<p>
	자바스크립트의 대부분의 DOM 이벤트 핸들러와 Timer 함수(setTimeout, setInterval), Ajax 요청은 비동기식 처리 모델로 동작한다.
</p>

<p>
	아래는 비동기식으로 동작하는 코드이다. 순차적으로 실행되지 않는다.
</p>

<pre class="mgtbD">
<code class="xmp">
function func1() {
  console.log('func1');
  func2();
}

function func2() {
  setTimeout(function() {
    console.log('func2');
  }, 0);

  func3();
}

function func3() {
  console.log('func3');
}

func1();
</code>
</pre>

<p>
	위 예제를 실행하면 setTimeout 메소드에 두번째 인수 인터벌을 0초로 설정하여도 콘솔에 “func1 func2 func3”의 순서로 로그가 출력되지 않는다.
	이는 setTimeout 메소드가 비동기 함수이기 때문이다.
</p>
<p>
	함수 func1이 호출되면 함수 func1은 Call Stack에 쌓인다.<br />
	그리고 함수 func1은 함수 func2을 호출하므로 함수 func2가 Call Stack에 쌓이고 setTimeout가 호출된다.<br />
	setTimeout의 콜백함수는 즉시 실행되지 않고 지정 대기 시간만큼 기다리다가
	“tick” 이벤트가 발생하면 태스크 큐로 이동한 후 Call Stack이 비어졌을 때 Call Stack으로 이동되어 실행된다.<br />
</p>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-33">33 이벤트</h3>


<pre>
1. Introduction
2. 이벤트 루프(Event Loop)와 동시성(Concurrency)
3. 이벤트의 종류
	3.1 UI Event
	3.2 Keyboard Event
	3.3 Mouse Event
	3.4 Focus Event
	3.5 Form Event
	3.6 Clipboard Event
4. 이벤트 핸들러 등록
	4.1 인라인 이벤트 핸들러 방식
	4.2 이벤트 핸들러 프로퍼티 방식
	4.3 addEventListener 메소드 방식
5. 이벤트 핸들러 함수 내부의 this
	5.1 인라인 이벤트 핸들러 방식
	5.2 이벤트 핸들러 프로퍼티 방식
	5.3 addEventListener 메소드 방식
6. 이벤트의 흐름
7. Event 객체
	7.1 Event Property
		7.1.1 Event.target
		7.1.2 Event.currentTarget
		7.1.3 Event.type
		7.1.4 Event.cancelable
		7.1.5 Event.eventPhase
8. Event Delegation (이벤트 위임)
9. 기본 동작의 변경
	9.1 Event.preventDefault()
	9.2 Event.stopPropagation()
	9.3 preventDefault & stopPropagation
Reference
</pre>

<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">1. Introduction</h4>

이벤트<br />
이벤트 핸들러<br />

<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">2. 이벤트 루프(Event Loop)와 동시성(Concurrency)</h4>

<p>
	브라우저는 단일 쓰레드(single-thread)에서 이벤트 드리븐(event-driven) 방식으로 동작한다.
</p>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">3. 이벤트의 종류</h4>
<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">3.1 UI Event</h5>

<table class="t3 w100 ttpdtb1em tdpdlr2pct thcv0 lhD tttac tt2tal ttvam ttwa-small-only">
	<col style="width:10em;" /><col />
  <thead>
    <tr>
      <th>Event</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>load</strong></td>
      <td>웹페이지의 로드가 완료되었을 때</td>
    </tr>
    <tr>
      <td>unload</td>
      <td>웹페이지가 언로드될 때(주로 새로운 페이지를 요청한 경우)</td>
    </tr>
    <tr>
      <td>error</td>
      <td>브라우저가 자바스크립트 오류를 만났거나 요청한 자원이 존재하지 않는 경우</td>
    </tr>
    <tr>
      <td>resize</td>
      <td>브라우저 창의 크기를 조절했을 때</td>
    </tr>
    <tr>
      <td>scroll</td>
      <td>사용자가 페이지를 위아래로 스크롤할 때</td>
    </tr>
    <tr>
      <td>select</td>
      <td>텍스트를 선택했을 때</td>
    </tr>
  </tbody>
</table>

<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">3.2 Keyboard Event</h5>

<table class="t3 w100 ttpdtb1em tdpdlr2pct thcv0 lhD tttac tt2tal ttvam ttwa-small-only">
	<col style="width:10em;" /><col />
  <thead>
    <tr>
      <th>Event</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>keydown</td>
      <td>키를 누르고 있을 때</td>
    </tr>
    <tr>
      <td><strong>keyup</strong></td>
      <td>누르고 있던 키를 뗄 때</td>
    </tr>
    <tr>
      <td>keypress</td>
      <td>키를 누르고 뗏을 때</td>
    </tr>
  </tbody>
</table>

<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">3.3 Mouse Event</h5>

<table class="t3 w100 ttpdtb1em tdpdlr2pct thcv0 lhD tttac tt2tal ttvam ttwa-small-only">
	<col style="width:10em;" /><col />
  <thead>
    <tr>
      <th>Event</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>click</strong></td>
      <td>마우스 버튼을 클릭했을 때</td>
    </tr>
    <tr>
      <td>dbclick</td>
      <td>마우스 버튼을 더블 클릭했을 때</td>
    </tr>
    <tr>
      <td>mousedown</td>
      <td>마우스 버튼을 누르고 있을 때</td>
    </tr>
    <tr>
      <td>mouseup</td>
      <td>누르고 있던 마우스 버튼을 뗄 때</td>
    </tr>
    <tr>
      <td>mousemove</td>
      <td>마우스를 움직일 때 (터치스크린에서 동작하지 않는다)</td>
    </tr>
    <tr>
      <td>mouseover</td>
      <td>마우스를 요소 위로 움직였을 때 (터치스크린에서 동작하지 않는다)</td>
    </tr>
    <tr>
      <td>mouseout</td>
      <td>마우스를 요소 밖으로 움직였을 때 (터치스크린에서 동작하지 않는다)</td>
    </tr>
  </tbody>
</table>

<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">3.4 Focus Event</h5>

<table class="t3 w100 ttpdtb1em tdpdlr2pct thcv0 lhD tttac tt2tal ttvam ttwa-small-only">
	<col style="width:10em;" /><col />
  <thead>
    <tr>
      <th>Event</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>focus</strong>/focusin</td>
      <td>요소가 포커스를 얻었을 때</td>
    </tr>
    <tr>
      <td><strong>blur</strong>/foucusout</td>
      <td>요소가 포커스를 잃었을 때</td>
    </tr>
  </tbody>
</table>

<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">3.5 Form Event</h5>

<table class="t3 w100 ttpdtb1em tdpdlr2pct thcv0 lhD tttac tt2tal ttvam ttwa-small-only">
	<col style="width:10em;" /><col />
  <thead>
    <tr>
      <th>Event</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>input</strong></td>
      <td>input 또는 textarea 요소의 값이 변경되었을 때</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td>contenteditable 어트리뷰트를 가진 요소의 값이 변경되었을 때</td>
    </tr>
    <tr>
      <td><strong>change</strong></td>
      <td>select box, checkbox, radio button의 상태가 변경되었을 때</td>
    </tr>
    <tr>
      <td>submit</td>
      <td>form을 submit할 때 (버튼 또는 키)</td>
    </tr>
    <tr>
      <td>reset</td>
      <td>reset 버튼을 클릭할 때 (최근에는 사용 안함)</td>
    </tr>
  </tbody>
</table>

<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">3.6 Clipboard Event</h5>

<table class="t3 w100 ttpdtb1em tdpdlr2pct thcv0 lhD tttac tt2tal ttvam ttwa-small-only">
	<col style="width:10em;" /><col />
  <thead>
    <tr>
      <th>Event</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>cut</td>
      <td>콘텐츠를 잘라내기할 때</td>
    </tr>
    <tr>
      <td>copy</td>
      <td>콘텐츠를 복사할 때</td>
    </tr>
    <tr>
      <td>paste</td>
      <td>콘텐츠를 붙여넣기할 때</td>
    </tr>
  </tbody>
</table>

<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">4. 이벤트 핸들러 등록</h4>
<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">4.1 인라인 이벤트 핸들러 방식</h5>

<xmp class="xmp">
<button onclick="myHandler()">Click me</button>
</xmp>

<p>
	이 방식은 더 이상 사용되지 않으며 사용해서도 않된다.
	오래된 코드에서 간혹 이 방식을 사용한 것이 있기 때문에 알아둘 필요는 있다.
	HTML과 Javascript는 관심사가 다르므로 분리하는 것이 좋다.
</p>

<p class="pd1em-rv bg-info">
	최근 관심을 받고 있는 CBD(Component Based Development) 방식의 Angular/React/Vue.js와 같은 프레임워크/라이브러리에서는
	인라인 이벤트 핸들러 방식으로 이벤트를 처리한다.
	CBD에서는 HTML, CSS, 자바스크립트를 뷰를 구성하기 위한 구성 요소로 보기 때문에 관심사가 다르다고 생각하지 않는다.
</p>


<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">4.2 이벤트 핸들러 프로퍼티 방식</h5>


<p>
	인라인 이벤트 핸들러 방식처럼 HTML과 Javascript가 뒤섞이는 문제는 해결할 수 있는 방식이다.
	하지만 이벤트 핸들러 프로퍼티에 하나의 이벤트 핸들러만을 바인딩할 수 있다는 단점이 있다.
</p>

<xmp class="xmp">
<!DOCTYPE html>
<html>
<body>
  <button class="btn">Click me</button>
  <script>
    const btn = document.querySelector('.btn');

    // 이벤트 핸들러 프로퍼티 방식은 이벤트에 하나의 이벤트 핸들러만을 바인딩할 수 있다
    // 첫번째 바인딩된 이벤트 핸들러 => 실행되지 않는다.
    btn.onclick = function () {
      alert('① Button clicked 1');
    };

    // 두번째 바인딩된 이벤트 핸들러
    btn.onclick = function () {
      alert('① Button clicked 2');
    };

    // addEventListener 메소드 방식
    // 첫번째 바인딩된 이벤트 핸들러
    btn.addEventListener('click', function () {
      alert('② Button clicked 1');
    });

    // 두번째 바인딩된 이벤트 핸들러
    btn.addEventListener('click', function () {
      alert('② Button clicked 2');
    });
  </script>
</body>
</html>
</xmp>


<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">4.3 addEventListener 메소드 방식</h5>

<figure class="box1 mg0 pd10px tac">
	<img src="https://poiemaweb.com/img/event_listener.png" alt="★대체텍스트필수" />
	<figcaption>addEventListener 메소드</figcaption>
</figure>

<p>
	addEventListener 함수 방식은 이전 방식에 비해 아래와 같이 보다 나은 장점을 갖는다.
</p>

<ul class="bu">
<li>하나의 이벤트에 대해 하나 이상의 이벤트 핸들러를 추가할 수 있다.<br /></li>
<li>캡처링과 버블링을 지원한다.<br /></li>
<li>HTML 요소뿐만아니라 모든 DOM 요소(HTML, XML, SVG)에 대해 동작한다. 브라우저는 웹 문서(HTML, XML, SVG)를 로드한 후, 파싱하여 DOM을 생성한다.<br /></li>
</ul>

<p>
	<b class="em9">addEventListener</b> 메소드는 IE 9 이상에서 동작한다. IE 8 이하에서는 <b class="em8">attachEvent</b> 메소드를 사용한다.
</p>

<pre class="mgtbD">
<code class="xmp">
if (elem.addEventListener) {    // IE 9 ~
  elem.addEventListener('click', func);
} else if (elem.attachEvent) {  // ~ IE 8
  elem.attachEvent('onclick', func);
}
</code>
</pre>

<p>
	addEventListener 메소드의 사용 예제를 살펴보자.
</p>

<xmp class="xmp">
<!DOCTYPE html>
<html>
<body>
  <script>
    addEventListener('click', function () {
      alert('Clicked!');
    });
  </script>
</body>
</html>
</xmp>

<p>
	위와 같이 대상 DOM 요소(target)를 지정하지 않으면 전역객체 window, 즉 DOM 문서를 포함한 브라우저의 윈도우에서 발생하는 click 벤트에 이벤트 핸들러를 바인딩한다.<br />
	따라서 브라우저 윈도우 어디를 클릭하여도 이벤트 핸들러가 동작한다.<br />
</p>

<xmp class="xmp">
<!DOCTYPE html>
<html>
<body>
  <label>User name <input type='text'></label>

  <script>
    const input = document.querySelector('input[type=text]');

    input.addEventListener('blur', function () {
      alert('blur event occurred!');
    });
  </script>
</body>
</html>
</xmp>

<p>
	위 예제는 input 요소에서 발생하는 blur 이벤트에 이벤트 핸들러를 바인딩하였다.<br />
	사용자 이름이 최소 2자 이상이야한다는 규칙을 세우고 이에 부합하는지 확인해보자.<br />
</p>

<xmp class="xmp">
<!DOCTYPE html>
<html>
<body>
  <label>User name <input type='text'></label>
  <em class="message"></em>

  <script>
    const input = document.querySelector('input[type=text]');
    const msg = document.querySelector('.message');

    input.addEventListener('blur', function () {
      if (input.value.length < 2) {
        msg.innerHTML = '이름은 2자 이상 입력해 주세요';
      } else {
        msg.innerHTML = '';
      }
    });
  </script>
</body>
</html>
</xmp>

<p>
	2자 이상이라는 규칙이 바뀌면 이 규칙을 확인하는 모든 코드를 수정해야 한다.<br />
	따라서 이러한 방식의 코딩은 바람직하지 않다.<br />
	이유는 규모가 큰 프로그램의 경우 수정과 테스트에 소요되는 자원의 낭비도 문제이지만 수정에는 거의 대부분 실수가 동반되기 때문이다.<br />
</p>
<p>
	2자 이상이라는 규칙을 상수화하고 함수의 인수로 전달도록 수정하자.<br />
	이렇게 하면 규칙이 변경되어도 함수는 수정하지 않아도 된다.<br />
</p>
<p>
	그런데 addEventListener 메소드의 두번째 매개변수는 이벤트가 발생했을 때 호출될 이벤트 핸들러이다.<br />
	<em class="em">이때 두번째 매개변수에는 함수 호출이 아니라 함수 자체를 지정하여야 한다.</em><br />
</p>

<pre class="mgtbD">
<code class="xmp">
function foo() {
  alert('clicked!');
}
// elem.addEventListener('click', foo()); // 이벤트 발생 시까지 대기하지 않고 바로 실행된다
elem.addEventListener('click', foo);      // 이벤트 발생 시까지 대기한다
</code>
</pre>

<p>
	따라서 이벤트 핸들러 프로퍼티 방식과 같이 이벤트 핸들러 함수에 인수를 전달할 수 없는 문제가 발생한다.<br />
	이를 우회하는 방법은 아래와 같다.<br />
</p>

<xmp class="xmp">
<!DOCTYPE html>
<html>
<body>
  <label>User name <input type='text'></label>
  <em class="message"></em>

  <script>
    const MIN_USER_NAME_LENGTH = 2; // 이름 최소 길이

    const input = document.querySelector('input[type=text]');
    const msg = document.querySelector('.message');

    function checkUserNameLength(n) {
      if (input.value.length < n) {
        msg.innerHTML = '이름은 ' + n + '자 이상이어야 합니다';
      } else {
        msg.innerHTML = '';
      }
    }

    input.addEventListener('blur', function () {
      // 이벤트 핸들러 내부에서 함수를 호출하면서 인수를 전달한다.
      checkUserNameLength(MIN_USER_NAME_LENGTH);
    });

    // 이벤트 핸들러 프로퍼티 방식도 동일한 방식으로 인수를 전달할 수 있다.
    // input.onblur = function () {
    //   // 이벤트 핸들러 내부에서 함수를 호출하면서 인수를 전달한다.
    //   checkUserNameLength(MIN_USER_NAME_LENGTH);
    // };
  </script>
</body>
</html>
</xmp>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">5. 이벤트 핸들러 함수 내부의 this</h4>
<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">5.1 인라인 이벤트 핸들러 방식</h5>

<p>
	<b class="em2">this는 전역 객체 window</b>
</p>

<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">5.2 이벤트 핸들러 프로퍼티 방식</h5>

<p>
	<b class="em2">this는 이벤트에 바인딩된 요소</b>
</p>

<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">5.3 addEventListener 메소드 방식</h5>

<p>
	<b class="em2">this는 이벤트 리스너에 바인딩된 요소(currentTarget)</b>
</p>

<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">6. 이벤트의 흐름</h4>

<p>
	<em class="em0">주의할 것은 버블링과 캡처링은 둘 중에 하나만 발생하는 것이 아니라 캡처링부터 시작하여 버블링으로 종료한다는 것이다.</em><br />
	즉, 이벤트가 발생했을 때 캡처링과 버블링은 순차적으로 발생한다.<br />
	캡처링은 IE8 이하에서 지원되지 않는다.<br />
</p>
<p>
	addEventListener 메소드의 세번째 매개변수에 <em class="em">true를 설정하면 캡처링</em>으로 전파되는 이벤트를 캐치하고<br />
	<em class="em">false 또는 미설정하면 버블링</em>으로 전파되는 이벤트를 캐치한다<br />
</p>

<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">7. Event 객체</h4>

<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">7.1 Event Property</h5>

<!-- ◇◆ -->
<h6 class="hb1 h6">7.1.1 Event.target</h6>

<p>
	실제로 이벤트를 발생시킨 요소
</p>

<!-- ◇◆ -->
<h6 class="hb1 h6">7.1.2 Event.currentTarget</h6>

<p>
	이벤트에 바인딩된 DOM 요소를 가리킨다. 즉, addEventListener 앞에 기술된 객체를 가리킨다.
</p>
<p>
	addEventListener 메소드에서 지정한 이벤트 핸들러 내부의 this는 이벤트에 바인딩된 DOM 요소를 가리키며
	이것은 이벤트 객체의 currentTarget 프로퍼티와 같다.
	따라서 이벤트 핸들러 함수 내에서 currentTarget과 this는 언제나 일치한다.
</p>

<!-- ◇◆ -->
<h6 class="hb1 h6">7.1.3 Event.type</h6>

<p>
	발생한 이벤트의 종류를 나타내는 문자열을 반환한다.
</p>

<!-- ◇◆ -->
<h6 class="hb1 h6">7.1.4 Event.cancelable</h6>

<p>
	요소의 기본 동작을 취소시킬 수 있는지 여부(true/false)를 나타낸다.
</p>

<!-- ◇◆ -->
<h6 class="hb1 h6">7.1.5 Event.eventPhase</h6>

<p>
	이벤트 흐름(event flow) 상에서 어느 단계(event phase)에 있는지를 반환한다.
</p>

<table class="t3 waha ttpdtb1em ttpdlr2pct thcv0 lhD tttac tt2tal ttvam ttwa-small-only">
  <thead>
    <tr>
      <th>반환값</th>
      <th>의미</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>이벤트 없음</td>
    </tr>
    <tr>
      <td>1</td>
      <td>캡쳐링 단계</td>
    </tr>
    <tr>
      <td>2</td>
      <td>타깃</td>
    </tr>
    <tr>
      <td>3</td>
      <td>버블링 단계</td>
    </tr>
  </tbody>
</table>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">8. Event Delegation (이벤트 위임)</h4>

<p>
	우선 아래 예제를 살펴보자.
</p>

<xmp class="xmp">
<ul id="post-list">
  <li id="post-1">Item 1</li>
  <li id="post-2">Item 2</li>
  <li id="post-3">Item 3</li>
  <li id="post-4">Item 4</li>
  <li id="post-5">Item 5</li>
  <li id="post-6">Item 6</li>
</ul>
</xmp>

<p>
	모든 li 요소가 클릭 이벤트에 반응하는 처리를 구현하고 싶은 경우, li 요소에 이벤트 핸들러를 바인딩하면 총 6개의 이벤트 핸들러를 바인딩하여야 한다.
</p>
<p>
	만일 li 요소가 100개라면 100개의 이벤트 핸들러를 바인딩하여야 한다. 이는 실행 속도 저하의 원인이 될 뿐 아니라 코드 또한 매우 길어지며 작성 또한 불편하다.
</p>
<p>
	그리고 <b class="em0">동적으로 li 요소가 추가되는 경우, 아직 추가되지 않은 요소는 DOM에 존재하지 않으므로 이벤트 핸들러를 바인딩할 수 없다.</b>
	이러한 경우 이벤트 위임을 사용한다.
</p>
<p>
	이벤트 위임(Event Delegation)은 다수의 자식 요소에 각각 이벤트 핸들러를 바인딩하는 대신 하나의 부모 요소에 이벤트 핸들러를 바인딩하는 방법이다.
	위의 경우 6개의 자식 요소에 각각 이벤트 핸들러를 바인딩하는 것 대신 부모 요소(ul#post-list)에 이벤트 핸들러를 바인딩하는 것이다.
</p>
<p>
	또한 DOM 트리에 새로운 li 요소를 추가하더라도 이벤트 처리는 부모 요소인 ul 요소에 위임되었기 때문에
	새로운 요소에 이벤트를 핸들러를 다시 바인딩할 필요가 없다.
</p>
<p>
	이는 이벤트가 이벤트 흐름에 의해 이벤트를 발생시킨 요소의 부모 요소에도 영향(버블링)을 미치기 때문에 가능한 것이다.
</p>
<p>
	실제로 이벤트를 발생시킨 요소를 알아내기 위해서는 <code>Event.target</code>을 사용한다.
</p>

<xmp class="xmp">
<!DOCTYPE html>
<html>
<body>
  <ul class="post-list">
    <li id="post-1">Item 1</li>
    <li id="post-2">Item 2</li>
    <li id="post-3">Item 3</li>
    <li id="post-4">Item 4</li>
    <li id="post-5">Item 5</li>
    <li id="post-6">Item 6</li>
  </ul>
  <div class="msg">
  <script>
    const msg = document.querySelector('.msg');
    const list = document.querySelector('.post-list')

    list.addEventListener('click', function (e) {
      // 이벤트를 발생시킨 요소
      console.log('[target]: ' + e.target);
      // 이벤트를 발생시킨 요소의 nodeName
      console.log('[target.nodeName]: ' + e.target.nodeName);

      // li 요소 이외의 요소에서 발생한 이벤트는 대응하지 않는다.
      if (e.target && e.target.nodeName === 'LI') {
        msg.innerHTML = 'li#' + e.target.id + ' was clicked!';
      }
    });
  </script>
</body>
</html>
</xmp>



<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">9. 기본 동작의 변경</h4>

<p>
	이벤트 객체는 요소의 기본 동작과 요소의 부모 요소들이 이벤트에 대응하는 방법을 변경하기 위한 메소드는 가지고 있다.<br />
</p>

<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">9.1 Event.preventDefault()</h5>

<p>
	폼을 submit하거나 링크를 클릭하면 다른 페이지로 이동하게 된다.<br />
	이와 같이 요소가 가지고 있는 기본 동작을 중단시키기 위한 메소드가 <b class="em9">preventDefault()</b>이다.<br />
</p>

<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">9.2 Event.stopPropagation()</h5>

<p>
	어느 한 요소를 이용하여 이벤트를 처리한 후 이벤트가 부모 요소로 이벤트가 전파되는 것을 중단시키기 위한 메소드이다.<br />
	부모 요소에 동일한 이벤트에 대한 다른 핸들러가 지정되어 있을 경우 사용된다.<br />
</p>
<p>
	아래 코드를 보면, 부모 요소와 자식 요소에 모두 mousedown 이벤트에 대한 핸들러가 지정되어 있다.<br />
	하지만 부모 요소와 자식 요소의 이벤트를 각각 별도로 처리하기 위해 button 요소의 이벤트의 전파(버블링)를 중단시키기 위해서는 stopPropagation 메소드를 사용하여 이벤트 전파를 중단할 필요가 있다.<br />
</p>


<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">9.3 preventDefault & stopPropagation</h5>

<p>
	기본 동작의 중단과 버블링 또는 캡처링의 중단을 동시에 실시하는 방법은 아래와 같다.
</p>

<pre class="mgtbD">
<code class="xmp">
return false;
</code>
</pre>

<p>
	단 이 방법은 jQuery를 사용할 때와 아래와 같이 사용할 때만 적용된다.
</p>

<xmp class="xmp">
<!DOCTYPE html>
<html>
<body>
  <a href="http://www.google.com" onclick='return handleEvent()'>go</a>
  <script>
  function handleEvent() {
    return false;
  }
  </script>
</body>
</html>
</xmp>

<xmp class="xmp">
<!DOCTYPE html>
<html>
<body>
  <div>
    <a href="http://www.google.com">go</a>
  </div>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.3/jquery.min.js"></script>
  <script>

  // within jQuery
  $('a').click(function (e) {
    e.preventDefault(); // OK
  });

  $('a').click(function () {
    return false; // OK --> e.preventDefault() & e.stopPropagation().
  });

  // pure js
  document.querySelector('a').addEventListener('click', function(e) {
    // e.preventDefault(); // OK
    return false;       // NG!!!!!
  });
  </script>
</body>
</html>
</xmp>

<p>
	이 방법은 기본 동작의 중단과 이벤트 흐름의 중단 모두 적용되므로<br />
	이 두가지 중 하나만 중단하기 원하는 경우는 preventDefault() 또는 stopPropagation() 메소드를 개별적으로 사용한다.<br />
</p>



<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">Reference</h4>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-34">34 디바이스의 방향 정보를 다루는 자바스크립트 이벤트</h3>

<p>
	Device Orientation는 HTML5가 제공하는 매우 유용한 기능으로 중력과의 관계에서 디바이스의 물리적 방향의 변화를 감지할 수 있다.<br />
	이것을 이용하면 모바일 디바이스를 회전시켰을 때 이벤트를 감지하여 적절히 화면을 변화 시킬 수 있다.<br />
</p>
<p>
	디바이스의 방향 정보를 다루는 자바스크립트 이벤트는 두가지가 있다.
</p>

<ul class="bu">
<li><b class="em9">DeviceOrientationEvent</b> 가속도계(accelerometer)가 기기의 방향의 변화를 감지했을 때 발생한다.</li>
<li><b class="em9">DeviceMotionEvent</b> 가속도에 변화가 일어났을 때 발생한다</li>
</ul>

<p>
	브라우저 별 지원 정보는 caniuse를 참조한다. 현재 사파리를 제외한 대부분의 브라우저에서 사용할 수 있다.
</p>
<p>
	하지만 오래된 브라우저를 사용하는 사용자를 위해 브라우저의 이벤트 지원 여부를 먼저 확인할 필요가 있다.
</p>

<pre class="mgtbD">
<code class="xmp">
if (window.DeviceOrientationEvent) {
  // Our browser supports DeviceOrientation
} else {
  console.log('Sorry, your browser doesn't support Device Orientation');
}
</code>
</pre>

<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">DeviceOrientationEvent</h4>

<p>
	디바이스의 방향 변화는 3개의 각도( alpha, beta, gamma )를 사용하여 측정된다.
	deviceorientation 이벤트에 리스너를 등록하면 리스너 함수가 주기적으로 호출되어 업데이트된 방향 데이터를 제공한다.
	deviceorientation 이벤트는 다음 4가지의 값을 가진다.
</p>

<pre class="mgtbD">
<code class="xmp">
window.addEventListener('deviceorientation', handleOrientation, false);

function handleOrientation(event) {
  var absolute = event.absolute;
  var alpha    = event.alpha;
  var beta     = event.beta;
  var gamma    = event.gamma;

  // Do stuff with the new orientation data
}
</code>
</pre>


<table class="t3 w100 ttpdtb1em ttpdlr2pct thcv0 lhD tttac tt2tal ttvam ttwa-small-only">
  <thead>
    <tr>
      <th>값</th>
      <th>의미</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>absolute</td>
      <td>지구좌표계(Earth coordinate system)을 사용하는 지에 대한 boolean 값이다. 일반적인 경우 사용하지 않는다.</td>
    </tr>
    <tr>
      <td>alpha</td>
      <td>0도부터 360도까지 범위의 z축을 중심으로 디바이스의 움직임을 나타낸다.</td>
    </tr>
    <tr>
      <td>beta</td>
      <td>-180도부터 180도(모바일 사파리: -90도~90도)까지 범위의 x축을 중심으로 디바이스의 움직임을 나타낸다. 이는 디바이스의 앞뒤 움직임을 나타낸다.</td>
    </tr>
    <tr>
      <td>gamma</td>
      <td>-90도부터 90도(모바일 사파리: -180도~180도)까지 범위의 y축을 중심으로 디바이스의 움직임을 나타낸다. 이는 디바이스의 좌우 움직임을 나타낸다.</td>
    </tr>
  </tbody>
</table>


<!-- even-grid -->
<div class="even-grid evenmix-123 tac">
	<div class="column">
		<figure class="box1 mg0 pd10px tac">
			<img src="https://poiemaweb.com/img/deviceorientation-alpha.png" alt="deviceorientation-alpha" />
			<figcaption>alpha</figcaption>
		</figure>
	</div>
	<div class="column">
		<figure class="box1 mg0 pd10px tac">
			<img src="https://poiemaweb.com/img/deviceorientation-beta.png" alt="deviceorientation-beta " />
			<figcaption>beta</figcaption>
		</figure>
	</div>
	<div class="column">
		<figure class="box1 mg0 pd10px tac">
			<img src="https://poiemaweb.com/img/deviceorientation-gamma.png" alt="deviceorientation-gamma " />
			<figcaption>gamma</figcaption>
		</figure>
	</div>
</div>
<!-- /even-grid -->


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">Reference</h4>

<ul>
  <li>
    <p><a href="http://www.sitepoint.com/using-device-orientation-html5/">Using Device Orientation in HTML5</a></p>
  </li>
  <li>
    <p><a href="https://developer.mozilla.org/ko/docs/WebAPI/Detecting_device_orientation">기기 방향 감지하기</a></p>
  </li>
  <li>
    <p><a href="https://developers.google.com/web/fundamentals/native-hardware/device-orientation/">Google Developers Device orientation</a></p>
  </li>
</ul>



<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-35">35 비동기식 처리 모델과 Ajax</h3>


<pre>
1. Ajax (Asynchronous JavaScript and XML)
2. JSON (JavaScript Object Notation)
	2.1 JSON.stringify
	2.2 JSON.parse
3. XMLHttpRequest
	3.1 Ajax request
		3.1.1 XMLHttpRequest.open
		3.1.2 XMLHttpRequest.send
		3.1.3 XMLHttpRequest.setRequestHeader
	3.2 Ajax response
4. Web Server
5. Ajax 예제
	5.1 Load HTML
	5.2 Load JSON
	5.3 Load JSONP
Reference
</pre>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">1. Ajax (Asynchronous JavaScript and XML)</h4>
<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">2. JSON (JavaScript Object Notation)</h4>

<pre class="mgtbD">
<code class="xmp">
{
  "name": "Lee",
  "gender": "male",
  "age": 20,
  "alive": true
}
</code>
</pre>

<p>
	키는 반드시 큰따옴표(작은따옴표 사용불가)로 둘러싸야 한다.
</p>

<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">2.1 JSON.stringify</h5>

<p>
	JSON.stringify 메소드는 객체를 JSON 형식의 문자열로 변환한다.
</p>

<pre class="mgtbD">
<code class="xmp">
const o = { name: 'Lee', gender: 'male', age: 20 };

// 객체 => JSON 형식의 문자열
const strObject = JSON.stringify(o);
console.log(typeof strObject, strObject);
// string {"name":"Lee","gender":"male","age":20}

// 객체 => JSON 형식의 문자열 + prettify
const strPrettyObject = JSON.stringify(o, null, 2);
console.log(typeof strPrettyObject, strPrettyObject);
/*
string {
  "name": "Lee",
  "gender": "male",
  "age": 20
}
*/

// replacer
// 값의 타입이 Number이면 필터링되어 반환되지 않는다.
function filter(key, value) {
  // undefined: 반환하지 않음
  return typeof value === 'number' ? undefined : value;
}

// 객체 => JSON 형식의 문자열 + replacer + prettify
const strFilteredObject = JSON.stringify(o, filter, 2);
console.log(typeof strFilteredObject, strFilteredObject);
/*
string {
  "name": "Lee",
  "gender": "male"
}
*/

const arr = [1, 5, 'false'];

// 배열 객체 => 문자열
const strArray = JSON.stringify(arr);
console.log(typeof strArray, strArray); // string [1,5,"false"]

// replacer
// 모든 값을 대문자로 변환된 문자열을 반환한다
function replaceToUpper(key, value) {
  return value.toString().toUpperCase();
}

// 배열 객체 => 문자열 + replacer
const strFilteredArray = JSON.stringify(arr, replaceToUpper);
console.log(typeof strFilteredArray, strFilteredArray); // string "1,5,FALSE"
</code>
</pre>


<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">2.2 JSON.parse</h5>

<p>
	JSON.parse 메소드는 JSON 데이터를 가진 문자열을 객체로 변환한다.
</p>

<p class="pd1em-rv bg-info">
	서버로부터 브라우저로 전송된 JSON 데이터는 문자열이다.<br />
	이 문자열을 객체로서 사용하려면 객체화하여야 하는데 이를 역직렬화(Deserializing)이라 한다.<br />
	역직렬화를 위해서 내장 객체 JSON의 static 메소드인 JSON.parse를 사용한다.<br />
</p>

<pre class="mgtbD">
<code class="xmp">
const o = { name: 'Lee', gender: 'male', age: 20 };

// 객체 => JSON 형식의 문자열
const strObject = JSON.stringify(o);
console.log(typeof strObject, strObject);
// string {"name":"Lee","gender":"male","age":20}

const arr = [1, 5, 'false'];

// 배열 객체 => 문자열
const strArray = JSON.stringify(arr);
console.log(typeof strArray, strArray); // string [1,5,"false"]

// JSON 형식의 문자열 => 객체
const obj = JSON.parse(strObject);
console.log(typeof obj, obj); // object { name: 'Lee', gender: 'male' }

// 문자열 => 배열 객체
const objArray = JSON.parse(strArray);
console.log(typeof objArray, objArray); // object [1, 5, "false"]
</code>
</pre>

<p>
	배열이 JSON 형식의 문자열로 변환되어 있는 경우 JSON.parse는 문자열을 배열 객체로 변환한다. 배열의 요소가 객체인 경우 배열의 요소까지 객체로 변환한다.
</p>

<pre class="mgtbD">
<code class="xmp">
const todos = [
  { id: 1, content: 'HTML', completed: true },
  { id: 2, content: 'CSS', completed: true },
  { id: 3, content: 'JavaScript', completed: false }
];

// 배열 => JSON 형식의 문자열
const str = JSON.stringify(todos);
console.log(typeof str, str);

// JSON 형식의 문자열 => 배열
const parsed = JSON.parse(str);
console.log(typeof parsed, parsed);
</code>
</pre>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">3. XMLHttpRequest</h4>

<p>
	브라우저는 XMLHttpRequest 객체를 이용하여 Ajax 요청을 생성하고 전송한다.
	서버가 브라우저의 요청에 대해 응답을 반환하면 같은 XMLHttpRequest 객체가 그 결과를 처리한다.
</p>

<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">3.1 Ajax request</h5>

<p>
	다음은 Ajax 요청 처리의 예이다.
</p>

<pre class="mgtbD">
<code class="xmp">
// XMLHttpRequest 객체의 생성
const xhr = new XMLHttpRequest();
// 비동기 방식으로 Request를 오픈한다
xhr.open('GET', '/users');
// Request를 전송한다
xhr.send();
</code>
</pre>

<!-- ◇◆ -->
<h6 class="hb1 h6">3.1.1 XMLHttpRequest.open</h6>

<p>
	XMLHttpRequest 객체의 인스턴스를 생성하고 XMLHttpRequest.open 메소드를 사용하여 서버로의 요청을 준비한다.<br />
	XMLHttpRequest.open의 사용법은 아래와 같다.<br />
</p>

<pre class="mgtbD">
<code class="xmp">
XMLHttpRequest.open(method, url[, async])
</code>
</pre>

<table class="t3 w100 ttpdtb1em ttpdlr2pct thcv0 lhD tttac tt2tal ttvam ttwa-small-only">
	<col style="width:10em;" /><col />
  <thead>
    <tr>
      <th>매개변수</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>method</td>
      <td>HTTP method (“GET”, “POST”, “PUT”, “DELETE” 등)</td>
    </tr>
    <tr>
      <td>url</td>
      <td>요청을 보낼 URL</td>
    </tr>
    <tr>
      <td>async</td>
      <td>비동기 조작 여부. 옵션으로 default는 true이며 비동기 방식으로 동작한다.</td>
    </tr>
  </tbody>
</table>


<!-- ◇◆ -->
<h6 class="hb1 h6">3.1.2 XMLHttpRequest.send</h6>

<p>
	XMLHttpRequest.send 메소드로 준비된 요청을 서버에 전달한다.
</p>
<ul class="bu">
<li>GET 메소드의 경우, URL의 일부분인 쿼리문자열(query string)로 데이터를 서버로 전송한다.</li>
<li>POST 메소드의 경우, 데이터(페이로드)를 Request Body에 담아 전송한다.</li>
</ul>
<p>
	XMLHttpRequest.send 메소드에는 request body에 담아 전송할 인수를 전달할 수 있다.
</p>
<p>
	만약 요청 메소드가 GET인 경우, send 메소드의 인수는 무시되고 request body은 null로 설정된다.
</p>


<!-- ◇◆ -->
<h6 class="hb1 h6">3.1.3 XMLHttpRequest.setRequestHeader</h6>

<p>
	XMLHttpRequest.setRequestHeader 메소드는 HTTP Request Header의 값을 설정한다.
	setRequestHeader 메소드는 반드시 XMLHttpRequest.open 메소드 호출 이후에 호출한다.
</p>
<p>
	자주 사용하는 Request Header인 Content-type, Accept에 대해 살펴보자.
</p>

<strong class="big">Content-type</strong>
<p>
	Content-type은 request body에 담아 전송할 데이터의 MIME-type의 정보를 표현한다. 자주 사용되는 MIME-type은 아래와 같다.
</p>

<table class="t3 w100 ttpdtb1em ttpdlr2pct thcv0 lhD tttac tt2tal ttvam ttwa-small-only">
	<col style="width:10em;" /><col />
  <thead>
    <tr>
      <th>타입</th>
      <th>서브타입</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>text 타입</td>
      <td>text/plain, text/html, text/css, text/javascript</td>
    </tr>
    <tr>
      <td>Application 타입</td>
      <td>application/json, application/x-www-form-urlencode</td>
    </tr>
    <tr>
      <td>File을 업로드하기 위한 타입</td>
      <td>multipart/formed-data</td>
    </tr>
  </tbody>
</table>

<p>
	다음은 request body에 담아 서버로 전송할 데이터의 MIME-type을 지정하는 예이다.
</p>

<pre class="mgtbD">
<code class="xmp">
// json으로 전송하는 경우
xhr.open('POST', '/users');

// 클라이언트가 서버로 전송할 데이터의 MIME-type 지정: json
xhr.setRequestHeader('Content-type', 'application/json');

const data = { id: 3, title: 'JavaScript', author: 'Park', price: 5000};

xhr.send(JSON.stringify(data));
</code>
</pre>

<pre class="mgtbD">
<code class="xmp">
// x-www-form-urlencoded으로 전송하는 경우
xhr.open('POST', '/users');

// 클라이언트가 서버로 전송할 데이터의 MIME-type 지정: x-www-form-urlencoded
// application/x-www-form-urlencoded는 key=value&key=value...의 형태로 전송
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');

const data = { title: 'JavaScript', author: 'Park', price: 5000};

xhr.send(Object.keys(data).map(key => `${key}=${data[key]}`).join('&'));
// escaping untrusted data
// xhr.send(Object.keys(data).map(key => `${key}=${encodeURIComponent(data[key])}`).join('&'));
</code>
</pre>

<strong class="big">Accept</strong>

<p>
	HTTP 클라이언트가 서버에 요청할 때 서버가 센드백할 데이터의 MIME-type을 Accept로 지정할 수 있다.
</p>
<p>
	다음은 서버가 센드백할 데이터의 MIME-type을 지정하는 예이다.
</p>

<pre class="mgtbD">
<code class="xmp">
// 서버가 센드백할 데이터의 MIME-type 지정: json
xhr.setRequestHeader('Accept', 'application/json');
</code>
</pre>

<p>
	만약 Accept 헤더를 설정하지 않으면, send 메소드가 호출될 때 Accept 헤더가 */*으로 전송된다.
</p>


<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">3.2 Ajax response</h5>

<p>
	다음은 Ajax 응답 처리의 예이다.
</p>

<pre class="mgtbD">
<code class="xmp">
// XMLHttpRequest 객체의 생성
const xhr = new XMLHttpRequest();

// XMLHttpRequest.readyState 프로퍼티가 변경(이벤트 발생)될 때마다 onreadystatechange 이벤트 핸들러가 호출된다.
xhr.onreadystatechange = function (e) {
  // readyStates는 XMLHttpRequest의 상태(state)를 반환
  // readyState: 4 => DONE(서버 응답 완료)
  if (xhr.readyState !== XMLHttpRequest.DONE) return;

  // status는 response 상태 코드를 반환 : 200 => 정상 응답
  if(xhr.status === 200) {
    console.log(xhr.responseText);
  } else {
    console.log('Error!');
  }
};
</code>
</pre>

<p>
	위 코드를 좀 더 자세히 살펴보도록 하자.
</p>
<p>
	XMLHttpRequest.send 메소드를 통해 서버에 Request를 전송하면 서버는 Response를 반환한다.<br />
	하지만 언제 Response가 클라이언트에 도달할 지는 알 수 없다.<br />
	XMLHttpRequest.<b class="em9">onreadystatechange는</b> Response가 클라이언트에 도달하여 발생된 이벤트를 감지하고 콜백 함수를 실행하여 준다.<br />
	이때 이벤트는 Request에 어떠한 변화가 발생한 경우 즉 XMLHttpRequest.<b class="em9">readyState</b> 프로퍼티가 변경된 경우 발생한다.
</p>

<pre class="mgtbD">
<code class="xmp">
// XMLHttpRequest 객체의 생성
var xhr = new XMLHttpRequest();
// 비동기 방식으로 Request를 오픈한다
xhr.open('GET', 'data/test.json');
// Request를 전송한다
xhr.send();

// XMLHttpRequest.readyState 프로퍼티가 변경(이벤트 발생)될 때마다 콜백함수(이벤트 핸들러)를 호출한다.
xhr.onreadystatechange = function (e) {
  // 이 함수는 Response가 클라이언트에 도달하면 호출된다.
};
</code>
</pre>

<p>
	XMLHttpRequest 객체는 response가 클라이언트에 도달했는지를 추적할 수 있는 프로퍼티를 제공한다.
	이 프로퍼티가 바로 XMLHttpRequest.readyState이다.
	만일 XMLHttpRequest.readyState의 값이 4인 경우, 정상적으로 Response가 돌아온 경우이다.
</p>
<p>
	readXMLHttpRequest.readyState의 값은 아래와 같다.
</p>

<table class="t3 w100 ttpdtb1em ttpdlr2pct thcv0 lhD tttac tt2tal tt3tal ttvam ttwa-small-only">
	<col style="width:10em;" /><col />
  <thead>
    <tr>
      <th>Value</th>
      <th>State</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>UNSENT</td>
      <td>XMLHttpRequest.open() 메소드 호출 이전</td>
    </tr>
    <tr>
      <td>1</td>
      <td>OPENED</td>
      <td>XMLHttpRequest.open() 메소드 호출 완료</td>
    </tr>
    <tr>
      <td>2</td>
      <td>HEADERS_RECEIVED</td>
      <td>XMLHttpRequest.send() 메소드 호출 완료</td>
    </tr>
    <tr>
      <td>3</td>
      <td>LOADING</td>
      <td>서버 응답 중(XMLHttpRequest.responseText 미완성 상태)</td>
    </tr>
    <tr>
      <td>4</td>
      <td>DONE</td>
      <td>서버 응답 완료</td>
    </tr>
  </tbody>
</table>

<pre class="mgtbD">
<code class="xmp">
// XMLHttpRequest 객체의 생성
var xhr = new XMLHttpRequest();
// 비동기 방식으로 Request를 오픈한다
xhr.open('GET', 'data/test.json');
// Request를 전송한다
xhr.send();

// XMLHttpRequest.readyState 프로퍼티가 변경(이벤트 발생)될 때마다 콜백함수(이벤트 핸들러)를 호출한다.
xhr.onreadystatechange = function (e) {
  // 이 함수는 Response가 클라이언트에 도달하면 호출된다.

  // readyStates는 XMLHttpRequest의 상태(state)를 반환
  // readyState: 4 => DONE(서버 응답 완료)
  if (xhr.readyState !== XMLHttpRequest.DONE) return;

  // status는 response 상태 코드를 반환 : 200 => 정상 응답
  if(xhr.status === 200) {
    console.log(xhr.responseText);
  } else {
    console.log('Error!');
  }
};
</code>
</pre>

<p>
	XMLHttpRequest의.readyState가 4인 경우, 서버 응답이 완료된 상태이므로
	이후 XMLHttpRequest.status가 200(정상 응답)임을 확인하고 정상인 경우, XMLHttpRequest.responseText를 취득한다.
	XMLHttpRequest.responseText에는 서버가 전송한 데이터가 담겨 있다.
</p>
<p>
	만약 서버 응답 완료 상태에만 반응하도록 하려면 readystatechange 이벤트 대신 load 이벤트를 사용해도 된다.
	load 이벤트는 서버 응답이 완료된 경우에 발생한다.
</p>

<pre class="mgtbD">
<code class="xmp">
// XMLHttpRequest 객체의 생성
var xhr = new XMLHttpRequest();
// 비동기 방식으로 Request를 오픈한다
xhr.open('GET', 'data/test.json');
// Request를 전송한다
xhr.send();

// load 이벤트는 서버 응답이 완료된 경우에 발생한다.
xhr.onload = function (e) {
  // status는 response 상태 코드를 반환 : 200 => 정상 응답
  if(xhr.status === 200) {
    console.log(xhr.responseText);
  } else {
    console.log('Error!');
  }
};
</code>
</pre>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">4. Web Server</h4>

<p>
	웹서버(Web Server)는 브라우저와 같은 클라이언트로부터 HTTP 요청을 받아들이고 HTML 문서와 같은 웹 페이지를 반환하는 컴퓨터 프로그램이다.
</p>
<p>
	Ajax는 웹서버와의 통신이 필요하므로 예제를 실행하기 위해서는 웹서버가 필요하다.
</p>
<p>
	Node.js가 설치되어 있다면 Express로 간단한 웹서버를 생성한다.
</p>

<pre class="mgtbD">
<code class="xmp">
## 데스크탑에 webserver-express 폴더가 생성된다.
$ cd ~/Desktop
$ git clone https://github.com/ungmo2/webserver-express.git
$ cd webserver-express
## install express
$ npm install
## create public folder
$ mkdir public
</code>
</pre>

<p>
	webserver-express 디렉터리 내에 있는 public 디렉터리가 루트 디렉터리이다.<br />
</p>
<p>
	웹서버를 실행한다.<br />
</p>

<pre class="mgtbD">
<code class="xmp">
## start webserver
$ npm start
</code>
</pre>

<p>
	<a href="http://localhost:3000" target="_blank" rel="noopener" title="새 창" class="a1">http://localhost:3000</a>에 접속하여 Hello World!가 표시되면 웹서버가 정상 동작하는 것이다.
</p>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">5. Ajax 예제</h4>
<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">5.1 Load HTML</h5>

<p>
	Ajax를 이용하여 웹페이지에 추가하기 가장 손쉬운 데이터 형식은 HTML이다.<br />
	별도의 작업없이 전송받은 데이터를 DOM에 추가하면 된다.<br />
</p>

<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">5.2 Load JSON</h5>

<p>
	서버로부터 브라우저로 전송된 JSON 데이터는 문자열이다.<br />
	이 문자열을 객체화하여야 하는데 이를 역직렬화(Deserializing)이라 한다.<br />
	역직렬화를 위해서 내장 객체 JSON의 static 메소드인 <b class="em9">JSON.parse()</b>를 사용한다.<br />
</p>
<p>
	경로: 루트 폴더(webserver-express/public)/data/data.json
</p>

<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">5.3 Load JSONP</h5>

<p>
	요청에 의해 웹페이지가 전달된 서버와 동일한 도메인의 서버로 부터 전달된 데이터는 문제없이 처리할 수 있다.<br />
	하지만 보안상의 이유로 다른 도메인(http와 https, 포트가 다르면 다른 도메인으로 간주한다)으로의 요청(크로스 도메인 요청)은 제한된다.<br />
	이것을 동일출처원칙(Same-origin policy)이라고 한다.<br />
</p>
<p>
	동일출처원칙을 우회하는 방법은 세가지가 있다.<br />
</p>

<!-- ◇◆ -->
<h6 class="hb1 h6">1. 웹서버의 프록시 파일</h6>

<p>
	서버에 원격 서버로부터 데이터를 수집하는 별도의 기능을 추가하는 것이다. 이를 프록시(Proxy)라 한다.
</p>

<!-- ◇◆ -->
<h6 class="hb1 h6">2. JSONP</h6>

<p>
	script 태그의 원본 주소에 대한 제약은 존재하지 않는데 이것을 이용하여 다른 도메인의 서버에서 데이터를 수집하는 방법이다. 자신의 서버에 함수를 정의하고 다른 도메인의 서버에 얻고자 하는 데이터를 인수로 하는 함수 호출문을 로드하는 것이다.
</p>

<!-- ◇◆ -->
<h6 class="hb1 h6">3. Cross-Origin Resource Sharing</h6>

<p>
	HTTP 헤더에 추가적으로 정보를 추가하여 브라우저와 서버가 서로 통신해야 한다는 사실을 알게하는 방법이다.
	W3C 명세에 포함되어 있지만 최신 브라우저에서만 동작하며 서버에 HTTP 헤더를 설정해 주어야 한다.
</p>

<p>
	Node.js로 구현한 서버의 경우, <a href="https://github.com/expressjs/cors" target="_blank" rel="noopener" title="새 창" class="a1">CORS</a> package를 사용하면 간단하게 Cross-Origin Resource Sharing을 구현할 수 있다.
</p>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">Reference</h4>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-36">36 REST(Representational State Transfer) API</h3>


<pre>
1. REST API 중심 규칙
2. HTTP Method
3. REST API의 구성
4. REST API의 Example
	4.1 json-server
	4.2 GET
	4.3 POST
	4.4 PUT
	4.5 PATCH
	4.6 DELETE
Reference
</pre>

<p>
	REST(Representational State Transfer)는 HTTP/1.0과 1.1의 스펙 작성에 참여하였고 아파치 HTTP 서버 프로젝트의 공동설립자인 로이 필딩 (Roy Fielding)의 2000년 논문에서 처음 소개되었다.
	발표 당시의 웹이 HTTP의 설계 상 우수성을 제대로 사용하지 못하고 있는 상황을 보고 웹의 장점을 최대한 활용할 수 있는 아키텍쳐로서 REST를 소개하였고
	이는 HTTP 프로토콜을 의도에 맞게 디자인하도록 유도하고 있다.
	REST의 기본 원칙을 성실히 지킨 서비스 디자인을 "<b class="em0">RESTful</b>"이라고 표현한다.
</p>

<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">1. REST API 중심 규칙</h4>

<p>
	REST에서 가장 중요한 기본적인 규칙은 두 가지이다.<br />
	URI는 자원을 표현하는 데에 집중하고 행위에 대한 정의는 HTTP Method를 통해 하는 것이 REST한 API를 설계하는 중심 규칙이다.<br />
</p>

<p>
	<strong class="em0">1. URI는 정보의 자원을 표현해야 한다.</strong>
</p>
<p>
	리소스명은 동사보다는 명사를 사용한다. URI는 자원을 표현하는데 중점을 두어야 한다. get 같은 행위에 대한 표현이 들어가서는 안된다
</p>

<pre class="mgtbD">
<code class="xmp">
# bad
GET /getTodos/1
GET /todos/show/1

# good
GET /todos/1
</code>
</pre>

<p>
	<strong class="em0">2. 자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE 등)으로 표현한다.</strong>
</p>

<pre class="mgtbD">
<code class="xmp">
# bad
GET /todos/delete/1

# good
DELETE /todos/1
</code>
</pre>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">2. HTTP Method</h4>

<p>
	주로 5가지의 Method(GET, POST, PUT, PATCH, DELETE)를 사용하여 CRUD를 구현한다.
</p>

<table class="t3 w100 ttpdtb1em ttpdlr2pct thcv0 lhD tttal tt4tac ttvam ttwa-small-only">
	<col style="width:10em;" /><col />
  <thead>
    <tr>
      <th>Method</th>
      <th>Action</th>
      <th>역할</th>
      <th>페이로드</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>GET</td>
      <td>index/retrieve</td>
      <td>모든/특정 리소스를 조회</td>
      <td>x</td>
    </tr>
    <tr>
      <td>POST</td>
      <td>create</td>
      <td>리소스를 생성</td>
      <td>○</td>
    </tr>
    <tr>
      <td>PUT</td>
      <td>replace</td>
      <td><strong>리소스의 전체를 교체</strong></td>
      <td>○</td>
    </tr>
    <tr>
      <td>PATCH</td>
      <td>modify</td>
      <td><strong>리소스의 일부를 수정</strong></td>
      <td>○</td>
    </tr>
    <tr>
      <td>DELETE</td>
      <td>delete</td>
      <td>모든/특정 리소스를 삭제</td>
      <td>x</td>
    </tr>
  </tbody>
</table>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">3. REST API의 구성</h4>

<p>
	REST API는 자원(Resource), 행위(Verb), 표현(Representations)의 3가지 요소로 구성된다.
	REST는 자체 표현 구조(Self-descriptiveness)로 구성되어 REST API만으로 요청을 이해할 수 있다.
</p>

<table class="t3 w100 ttpdtb1em ttpdlr2pct thcv0 lhD tttal tt4tac ttvam ttwa-small-only">
	<col style="width:10em;" /><col />
  <thead>
    <tr>
      <th style="text-align: left">구성 요소</th>
      <th style="text-align: left">내용</th>
      <th style="text-align: left">표현 방법</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">Resource</td>
      <td style="text-align: left">자원</td>
      <td style="text-align: left">HTTP URI</td>
    </tr>
    <tr>
      <td style="text-align: left">Verb</td>
      <td style="text-align: left">자원에 대한 행위</td>
      <td style="text-align: left">HTTP Method</td>
    </tr>
    <tr>
      <td style="text-align: left">Representations</td>
      <td style="text-align: left">자원에 대한 행위의 내용</td>
      <td style="text-align: left">HTTP Message Pay Load</td>
    </tr>
  </tbody>
</table>

<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">4. REST API의 Example</h4>
<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">4.1 json-server</h5>
<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">4.2 GET</h5>
<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">4.3 POST</h5>
<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">4.4 PUT</h5>
<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">4.5 PATCH</h5>
<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">4.6 DELETE</h5>
<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">Reference</h4>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3" id="h3-37">37 Single Page Application & Routing</h3>


<pre>
1. SPA (Single Page Application)
2. Routing
3. SPA와 Routing
	3.1 전통적 링크 방식
	3.2 AJAX 방식
	3.3 Hash 방식
	3.4 PJAX 방식
4. Conclusion
Reference
</pre>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">1. SPA (Single Page Application)</h4>


<p>단일 페이지 애플리케이션(Single Page Application, SPA)는 모던 웹의 패러다임이다. SPA는 기본적으로 단일 페이지로 구성되며 기존의 서버 사이드 렌더링과 비교할 때, 배포가 간단하며 네이티브 앱과 유사한 사용자 경험을 제공할 수 있다는 장점이 있다.</p>

<p>link tag를 사용하는 전통적인 웹 방식은 새로운 페이지 요청 시마다 정적 리소스가 다운로드되고 전체 페이지를 다시 렌더링하는 방식을 사용하므로 새로고침이 발생되어 사용성이 좋지 않다. 그리고 변경이 필요없는 부분를 포함하여 전체 페이지를 갱신하므로 비효율적이다.</p>

<p>SPA는 기본적으로 웹 애플리케이션에 필요한 모든 정적 리소스를 최초에 한번 다운로드한다. 이후 새로운 페이지 요청 시, 페이지 갱신에 필요한 데이터만을 전달받아 페이지를 갱신하므로 전체적인 트래픽을 감소할 수 있고, 전체 페이지를 다시 렌더링하지 않고 변경되는 부분만을 갱신하므로 새로고침이 발생하지 않아 네이티브 앱과 유사한 사용자 경험을 제공할 수 있다.</p>

<p>모바일의 사용이 증가하고 있는 현 시점에 트래픽의 감소와 속도, 사용성, 반응성의 향상은 매우 중요한 이슈이다. SPA의 핵심 가치는 <strong>사용자 경험(UX) 향상</strong>에 있으며 부가적으로 애플리케이션 속도의 향상도 기대할 수 있어서 모바일 퍼스트(Mobile First) 전략에 부합한다.</p>

<p>모든 소프트웨어 아키텍처에는 trade-off가 존재하며 모든 애플리케이션에 적합한 은탄환(Silver bullet)은 없듯이 SPA 또한 구조적인 단점을 가지고 있다. 대표적인 단점은 아래와 같다.</p>

<!-- pd1em-rv -->
<div class="pd15em-rv bg-info">
	<dl class="mg0">
		<dt><b class="em0">초기 구동 속도</b></dt>
		<dd>SPA는 웹 애플리케이션에 필요한 모든 정적 리소스를 최초에 한번 다운로드하기 때문에 초기 구동 속도가 상대적으로 느리다. 하지만 SPA는 웹페이지보다는 애플리케이션에 적합한 기술이므로 트래픽의 감소와 속도, 사용성, 반응성의 향상 등의 장점을 생각한다면 결정적인 단점이라고 할 수는 없다.</dd>
		<dt><b class="em0">SEO(검색엔진 최적화) 문제</b></dt>
		<dd>SPA는 서버 렌더링 방식이 아닌 자바스크립트 기반 비동기 모델(클라이언트 렌더링 방식)이다. 따라서 SEO는 언제나 단점으로 부각되어 왔던 이슈이다. 하지만 SPA는 정보의 제공을 위한 웹페이지보다는 애플리케이션에 적합한 기술이므로 SEO 이슈는 심각한 문제로 볼 수 없다. Angular 또는 React 등의 SPA 프레임워크는 서버 렌더링을 지원하는 SEO 대응 기술이 이미 존재하고 있어 SEO 대응이 필요한 페이지에 대해서는 선별적 SEO 대응이 가능하다.</dd>
	</dl>
</div>
<!-- /pd1em-rv -->


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">2. Routing</h4>


<p>
	라우팅이란 출발지에서 목적지까지의 경로를 결정하는 기능이다.
	애플리케이션의 라우팅은 사용자가 태스크를 수행하기 위해 어떤 화면(view)에서 다른 화면으로 화면을 전환하는 내비게이션을 관리하기 위한 기능을 의미한다.
	일반적으로 사용자자 요청한 URL 또는 이벤트를 해석하고 새로운 페이지로 전환하기 위한 데이터를 취득하기 위해 서버에 필요 데이터를 요청하고 화면을 전환하는 위한 일련의 행위를 말한다.
</p>

<p>브라우저가 화면을 전환하는 경우는 아래와 같다.</p>

<ol>
  <li>
    <p>브라우저의 주소창에 URL을 입력하면 해당 페이지로 이동한다.</p>
  </li>
  <li>
    <p>웹페이지의 링크를 클릭하면 해당 페이지로 이동한다.</p>
  </li>
  <li>
    <p>브라우저의 뒤로가기 또는 앞으로가기 버튼을 클릭하면 사용자가 방문한 웹페이지의 기록(history)의 뒤 또는 앞으로 이동한다.</p>
  </li>
</ol>

<p>
	AJAX 요청에 의해 서버로부터 데이터를 응답받아 화면을 생성하는 경우, 브라우저의 주소창의 URL은 변경되지 않는다.
	이는 사용자의 방문 history를 관리할 수 없음을 의미하며, SEO(검색엔진 최적화) 이슈의 발생 원인이기도 하다.
	<strong>history 관리를 위해서는 각 페이지는 브라우저의 주소창에서 구별할 수 있는 유일한 URL을 소유하여야 한다.</strong>
</p>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">3. SPA와 Routing</h4>


<p>전통적인 웹 방식에서 SPA까지 발전하게 된 과정과 SPA의 라우팅(Routing)에 대하 살펴보도록 하자.</p>

<p>예제를 실행하기 위해 과정은 아래와 같다.</p>

<p>가상 서버를 실행하기 위해 <a href="https://www.npmjs.com/package/serve">serve</a>를 설치한다.</p>

<pre class="mgtbD">
<code class="xmp">
	$ npm install -g serve
</code>
</pre>

<p>소스코드를 clone한다.</p>

<pre class="mgtbD">
<code class="xmp">
$ git clone https://github.com/ungmo2/spa-example.git
$ cd spa-example
</code>
</pre>

<em class="em"><!-- ★★(ourToDo) -->
	@m) 실행불가! $ git clone https://github.com/ungmo2/spa-example.git<br />
	:: git 은 내부 또는 외부 명령, 실행할 수 있는 프로그램, 또는 배치 파일이 아닙니다.
</em>



<p>예제의 실행 방법은 아래와 같다.</p>

<pre class="mgtbD">
<code class="xmp">
# 전통적 링크 방식
$ npm run link
# AJAX 방식
$ npm run ajax
# Hash 방식
$ npm run hash
# PJAX 방식
$ npm run pjax
</code>
</pre>



<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">3.1 전통적 링크 방식</h5>

<p>전통적 링크 방식은 link tag로 동작하는 기본적인 웹페이지의 동작 방식이다. 아래 코드를 살펴보자.</p>

<xmp class="xmp">
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Link</title>
  <link rel="stylesheet" href="css/style.css">
</head>
<body>
  <nav>
    <ul>
      <li><a href="/">Home</a></li>
      <li><a href="service.html">Service</a></li>
      <li><a href="about.html">About</a></li>
    </ul>
  </nav>
  <section>
    <h1>Home</h1>
    <p>This is main page</p>
  </section>
</body>
</html>
</xmp>

<p>
	link tag(<code>&lt;a href="service.html"&gt;Service&lt;/a&gt;</code> 등)을 클릭하면
	href 어트리뷰트의 값인 리소스의 경로가 URL의 path에 추가되어 주소창에 나타나고 해당 리소스를 서버에 요청된다.
</p>

<p><img src="http://poiemaweb.com/img/uri.png" alt="uri" /></p>

<p class="w10em mgt0 mgla mgra bgce tac">URI의 구조</p>

<p>
	이때 서버는 html로 화면을 표시하는데 부족함이 없는 완전한 리소스를 클라이언트에 응답한다.
	이를 <strong>서버 렌더링</strong>이라 한다. 브라우저는 서버가 응답한 html을 수신하고 렌더링한다.
	이때 이전 페이지에서 수신된 html로 전환하는 과정에서 전체 페이지를 다시 렌더링하게 되므로 새로고침이 발생한다.
</p>

<p style="width:400px;margin:auto;">
	<img src="http://poiemaweb.com/img/traditional-webpage-lifecycle.png" alt="traditional-webpage-lifecycle" />
</p>

<p class="w20em mgt0 mgla mgra bgce tac">Traditional Web Page Lifecycle</p>

<p>
	이 방식은 JavaScript가 필요없이 응답된 html만으로 렌더링이 가능하며
	각 페이지마다 고유의 URL이 존재하므로 history 관리 및 SEO 대응에 아무런 문제가 없다.
	하지만 중복된 리소스를 요청마다 수신해야 하며,
	전체 페이지를 다시 렌더링하는 과정에서 새로고침이 발생하여 사용성이 좋지 않은 단점이 있다.
</p>

<p>위 예제를 실행하려면 아래의 명령어를 실행한다.</p>

<pre class="mgtbD">
<code class="xmp">
$ npm run link
</code>
</pre>


<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">3.2 AJAX 방식</h5>


<p>
	전통적 링크 방식은 현재 페이지에서 수신된 html로 화면을 전환하는 과정에서 전체 페이지를 새로 렌더링하게 되므로 새로고침이 발생한다.
	간단한 웹페이지라면 문제될 것이 없겠지만 복잡한 웹페이지의 경우, 요청마다 중복된 HTML과 CSS, JavaScript를 매번 다운로드해야하므로 속도 저하의 요인이 된다.
</p>

<p>
	전통적 링크 방식의 단점을 보완하기 위해 등장한 것이 AJAX(Asynchronous JavaScript and XML)이다.
	AJAX는 자바스크립트를 이용해서 비동기적(Asynchronous)으로 서버와 브라우저가 데이터를 교환할 수 있는 통신 방식을 의미한다.
</p>

<p style="width:400px;margin:auto;"><img src="http://poiemaweb.com/img/ajax-webpage-lifecycle.png" alt="ajax-webpage-lifecycle" /></p>

<p class="w10em mgt0 mgla mgra bgce tac">AJAX Lifecycle</p>

<p>
	서버로부터 웹페이지가 반환되면 화면 전체를 새로 렌더링해야 하는데
	페이지 일부만을 갱신하고도 동일한 효과를 볼 수 있도록 하는 것이 AJAX이다.
</p>

<xmp class="xmp">
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>AJAX</title>
  <link rel="stylesheet" href="css/style.css">
  <script src="js/index.js" defer></script>
</head>
<body>
  <nav>
    <ul id="navigation">
      <li><a id="home">Home</a></li>
      <li><a id="service">Service</a></li>
      <li><a id="about">About</a></li>
    </ul>
  </nav>
  <div class="app-root">Loading..</div>
</body>
</html>
</xmp>

<p>
	위 예제를 살펴보면 link tag(<code>&lt;a id="home"&gt;Home&lt;/a&gt;</code> 등)에 href 어트리뷰트를 사용하지 않는다.
	그리고 웹페이지의 내용이 일부 비어있는 것을 알 수 있다.
	내비게이션이 클릭되면 link tag의 기본 동작을 prevent하고 AJAX을 사용하여 서버에 필요한 리소스를 요청한다.
	요청된 리소스가 응답되면 클라이언트에서 웹페이지에 그 내용을 갈아끼워 html을 완성한다.
</p>

<p>
	이를 통해 불필요한 리소스 중복 요청을 방지할 수 있다.
	또한 페이지 전체를 새로 렌더링할 필요가 없고 갱신이 필요한 일부만 로드하여 갱신하면 되므로
	빠른 퍼포먼스와 부드러운 화면 표시 효과를 기대할 수 있으므로 새로고침이 없는 보다 향상된 사용자 경험을 구현할 수 있다는 장점이 있다.
</p>

<p>JavaScript의 구현은 아래와 같다.</p>

<pre class="mgtbD">
<code class="xmp">
(function () {
  const root = document.querySelector('.app-root');
  const navigation = document.getElementById('navigation');

  const routes = {
    // id: url
    home: '/data/home.json',
    service: '/data/service.json',
    about: '/data/about.html'
  };

  const render = async id =&gt; {
    try {
      const url = routes[id];
      if (!url) {
        root.innerHTML = `${url} Not Found`;
        return;
      }

      const res = await fetch(url);
      const contentType = res.headers.get('content-type');

      if (contentType?.includes('application/json')) {
        const json = await res.json();
        root.innerHTML = `&lt;h1&gt;${json.title}&lt;/h1&gt;&lt;p&gt;${json.content}&lt;/p&gt;`;
      } else {
        root.innerHTML = await res.text();
      }
    } catch (err) {
      console.error(err);
    }
  };

  // AJAX 요청은 주소창의 url을 변경시키지 않으므로 history 관리가 되지 않는다.
  navigation.onclick = e =&gt; {
    if (!e.target.matches('#navigation &gt; li &gt; a')) return;
    e.preventDefault();
    render(e.target.id);
  };

  // DOMContentLoaded은 HTML과 script가 로드된 시점에 발생하는 이벤트로 load 이벤트보다 먼저 발생한다. (IE 9 이상 지원)
  // 새로고침이 클릭되었을 때, 웹페이지가 처음 로딩되었을 때, 현 페이지(예를들어 loclahost:5002)를 서버에 요청한다. 이때 Home에 필요한 리소스를 Ajax 요청한다.
  window.addEventListener('DOMContentLoaded', () =&gt; render('home'));
}());
</code>
</pre>


<p>
	AJAX는 URL을 변경시키지 않으므로 주소창의 주소가 변경되지 않는다.
	이는 브라우저의 뒤로가기, 앞으로가기 등의 <strong>history 관리가 동작하지 않음을 의미한다.</strong>
	물론 코드 상의 history.back(), history.go(n) 등도 동작하지 않는다.
	새로고침을 클릭하면 주소창의 주소가 변경되지 않기 때문에 언제나 첫페이지가 다시 로딩된다.
	하나의 주소로 동작하는 AJAX 방식은 <strong>SEO 이슈</strong>에서도 자유로울 수 없다.
</p>

<p>위 예제를 실행하려면 아래의 명령어를 실행한다.</p>

<pre class="mgtbD">
<code class="xmp">
$ npm run ajax
</code>
</pre>


<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">3.3 Hash 방식</h5>


<p>
	AJAX 방식은 불필요한 리소스 중복 요청을 방지할 수 있고, 새로고침이 없는 사용자 경험을 구현할 수 있다는 장점이 있지만
	history 관리가 되지 않는 단점이 있다. 이를 보완한 방법이 Hash 방식이다.
</p>

<p>
	Hash 방식은 URI의 fragment identifier(#service)의 고유 기능인 앵커(anchor)를 사용한다.
	fragment identifier는 hash mark 또는 hash라고 부르기도 한다.
</p>

<xmp class="xmp">
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>SPA</title>
  <link rel="stylesheet" href="css/style.css">
  <script src="js/index.js" defer></script>
</head>
<body>
  <nav>
    <ul>
      <li><a href="/">Home</a></li>
      <li><a href="#service">Service</a></li>
      <li><a href="#about">About</a></li>
    </ul>
  </nav>
  <div class="app-root">Loading...</div>
</body>
</html>
</xmp>

<p>
	위 예제를 살펴보면 link tag(<code>&lt;a href="#service"&gt;Service&lt;/a&gt;</code> 등)의 href 어트리뷰트에 hash를 사용하고 있다.
	즉, 내비게이션이 클릭되면 hash가 추가된 URI가 주소창에 표시된다.
	단, <strong>URL이 동일한 상태에서 hash가 변경되면 브라우저는 서버에 어떠한 요청도 하지 않는다.
	즉, hash는 변경되어도 서버에 새로운 요청을 보내지 않으며 따라서 페이지가 갱신되지 않는다.</strong>
	hash는 요청을 위한 것이 아니라 fragment identifier(#service)의 고유 기능인 앵커(anchor)로 웹페이지 내부에서 이동을 위한 것이기 때문이다.
</p>

<p>
	또한 hash 방식은 서버에 새로운 요청을 보내지 않으며 따라서 페이지가 갱신되지 않지만
	페이지마다 고유의 <strong>논리적 URL이 존재하므로 history 관리에 아무런 문제가 없다.</strong>
</p>

<p>JavaScript의 구현은 아래와 같다.</p>

<pre class="mgtbD">
<code class="xmp">
(function () {
  const root = document.querySelector('.app-root');

  const routes = {
    // hash: url
    '': '/data/home.json',
    service: '/data/service.json',
    about: '/data/about.html'
  };

  const render = async () =&gt; {
    try {
      // url의 hash를 취득
      const hash = location.hash.replace('#', '');
      const url = routes[hash];
      if (!url) {
        root.innerHTML = `${hash} Not Found`;
        return;
      }

      const res = await fetch(url);
      const contentType = res.headers.get('content-type');

      if (contentType?.includes('application/json')) {
        const json = await res.json();
        root.innerHTML = `&lt;h1&gt;${json.title}&lt;/h1&gt;&lt;p&gt;${json.content}&lt;/p&gt;`;
      } else {
        root.innerHTML = await res.text();
      }
    } catch (err) {
      console.error(err);
    }
  };

  // 네비게이션을 클릭하면 uri의 hash가 변경된다. 주소창의 uri가 변경되므로 history 관리가 가능하다.
  // 이때 uri의 hash만 변경되면 서버로 요청을 수행하지 않는다.
  // 따라서 uri의 hash가 변경하면 발생하는 이벤트인 hashchange 이벤트를 사용하여 hash의 변경을 감지하여 필요한 AJAX 요청을 수행한다.
  // hash 방식의 단점은 uri에 불필요한 #이 들어간다는 것이다.
  window.addEventListener('hashchange', render);

  // DOMContentLoaded은 HTML과 script가 로드된 시점에 발생하는 이벤트로 load 이벤트보다 먼저 발생한다. (IE 9 이상 지원)
  // 새로고침이 클릭되었을 때, 웹페이지가 처음 로딩되었을 때, 현 페이지(예를 들어 loclahost:5003/#service)를 요청하므로
  // index.html이 다시 로드되고 DOMContentLoaded 이벤트가 발생하여 render가 호출된다.
  window.addEventListener('DOMContentLoaded', render);
}());
</code>
</pre>

<p>
	hash 방식은 uri의 hash가 변경하면 발생하는 이벤트인
	<a href="https://developer.mozilla.org/ko/docs/Web/API/WindowEventHandlers/onhashchange">
		hashchange
	</a> 이벤트를 사용하여
	hash의 변경을 감지하여 필요한 AJAX 요청을 수행한다.</p>

<p>
	hash 방식의 단점은 uri에 불필요한 #이 들어간다는 것이다.
	일반적으로 hash 방식을 사용할 때 #!을 사용하기도 하는데
	이를 <a href="https://blog.outsider.ne.kr/698">해시뱅(Hash-bang)</a>이라고 부른다.
</p>

<p>
	hash 방식은 과도기적 기술이다.
	HTML5의 Histroy API인
	<a href="https://developer.mozilla.org/ko/docs/Web/API/History_API">
		pushState
	</a>가 모든 브라우저에서 지원이 된다면 해시뱅은 사용하지 않아도 되지만
	현재 pushState는 일부의 브라우저(IE 10 이상)에서만 지원이 가능하다.
</p>

<p>
	또 다른 문제는 <strong>SEO 이슈</strong>이다.
	크롤러는 검색엔진이 웹사이트의 콘텐츠를 수집하기 위해 HTTP 1.1과 URL 스펙(RFC-2396같은)을 따른다.
	이러한 크롤러는 JavaScript를 실행시키지 않기 때문에 hash 방식으로 만들어진 사이트의 콘텐츠를 수집할 수 없다.
	구글은 해시뱅을 일반 URL을 변경시켜 이 문제를 해결한 것으로 알려지지만
	다른 검색 엔진은 hash 방식으로 만들어진 사이트의 콘텐츠를 수집할 수 없다.
</p>

<p>위 예제를 실행하려면 아래의 명령어를 실행한다.</p>

<pre class="mgtbD">
<code class="xmp">
$ npm run hash
</code>
</pre>


<!-- ◇◆◇◆ -->
<h5 class="hb1 h5">3.4 PJAX 방식</h5>


<p>
	hash 방식의 가장 큰 단점은 SEO 이슈이다.
	이를 보완한 방법이 HTML5의 Histroy API인
	<a href="https://developer.mozilla.org/ko/docs/Web/API/History_API">
		pushState
	</a>와
	<a href="https://developer.mozilla.org/ko/docs/Web/Reference/Events/popstate">
		popstate 이벤트
	</a>를
	사용한 PJAX 방식이다.
	pushState와 popstate은 IE 10 이상에서 동작한다.
</p>

<xmp class="xmp">
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>PJAX</title>
  <link rel="stylesheet" href="css/style.css">
  <script src="js/index.js" defer></script>
</head>
<body>
  <nav>
    <ul id="navigation">
      <li><a href="/">Home</a></li>
      <li><a href="/service">Service</a></li>
      <li><a href="/about">About</a></li>
    </ul>
  </nav>
  <div class="app-root">Loading...</div>
</body>
</html>
</xmp>

<p>
	위 예제를 살펴보면 link tag(<code>&lt;a href="/service"&gt;Service&lt;/a&gt;</code> 등)의 href 어트리뷰트에 path를 사용하고 있다.
	내비게이션이 클릭되면 path가 추가된 URI가 서버로 요청된다.
	PJAX 방식은 내비게이션 클릭 이벤트를 캐치하고 preventDefault를 사용하여 서버로의 요청을 방지한다.
	이후, href 어트리뷰트에 path을 사용하여 AJAX 요청을 하는 방식이다.
</p>

<p>
	이때 AJAX 요청은 주소창의 URL을 변경시키지 않아 history 관리가 불가능하다.
	이때 사용하는 것이 pushState 메서드이다.
	<strong>pushState 메서드는 주소창의 URL을 변경하고 URL을 history entry로 추가하지만 요청하지는 않는다.</strong>
</p>

<p>JavaScript의 구현은 아래와 같다.</p>

<pre class="mgtbD">
<code class="xmp">
(function () {
  const root = document.querySelector('.app-root');
  const navigation = document.getElementById('navigation');

  const routes = {
    // path: url
    '/': '/data/home.json',
    '/service': '/data/service.json',
    '/about': '/data/about.html'
  };

  const render = async path =&gt; {
    try {
      const url = routes[path];
      if (!url) {
        root.innerHTML = `${path} Not Found`;
        return;
      }

      const res = await fetch(url);
      const contentType = res.headers.get('content-type');

      if (contentType?.includes('application/json')) {
        const json = await res.json();
        root.innerHTML = `&lt;h1&gt;${json.title}&lt;/h1&gt;&lt;p&gt;${json.content}&lt;/p&gt;`;
      } else {
        root.innerHTML = await res.text();
      }
    } catch (err) {
      console.error(err);
    }
  };

  // popstate 이벤트는 history entry가 변경되면 발생한다.
  // PJAX 방식은 hash를 사용하지 않으므로 hashchange 이벤트를 사용할 수 없다.
  // popstate 이벤트는 pushState에 의해 발생하지 않는다.
  // 이전페이지 / 다음페이지 button 또는 history.back() / history.go(n)에 의해 발생한다.
  window.addEventListener('popstate', e =&gt; {
    // e.state는 pushState 메서드의 첫번째 인수
    console.log('[popstate]', e.state);
    // 이전페이지 / 다음페이지 button이 클릭되면 render를 호출
    render(e.state.path);
  });

  // 네비게이션을 클릭하면 주소창의 url이 변경되므로 HTTP 요청이 서버로 전송된다.
  // preventDefault를 사용하여 이를 방지하고 history 관리를 위한 처리를 실시한다.
  navigation.addEventListener('click', e =&gt; {
    if (!e.target.matches('#navigation &gt; li &gt; a')) return;
    e.preventDefault();
    // 이동 페이지
    const path = e.target.getAttribute('href');

    // 주소창의 url은 변경되지만 HTTP 요청이 서버로 전송되지는 않는다.
    history.pushState({ path }, null, path);
    // path에 의한 AJAX 요청
    render(path);
  });

  // 웹페이지가 처음 로딩되었을 때
  render('/');

  // 새로고침이 클릭되었을 때, 현 페이지(예를 들어 loclahost:5004/service)가 서버에 요청된다.
  // 이에 응답하는 기능이 서버 측에 추가되어야 한다.
}());
</code>
</pre>

<p>
	PJAX 방식은 서버에 새로운 요청을 보내지 않으며 따라서 페이지가 갱신되지 않는다.
	하지만 페이지마다 고유의 URL이 존재하므로 history 관리에 아무런 문제가 없다.
	또한 hash를 사용하지 않으므로 SEO에도 문제가 없다.
</p>

<p>
	다만, 브라우저의 새로고침 버튼을 클릭하면 예를들어 loclahost:5004/service와 같은 요청이 서버로 전달된다.
	이때 서버는 URL에 따라 해당 리소스를 HTML으로 클라이언트에 응답하여야 한다.
</p>

<p>
	이는 <strong>서버 렌더링 방식과 AJAX 방식이 혼재</strong>되어 있는 것이다.
	서버는 클라이언트의 request hader의 Accept가 ‘text/html’이면 HTML을 응답하고,
	request hader의 Accept가 ‘application/json’이면 필요 리소스만 JSON으로 응답하도록 구현하여야 한다.
	예를 들어, 새로고침으로 브라우저에서 요청이 수행되면 request hader의 Accept는
	‘text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,<em>/</em>;q=0.8’이고 서버는 HTML을 응답한다.
	AJAX 요청의 경우,
	<a href="https://developer.mozilla.org/ko/docs/XMLHttpRequest/setRequestHeader">
		setRequestHeader 메서드
	</a>를 사용하여 응답될 데이터의 mine type을 json으로 지정한다.
</p>

<p>이에 대한 구현 예제는 아래와 같다.</p>

<pre class="mgtbD">
<code class="xmp">
// Client
(async () =&gt; {
  const res = await fetch('/service', {
    headers: { 'accept': 'application/json' }
  });

  render(await res.json());
})();
</code>
</pre>

<pre class="mgtbD">
<code class="xmp">
// Server
const express = require('express');
const app = express();
const fs = require('fs');
const path = require('path');

app.get('/service', (req, res) =&gt; {
  res.format({
    // 새로고침에 의한 브라우저 요청
    'text/html': function(){
      res.sendFile(path.join(__dirname + '/public/data/service.html'));
    },
    // AJAX 요청
    'application/json': function(){
      res.send(JSON.parse(fs.readFileSync('./public/data/service.json', 'utf8')));
    },
    'default': function() {
      // log the request and respond with 406
      res.status(406).send('Not Acceptable');
    }
  });
});

app.listen(3000, function () {
  console.log('listening on http//localhost:3000');
});
</code>
</pre>

<p>PJAX 방식의 예제를 실행하려면 아래의 명령어를 실행한다.</p>

<pre class="mgtbD">
<code class="xmp">
$ npm run pjax
</code>
</pre>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">4. Conclusion (결론)</h4>

<p>
	전통적 링크 방식에서 PJAX 방식까지 SPA의 발전 과정을 살펴보았다.
	지금까지 살펴본 4가지 방식을 History 관리, SEO 대응, 사용자 경험 등의 관점에서 정리하면 아래와 같다.
</p>

<table class="t3 w100 ttpdtb1em ttpdlr2pct thcv0 lhD tttac tt1tal ttvam ttwa-small-only">
	<caption>
		<strong class="h1 blind">SPA 4가지 비교</strong>
		<span class="summary1 blind">
			전통적 링크 방식 | AJAX 방식 | Hash 방식 | PJAX 방식
			: 			History 관리, SEO 대응, 사용자 경험, 서버 렌더링, 구현 난이도, IE 대응
		</span>
	</caption>
	<col class="w8em width10em-medium" /><col />
	<thead>
	<tr>
	<th scope="col">구분</th>
	<th scope="col">History 관리</th>
	<th scope="col">SEO 대응</th>
	<th scope="col">사용자 경험</th>
	<th scope="col">서버 렌더링</th>
	<th scope="col">구현 난이도</th>
	<th scope="col">IE 대응</th>
	</tr>
	</thead>
	<tbody>
	<tr>
	<th scope="row">전통적 링크 방식</th>
	<td>◯</td>
	<td>◯</td>
	<td>✗</td>
	<td>◯</td>
	<td>간단</td>
	<td> </td>
	</tr>
	<tr>
	<th scope="row">AJAX 방식</th>
	<td>✗</td>
	<td>✗</td>
	<td>◯</td>
	<td>✗</td>
	<td>보통</td>
	<td>7 이상</td>
	</tr>
	<tr>
	<th scope="row">Hash 방식</th>
	<td>◯</td>
	<td>✗</td>
	<td>◯</td>
	<td>✗</td>
	<td>보통</td>
	<td>8 이상</td>
	</tr>
	<tr>
	<th scope="row">PJAX 방식</th>
	<td>◯</td>
	<td>◯</td>
	<td>◯</td>
	<td>△</td>
	<td>복잡</td>
	<td>10 이상</td>
	</tr>
	</tbody>
</table>

<p>
	모든 소프트웨어 아키텍처에는 절충(trade-off)가 존재한다.
	SPA 또한 모든 애플리케이션에 적합한 은탄환(Silver bullet)은 아니다.
	애플리케이션의 상황을 고려하여 적절한 방법을 선택할 필요가 있다.
</p>


<!-- ◇◆◇◆◇◆ -->
<h4 class="hb1 h4">Reference</h4>


<ul class="bu">
  <li>
    <p><a href="https://developer.mozilla.org/ko/docs/Web/API/History_API">브라우저 히스토리 조작하기</a></p>
  </li>
  <li>
    <p><a href="https://css-tricks.com/using-the-html5-history-api/">Using the HTML5 History API</a></p>
  </li>
  <li>
    <p><a href="https://tutorialzine.com/2015/02/single-page-app-without-a-framework">Making a Single Page App Without a Framework</a></p>
  </li>
  <li>
    <p><a href="https://css-tricks.com/snippets/javascript/get-url-and-url-parts-in-javascript/">Get URL and URL Parts in JavaScript</a></p>
  </li>
  <li>
    <p><a href="https://blog.outsider.ne.kr/698">해시뱅(#!)에 대해서</a></p>
  </li>
  <li>
    <p><a href="https://blog.outsider.ne.kr/1276">AJAX를 사용할 때 웹브라우저 “뒤로 가기”의 구현</a></p>
  </li>
  <li>
    <p><a href="https://developer.mozilla.org/ko/docs/XMLHttpRequest/setRequestHeader">XMLHttpRequest.setRequestHeader()</a></p>
  </li>
</ul>





<br />
<hr class="show" />
<p><small>
<strong>History</strong>
: 20200212~
20201105.
20201104.
20200715.
20200714.
20200212.
</small></p>





<script src="../../share/inc/all_footer.js"></script>
</body>
</html>