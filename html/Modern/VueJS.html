<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<script>/*<![CDATA[*/
var _$ = {
	nowPage: {
		id: [0,1,0,0,0],
		title: 'VueJS', // Home | mNote
		pageType: 'sub',
		layoutType: 'sub'
	}
};
/*]]>*/</script>
<script src="../../share/inc/html_head.js"></script>
</head>
<body>
<script src="../../share/inc/all_header.js"></script>





<!-- ◇◆◇◆◇◆◇◆◇◆◇◆ -->
<h1 class="hb1 h1">VueJS</h1>

<!-- mtab1 -->
<div class="mtab1">
<menu>
<li><a href="#Outline">Outline</a></li>
<li><a href="#Start">Start</a></li>
<li><a href="#Task">Task</a></li>
<li><a href="#Link">Link</a></li>
</menu>
</div>
<!-- /mtab1 -->


<!-- ◇◆ even-grid ◇◆◇◆◇◆◇◆◇◆ -->


<!-- even-grid -->
<div class="even-grid float-left gap30px vgap00">
	<div class="small-12 medium-4 column fr">
		<div class="wrap1">


<!-- ◇◆◇◆◇◆◇◆◇◆ -->
<h2 id="Contents"><!-- (a table of)  -->Contents</h2>
<ol class="bo">
<li>Vue 인스턴스 Instance (실례)</li>
<li>디렉티브 Directive (지시자)</li>
<li>컴포넌트 Component (부품)</li>
<li>computed와 watch (계산된 속성과 감시자)</li>
<li><a href="#animation">트랜지션 & 애니메이션</a></li>
</ol>


<!-- ◇◆◇◆◇◆◇◆◇◆ -->
<h2 id="Link">Link</h2>

<h3 class="hb1 h3">VueJS</h3>

<ol class="bo">
<li><a href="https://kr.vuejs.org/v2/guide/comparison.html" target="_blank" title="새 창">다른 프레임워크와의 비교</a></li>
<li><a href="https://taling.me/Home/Search/" target="_blank" title="새 창">[ 모던웹만들기 ] Node.js + Vue.js 기반의 SPA(SinglePageApplication) 블로그 만들기</a></li>
<li><a href="http://blog.jeonghwan.net/vue/2017/03/29/is-vue-better-than-angular-react.html" target="_blank" title="새 창">과연 Vue.js가 앵귤러나 리엑트보다 좋을까?</a></li>
<li><a href="https://joshua1988.github.io/web-development/translation/why-we-moved-from-angular2-to-vuejs/" target="_blank" title="새 창">Angular 2 대신에 Vue.js를 선택한 이유 (그리고 React를 선택하지 않은 이유)</a></li>
</ol>

<h3 class="hb1 h3">Nearby information</h3>
<ol class="bo">
<li><a href="https://daneden.github.io/animate.css/" target="_blank" title="새 창">Animate.css</a> <small>타사 CSS 애니메이션 라이브러리</small></li>
<li><a href="http://velocityjs.org" target="_blank" title="새 창">Velocity.js</a> <small>써드파티 JavaScript 애니메이션 라이브러리</small></li>
<li><a href="https://github.com/tweenjs/tween.js/" target="_blank" title="새 창">Tween.js</a></li>
<li><a href="https://github.com/Qix-/color" target="_blank" title="새 창">Color.js</a></li>
<li><a href="https://github.com/visionmedia/page.js" target="_blank" title="새 창">page.js</a></li>
<li><a href="https://alibaba.github.io/weex/" target="_blank" title="새 창">Weex</a></li>
</ol>

		</div>
	</div>
	<div class="small-12 medium-8 column">
		<div class="wrap1">


<!-- ◇◆◇◆◇◆◇◆◇◆ -->
<h2 id="Outline">Outline</h2>


<!-- ◇◆◇◆◇◆◇◆ -->
<h1 class="hb1 h1"><a href="https://kr.vuejs.org" target="_blank" title="새 창">Vue.js 공식 가이드</a></h1>
----1D(8H)20180410.09:00~18:00
----1D(8H)20181121.09:00~18:00

<!-- ◇◆◇◆◇◆◇◆ -->
<h2 class="hb1 h2">필수요소</h2>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">설치방법</h3>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">시작하기</h3>

<a href="https://jsfiddle.net/chrisvfritz/50wL7mdz/" target="_blank" rel="noopener">JSFiddle Hello World 예제</a>

<xmp class="xmp">
<script src="https://unpkg.com/vue"></script>

<div id="app">
  {{ message }}
</div>

<script>/*<![CDATA[*/
var app = new Vue({
  el: '#app',
  data: {
    message: 'Hello Vue.js!'
  }
})
/*]]>*/</script>
</xmp>

<pre class="mg0">
<code>v-bind:</code>title="message"
<code>v-if</code>="seen"
	app3.seen = false
<code>v-for</code>="todo in todos"
	app4.todos.push({ text: 'New item' })
<code>v-on:click</code>="reverseMessage"
<code>v-model</code>="message"
</pre>

<p>컴파일 안한 코드는 당연히 디렉티브 v- 속성이 마크업 유효성 검사 통과하지 못한다.</p>


<!-- ◇◆◇◆◇◆◇◆ -->
<h4 class="hb1 h4">컴포넌트 Component 부품</h4>

<p>컴포넌트는 본질적으로 미리 정의된 옵션을 가진 Vue 인스턴스 입니다.</p>


<h5 class="hb1 h5">Props</h5>

<xmp class="xmp">
<div id="app-7">
  <ol>
    <!-- 
      이제 각 todo-item 에 todo 객체를 제공합니다.
      화면에 나오므로, 각 항목의 컨텐츠는 동적으로 바뀔 수 있습니다. 
      또한 각 구성 요소에 "키"를 제공해야합니다 (나중에 설명 됨).
     -->
    <todo-item
      v-for="item in groceryList"
      v-bind:todo="item"
      v-bind:key="item.id">
    </todo-item>
  </ol>
</div>
</xmp>
<xmp class="xmp">
Vue.component('todo-item', {
  props: ['todo'],
  template: '<li>{{ todo.text }}</li>'
})

var app7 = new Vue({
  el: '#app-7',
  data: {
    groceryList: [
      { id: 0, text: 'Vegetables' },
      { id: 1, text: 'Cheese' },
      { id: 2, text: 'Whatever else humans are supposed to eat' }
    ]
  }
})
</xmp>
<samp class="xmp">
  1. Vegetables
  2. Cheese
  3. Whatever else humans are supposed to eat
</samp>

이것은 인위적으로 만든 예시이지만, 우리는 앱을 두 개의 더 작은 단위로 나눌 수 있었고,
자식을 props 인터페이스를 통하여 부모로부터 합리적인 수준으로 분리할 수 있었습니다.
<em class="em">이제 앞으로는 부모 앱에 영향을 주지 않으면서 &lt;todo-item&gt; 컴포넌트를 더 복잡한 템플릿과 로직으로 더욱 향상시킬 수 있을 것입니다.</em>

<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">Vue 인스턴스 Instance</h3>

<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">템플릿 문법</h3>


<pre class="mg0">
보간법(Interpolation)
	문자열
	원시 HTML
	JavaScript 표현식 사용
디렉티브
	전달인자
	수식어
약어
	v-bind 약어
	v-on 약어
</pre>

<xmp class="xmp">
<!-- 전체 문법 -->
<a v-bind:href="url"> ... </a>

<!-- 약어 -->
<a :href="url"> ... </a>
</xmp>

<xmp class="xmp">
<!-- 전체 문법 -->
<a v-on:click="doSomething"> ... </a>

<!-- 약어 -->
<a @click="doSomething"> ... </a>
</xmp>

<p>:와 @는 ..  <em class="em">최종 렌더링 된 마크업에는 나타나지 않습니다.</em></p>


<h3 class="hb1 h3">computed와 watch (계산된 속성과 감시자)</h3>

계산된 속성
	기본 예제
		<code>computed: {}</code>

<xmp class="xmp">
<div id="example">
  <p>원본 메시지: "{{ message }}"</p>
  <p>뒤집히도록 계산된 메시지: "{{ reversedMessage }}"</p>
</div>
</xmp>
<xmp class="xmp">
var vm = new Vue({
  el: '#example',
  data: {
    message: '안녕하세요'
  },
  computed: {
    // 계산된 getter
    reversedMessage: function () {
      // `this` 는 vm 인스턴스를 가리킵니다.
      return this.message.split('').reverse().join('')
    }
  }
})
</xmp>


<!-- ◇◆◇◆◇◆◇◆ -->
<h4 class="hb1 h4">computed 속성의 캐싱 vs methods</h4>

	<code>computed: {}</code><br />
	<code>methods: {}</code><br />

	<em class="em">computed 속성은 해당 속성이 종속된 대상이 변경될 때만 함수를 실행합니다.</em><br />
	즉 message가 변경되지 않는 한,	computed 속성인 reversedMessage를 여러 번 요청해도 계산을 다시 하지 않고 계산되어 있던 결과를 즉시 반환합니다.<br />
	이에 비해 <em class="em">methods 를 호출하면 렌더링을 다시 할 때마다 항상 함수를 실행</em>합니다.<br />
	캐싱을 원하지 않는 경우 methods 를 사용하십시오.<br />



<h4 class="hb1 h4">computed 속성 vs watch 속성</h4>

<h4 class="hb1 h4">computed 속성의 setter 함수</h4>

<h4 class="hb1 h4">watch 속성</h4>

	<code>watch: {}</code>

<xmp class="xmp">
<script src="https://unpkg.com/axios@0.12.0/dist/axios.min.js"></script>
<script src="https://unpkg.com/lodash@4.13.1/lodash.min.js"></script>
</xmp>




<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">클래스와 스타일 바인딩</h3>

class와 style에 v-bind를 사용할 때 특별히 향상된 기능을 제공합니다.<br />
표현식은 문자열 이외에 객체 또는 배열을 이용할 수 있습니다.<br />

<h4 class="hb1 h4">HTML 클래스 바인딩하기</h4>

	<h5 class="hb1 h5">객체 구문</h5>
		<code>v-bind:class="{ active: isActive, 'text-danger': hasError }"</code>

	<h5 class="hb1 h5">배열 구문</h5>
		<code>v-bind:class="[activeClass, errorClass]"</code><br />
		<code>v-bind:class="[{ active: isActive }, errorClass]"</code><br />

	<h5 class="hb1 h5">컴포넌트와 함께 사용하는 방법</h5>

<xmp class="xmp">
Vue.component('my-component', {
  template: '<p class="foo bar">Hi</p>'
})
</xmp>
<xmp class="xmp">
<my-component class="baz boo"></my-component>
</xmp>
<xmp class="xmp">
<my-component v-bind:class="{ active: isActive }"></my-component>
</xmp>

<h4 class="hb1 h4">인라인 스타일 바인딩</h4>

	객체 구문
	<code>v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }</code>
	<br />
	배열 구문
	<code>v-bind:style="[baseStyles, overridingStyles]"</code>
	<br />
	자동 접두사
	<br />
	다중 값 제공
	<code>v-bind:style="{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }"</code>
	<br />


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">조건부 렌더링</h3>

<h4 class="hb1 h4">v-if</h4>
	
<h5 class="hb1 h5"><code>&lt;template&gt;</code>에 v-if을 갖는 조건부 그룹 만들기</h5>

v-if는 디렉티브기 때문에 하나의 엘리먼트에 추가해야합니다.<br />
하지만 하나 이상의 엘리먼트를 트랜지션하려면 어떻게 해야할까요?<br />
이 경우 우리는 보이지 않는 래퍼 역할을 하는 <code>&lt;template&gt;</code> 엘리먼트에 v-if를 사용할 수 있습니다.<br />
최종 렌더링 결과에는 <code>&lt;template&gt;</code> 엘리먼트가 포함되지 않습니다.<br />

<xmp class="xmp">
<template v-if="ok">
  <h1>Title</h1>
  <p>Paragraph 1</p>
  <p>Paragraph 2</p>
</template>
</xmp>

<h5 class="hb1 h5">v-else</h5>

<p>v-else 엘리먼트는 v-if 엘리먼트 또는 v-else-if 엘리먼트 바로 뒤에 있어야 합니다. 그렇지 않으면 인식할 수 없습니다.</p>

<h5 class="hb1 h5">v-else-if</h5>

<p>v-else와 마찬가지로, v-else-if 엘리먼트는 v-if 또는 v-else-if 엘리먼트 바로 뒤에 와야 합니다.</p>

<h5 class="hb1 h5">key 를 이용한 재사용 가능한 엘리먼트 제어</h5>

<h4 class="hb1 h4">v-show</h4>

엘리먼트를 조건부로 표시하기 위한 또 다른 옵션은 v-show 디렉티브입니다. 사용법은 거의 동일합니다.<br />
차이점은 v-show가 있는 엘리먼트는 항상 렌더링 되고 DOM에 남아있다는 점입니다.<br />
v-show는 단순히 엘리먼트에 display CSS 속성을 토글합니다.<br />

<p>v-show는 <code>&lt;template&gt;</code> 구문을 지원하지 않으며 v-else와도 작동하지 않습니다.</p>

<h4 class="hb1 h4">v-if vs v-show</h4>

일반적으로 v-if는 토글 비용이 높고 v-show는 초기 렌더링 비용이 더 높습니다.<br />
매우 자주 바꾸기를 원한다면 v-show를, 런타임 시 조건이 바뀌지 않으면 v-if를 권장합니다.<br />

<h4 class="hb1 h4">v-if 와 v-for</h4>

<p>v-if와 함께 사용하는 경우, v-for는 v-if보다 높은 우선순위를 갖습니다.</p>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">리스트 렌더링</h3>

<h4 class="hb1 h4">v-for로 엘리먼트에 배열 매핑하기</h4>

<p>
	<code>v-for</code> 디렉티브를 사용하여 배열을 기반으로 리스트를 렌더링 할 수 있습니다.<br />
	<code>v-for</code> 디렉티브는 <code>item in items</code> 형태로 특별한 문법이 필요합니다.<br />
	여기서 <code>items</code>는 원본 데이터 배열이고 <code>item</code>은 반복되는 배열 엘리먼트의 <strong>별칭</strong> 입니다.<br />
</p>


<h5 class="hb1 h5">기본 사용방법</h5>

<code>v-for="item in items"</code><br />
<code>v-for="(item, index) in items"</code><br />
<code>v-for="item of items"</code><br />

<h4 class="hb1 h4">v-for와 객체</h4>

<code>v-for="value in object"</code><br />
<code>v-for="(value, key) in object"</code><br />
<code>v-for="(value, key, index) in object"</code><br />

<h4 class="hb1 h4">key</h4>

<h4 class="hb1 h4">배열 변경 감지</h4>

<h5 class="hb1 h5">변이 메소드</h5>

push()
pop()
shift()
unshift()
splice()
sort()
reverse()

<h5 class="hb1 h5">배열 대체</h5>

filter(), concat() 와 slice()

<h5 class="hb1 h5">주의 사항</h5>

<p>JavaScript의 제한으로 인해 Vue는 배열에 대해 다음과 같은 변경 사항을 감지할 수 없습니다.</p>

<ol>
<li>인덱스로 배열에 있는 항목을 직접 설정하는 경우, 예: <code>vm.items[indexOfItem] = newValue</code></li>
<li>배열 길이를 수정하는 경우, 예: <code>vm.items.length = newLength</code></li>
</ol>

<h4 class="hb1 h4">객체 변경 감지에 관한 주의사항</h4>

<p>모던 JavaScript의 한계로 Vue는 속성 추가 및 삭제를 감지하지 못합니다.</p>

<p>
	Vue는 이미 만들어진 인스턴스에 새로운 루트레벨의 반응형 속성을 동적으로 추가하는 것을 허용하지 않습니다.<br />
	그러나 <code>Vue.set(object, key, value)</code> 메소드를 사용하여 중첩된 객체에 반응형 속성을 추가할 수 있습니다.<br />
</p>


<h4 class="hb1 h4">필터링 / 정렬 된 결과 표시하기</h4>

<p>
	때로 원본 데이터를 실제로 변경하거나 재설정하지 않고 배열의 필터링 된 버전이나 정렬된 버전을 표시해야 할 필요가 있습니다.
	이 경우 필터링 된 배열이나 정렬된 배열을 반환하는 계산된 속성을 만들 수 있습니다.
</p>

<h4 class="hb1 h4">Range v-for</h4>

<p><code>v-for</code> 는 숫자를 사용할 수 있습니다. 이 경우 템플릿을 여러번 반복합니다.</p>

<xmp class="xmp">
<div>
  <span v-for="n in 10">{{ n }} </span>
</div>
</xmp>
결과: 1 2 3 4 5 6 7 8 9 0

<h4 class="hb1 h4">v-for 템플릿</h4>

<p>
	템플릿 <code>v-if</code>와 마찬가지로,
	<code>&lt;template&gt;</code>태그를 사용해 여러 엘리먼트의 블럭을 렌더링 할 수 있습니다.
</p>

<xmp class="xmp">
<ul>
  <template v-for="item in items">
    <li>{{ item.msg }}</li>
    <li class="divider"></li>
  </template>
</ul>
</xmp>

<h4 class="hb1 h4">v-for 와 v-if</h4>

<p>
	동일한 노드에 두가지 모두 있다면,
	<code>v-for</code>가 <code>v-if</code>보다 높은 우선순위를 갖습니다.
	즉, <code>v-if</code>는 루프가 반복될 때마다 실행됩니다.
	이는 _일부_ 항목만 렌더링 하려는 경우 유용합니다.
</p>

<xmp class="xmp">
<li v-for="todo in todos" v-if="!todo.isComplete">
  {{ todo }}
</li>
</xmp>

<p>위의 경우 완료되지 않은 할일만 렌더링합니다.</p>
<p>
	위 방법 대신 실행을 조건부로 하는 것이 목적이라면
	래퍼 엘리먼트(또는 <a href="conditional.html#Conditional-Groups-with-v-if-on-lt-template-gt"><code>&lt;template&gt;</code></a>)을 사용하세요.
</p>

<xmp class="xmp">
<ul v-if="todos.length">
  <li v-for="todo in todos">
    {{ todo }}
  </li>
</ul>
<p v-else>No todos left!</p>
</xmp>


<h4 class="hb1 h4">v-for 와 컴포넌트</h4>

<p>간단한 할일 목록 전체 예제 입니다.</p>

HTML
<xmp class="xmp">
<div id="todo-list-example">
  <input
    v-model="newTodoText"
    v-on:keyup.enter="addNewTodo"
    placeholder="Add a todo"
  >
  <ul>
    <li
      is="todo-item"
      v-for="(todo, index) in todos"
      v-bind:key="todo.id"
      v-bind:title="todo.title"
      v-on:remove="todos.splice(index, 1)"
    ></li>
  </ul>
</div>
</xmp>

<p class="tip">
	<code>is="todo-item"</code> 속성을 보면 <code>&lt;li&gt;</code> 엘리먼트는 <code>&lt;ul&gt;</code> 안에서만 유효합니다.<br />
	<code>&lt;todo-item&gt;</code>과 같은 일을 하지만 잠재적인 브라우저의 구문 분석 오류를 해결 합니다.<br />
	자세한 내용은 <a href="components.html#DOM-Template-Parsing-Caveats">DOM 템플릿 파싱 주의사항</a>을 참조하세요.<br />
</p>

JS
<xmp class="xmp">
Vue.component('todo-item', {
  template: '\
    <li>\
      {{ title }}\
      <button v-on:click="$emit(\'remove\')">X</button>\
    </li>\
  ',
  props: ['title']
})

new Vue({
  el: '#todo-list-example',
  data: {
    newTodoText: '',
    todos: [
      {
        id: 1,
        title: 'Do the dishes',
      },
      {
        id: 2,
        title: 'Take out the trash',
      },
      {
        id: 3,
        title: 'Mow the lawn'
      }
    ],
    nextTodoId: 4
  },
  methods: {
    addNewTodo: function () {
      this.todos.push({
        id: this.nextTodoId++,
        title: this.newTodoText
      })
      this.newTodoText = ''
    }
  }
})
</xmp>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">이벤트 핸들링</h3>


<h4 class="hb1 h4">이벤트 청취</h4>

<xmp class="xmp">
<button v-on:click="counter += 1">Add 1</button>
</xmp>


<h4 class="hb1 h4">메소드 이벤트 핸들러</h4>

<xmp class="xmp">
<button v-on:click="greet">Greet</button>
</xmp>


<h4 class="hb1 h4">인라인 메소드 핸들러</h4>

<xmp class="xmp">
<button v-on:click="say('hi')">Say hi</button>
<button v-on:click="say('what')">Say what</button>
</xmp>

<p>
	때로 인라인 명령문 핸들러에서 원본 DOM 이벤트에 액세스 해야할 수도 있습니다.<br />
	특별한 <code>$event</code> 변수를 사용해 메소드에 전달할 수도 있습니다.<br />
</p>

HTML
<xmp class="xmp">
<button v-on:click="warn('Form cannot be submitted yet.', $event)">
  Submit
</button>
</xmp>

JS
<xmp class="xmp">
// ...
methods: {
  warn: function (message, event) {
    // 이제 네이티브 이벤트에 액세스 할 수 있습니다
    if (event) event.preventDefault()
    alert(message)
  }
}
</xmp>


<h4 class="hb1 h4">이벤트 수식어</h4>

<xmp class="xmp">
<!-- 클릭 이벤트 전파가 중단됩니다 -->
<a v-on:click.stop="doThis"></a>

<!-- 제출 이벤트가 페이지를 다시 로드 하지 않습니다 -->
<form v-on:submit.prevent="onSubmit"></form>

<!-- 수식어는 체이닝 가능합니다 -->
<a v-on:click.stop.prevent="doThat"></a>

<!-- 단순히 수식어만 사용할 수 있습니다 -->
<form v-on:submit.prevent></form>

<!-- 이벤트 리스너를 추가할 때 캡처모드를 사용합니다 -->
<!-- 즉, 내부 엘리먼트를 대상으로 하는 이벤트가 해당 엘리먼트에서 처리되기 전에 여기서 처리합니다. -->
<div v-on:click.capture="doThis">...</div>


<!-- event.target이 엘리먼트 자체인 경우에만 트리거를 처리합니다 -->
<!-- 자식 엘리먼트에서는 안됩니다 -->
<div v-on:click.self="doThat">...</div>

<!-- 클릭 이벤트는 최대 한번만 트리거 됩니다. -->
<a v-on:click.once="doThis"></a>

<!-- 스크롤의 기본 이벤트를 취소할 수 없습니다. -->
<div v-on:scroll.passive="onScroll">...</div>
</xmp>


<h4 class="hb1 h4">키 수식어</h4>

<xmp class="xmp">
<!-- keyCode가 13일 때만 `vm.submit()`을 호출합니다  -->
<input v-on:keyup.13="submit">
</xmp>

<p><code>keyCode</code>를 모두 기억하는 것은 힘듭니다. 그래서 Vue는 자주 사용하는 키의 알리아스를 제공합니다.</p>

<xmp class="xmp">
<!-- 위와 같습니다 -->
<input v-on:keyup.enter="submit">

<!-- 약어 사용도 가능합니다 -->
<input @keyup.enter="submit">
</xmp>

<p>키 수식어 별칭의 전체 목록입니다.</p>

<ul>
<li><code>.enter</code></li>
<li><code>.tab</code></li>
<li><code>.delete</code> (“Delete” 와 “Backspace” 키 모두를 캡처합니다)</li>
<li><code>.esc</code></li>
<li><code>.space</code></li>
<li><code>.up</code></li>
<li><code>.down</code></li>
<li><code>.left</code></li>
<li><code>.right</code></li>
</ul>

<p>
	또한 전역 <code>config.keyCodes</code> 객체를 통해
	<a href="../api/#keyCodes">사용자 지정 키 수식어 별칭을 지정할 수 있습니다.</a>
</p>

<xmp class="xmp">
// `v-on:keyup.f1`을 사용할 수 있습니다.
Vue.config.keyCodes.f1 = 112
</xmp>


<h5 class="hb1 h5">오토매틱 키 수식어</h5>

<p>
	<a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values" target="_blank" rel="noopener">
		<code>KeyboardEvent.key</code>
	</a>
	를 통해 노출된 유효 키 이름을 수식어로 직접 사용할 수 있습니다.
</p>

<p class="tip">
	일부 키(<code>.esc</code>와 모든 화살표 키)는
	IE9에서 일관성 없는 <code>key</code> 값을 가지고 있습니다.
	IE9를 지원해야하는 경우 내장 알리아스가 선호됩니다.
</p>


<h4 class="hb1 h4">시스템 수식어 키 목록</h4>

<p>다음 수식어를 사용해 해당 수식어 키가 눌러진 경우에만 마우스 또는 키보드 이벤트 리스너를 트리거 할 수 있습니다.</p>

<ul>
<li><code>.ctrl</code></li>
<li><code>.alt</code></li>
<li><code>.shift</code></li>
<li><code>.meta</code></li>
</ul>

<xmp class="xmp">
<!-- Alt + C -->
<input @keyup.alt.67="clear">

<!-- Ctrl + Click -->
<div @click.ctrl="doSomething">Do something</div>
</xmp>


<h5 class="hb1 h5"><code>.exact</code> 수식어</h5>

<p>
	<code>.exact</code> 수식어는
	다른 시스템 수식어와 조합해 그 핸들러가 실행되기 위해 정확한 조합이 눌러야하는 것을 보여줍니다.
</p>

<xmp class="xmp">
<!-- Alt 또는 Shift와 함께 눌린 경우에도 실행됩니다. -->
<button @click.ctrl="onClick">A</button>

<!-- Ctrl 키만 눌려있을 때만 실행됩니다. -->
<button @click.ctrl.exact="onCtrlClick">A</button>

<!-- 아래 코드는 시스템 키가 눌리지 않은 상태인 경우에만 작동합니다. -->
<button @click.exact="onClick">A</button>
</xmp>


<h5 class="hb1 h5">마우스 버튼 수식어</h5>

<ul>
<li><code>.left</code></li>
<li><code>.right</code></li>
<li><code>.middle</code></li>
</ul>

<p>위 수정자는 특정 마우스 버튼에 의해 트리거 된 이벤트로 핸들러를 제한합니다.</p>


<h4 class="hb1 h4">왜 HTML로 된 리스너를 사용합니까</h4>

<p>이 모든 이벤트 청취 접근 방법이
	우려 사항 분리(“separation of concerns”)에 대한 오래된 규칙을 어긴다고 생각할 수 있습니다.
	모든 뷰 핸들러 함수와 표현식은 현재 뷰 처리 하는 ViewModel에 엄격히 바인딩 되기 때문에 유지보수가 어렵지 않습니다.
	실제로 <code>v-on</code>을 사용하면 몇가지 이점이 있습니다.
</p>

<ol>
<li><p>HTML 템플릿을 간단히 하여 JavaScript 코드 내에서 핸들러 함수 구현을 찾는 것이 더 쉽습니다.</p>
</li>
<li><p>JavaScript에서 이벤트 리스너를 수동으로 연결할 필요가 없으므로 ViewModel 코드는 순수 로직과 DOM이 필요하지 않습니다. 이렇게 하면 테스트가 쉬워집니다.</p>
</li>
<li><p>ViewModel이 파기되면 모든 이벤트 리스너가 자동으로 제거 됩니다. 이벤트 제거에 대한 걱정이 필요 없어집니다.</p>
</li>
</ol>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">폼 입력 바인딩</h3>


<h4 class="hb1 h4">기본 사용법</h4>

<p>
	<code>v-model</code> 디렉티브를 사용하여 폼 input과 textarea 엘리먼트에 양방향 데이터 바인딩을 생성할 수 있습니다.<br />
	입력 유형에 따라 엘리먼트를 업데이트 하는 올바른 방법을 자동으로 선택합니다.<br />
	약간 이상하지만 <code>v-model</code>은 기본적으로 사용자 입력 이벤트에 대한 데이터를 업데이트하는 “syntax sugar”이며 일부 경우에 특별한 주의를 해야합니다.<br />
</p>

<p class="tip">
	<code>v-model</code>은 모든 form 엘리먼트의 초기 <code>value</code>와 <code>checked</code> 그리고 <code>selected</code> 속성을 무시합니다.<br />
	항상 Vue 인스턴스 데이터를 원본 소스로 취급합니다.<br />
	컴포넌트의 <code>data</code> 옵션 안에 있는 JavaScript에서 초기값을 선언해야합니다.<br />
</p>

<p class="tip" id="vmodel-ime-tip">
	<a href="https://en.wikipedia.org/wiki/Input_method" target="_blank" rel="noopener">IME</a> (중국어, 일본어, 한국어 등)가 필요한 언어의 경우<br />
	IME 중 <code>v-model</code>이 업데이트 되지 않습니다.<br />
	이러한 업데이트를 처리하려면 <code>input</code> 이벤트를 대신 사용하십시오.<br />
</p>


<h5 class="hb1 h5">문자열</h5>

<xmp class="xmp">
<input v-model="message" placeholder="여기를 수정해보세요">
<p>메시지: {{ message }}</p>
</xmp>

<h5 class="hb1 h5">여러줄을 가진 문장</h5>

<xmp class="xmp">
<span>여러 줄을 가지는 메시지:</span>
<p style="white-space: pre-line">{{ message }}</p>
<br>
<textarea v-model="message" placeholder="여러줄을 입력해보세요"></textarea>
</xmp>

<h5 class="hb1 h5">체크박스</h5>

<xmp class="xmp">
<input type="checkbox" id="checkbox" v-model="checked">
<label for="checkbox">{{ checked }}</label>
</xmp>

<p>여러개의 체크박스는 같은 배열을 바인딩 할 수 있습니다</p>

<xmp class="xmp">
<div id='example-3'>
  <input type="checkbox" id="jack" value="Jack" v-model="checkedNames">
  <label for="jack">Jack</label>
  <input type="checkbox" id="john" value="John" v-model="checkedNames">
  <label for="john">John</label>
  <input type="checkbox" id="mike" value="Mike" v-model="checkedNames">
  <label for="mike">Mike</label>
  <br>
  <span>체크한 이름: {{ checkedNames }}</span>
</div>
</xmp>

<xmp class="xmp">
new Vue({
  el: '#example-3',
  data: {
    checkedNames: []
  }
})
</xmp>

<h5 class="hb1 h5">라디오</h5>

<xmp class="xmp">
<input type="radio" id="one" value="One" v-model="picked">
<label for="one">One</label>
<br>
<input type="radio" id="two" value="Two" v-model="picked">
<label for="two">Two</label>
<br>
<span>선택: {{ picked }}</span>
</xmp>

<h5 class="hb1 h5">셀렉트</h5>

<xmp class="xmp">
<select v-model="selected">
  <option disabled value="">Please select one</option>
  <option>A</option>
  <option>B</option>
  <option>C</option>
</select>
<span>선택함: {{ selected }}</span>
</xmp>

<xmp class="xmp">
new Vue({
  el: '...',
  data: {
    selected: ''
  }
})
</xmp>

<p><code>v-for</code>를 이용한 동적 옵션 렌더링</p>

<xmp class="xmp">
<select v-model="selected">
  <option v-for="option in options" v-bind:value="option.value">
    {{ option.text }}
  </option>
</select>
<span>Selected: {{ selected }}</span>
</xmp>

<xmp class="xmp">
new Vue({
  el: '...',
  data: {
    selected: 'A',
    options: [
      { text: 'One', value: 'A' },
      { text: 'Two', value: 'B' },
      { text: 'Three', value: 'C' }
    ]
  }
})
</xmp>


<h4 class="hb1 h4">값 바인딩하기</h4>

<h5 class="hb1 h5">체크박스</h5>
<h5 class="hb1 h5">라디오</h5>
<h5 class="hb1 h5">셀렉트 옵션</h5>

<h4 class="hb1 h4">수식어</h4>

<h5 class="hb1 h5">.lazy</h5>

<p>
	기본적으로, <code>v-model</code>은 각 입력 이벤트 후 입력과 데이터를 동기화 합니다.<br />
	(단 <a href="#vmodel-ime-tip">앞에서 설명</a>한 IME 구성은 제외됩니다.)<br />
	<code>.lazy</code> 수식어를 추가하여 <code>change</code> 이벤트 이후에 동기화 할 수 있습니다.<br />
</p>

<xmp class="xmp">
<!-- "input" 대신 "change" 이후에 동기화 됩니다. -->
<input v-model.lazy="msg" >
</xmp>

<h5 class="hb1 h5">.number</h5>

<p>
	사용자 입력이 자동으로 숫자로 형변환 되기를 원하면,<br />
	<code>v-model</code>이 관리하는 input에 <code>number</code> 수식어를 추가하면 됩니다.<br />
</p>

<xmp class="xmp">
<input v-model.number="age" type="number">
</xmp>

<p>
	<code>type="number"</code>를 사용하는 경우에도<br />
	HTML 입력 엘리먼트의 값은 항상 문자열을 반환하기 때문에<br />
	이것은 종종 유용하게 사용할 수 있습니다.<br />
</p>

<h5 class="hb1 h5">.trim</h5>

<p>
	<code>v-model</code>이 관리하는 input을 자동으로 trim 하기 원하면,
	<code>trim</code> 수정자를 추가하면 됩니다.
</p>

<xmp class="xmp">
<input v-model.trim="msg">
</xmp>


<h4 class="hb1 h4">v-model 과 컴포넌트</h4>

<p>
	HTML의 기본 제공 input 유형이 항상 사용자의 요구를 만족시킬 수는 없습니다.<br />
	다행히 Vue 컴포넌트를 사용하면 완전히 사용자 정의 된 동작으로 재사용 가능한 input을 만들 수 있습니다.<br />
	이 input은 <code>v-model</code>에도 작동합니다!<br />
	자세한 컴포넌트 가이드의 <a href="components.html#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98-v-model-%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98">사용자 정의 입력</a>을 참조하십시오.
</p>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">컴포넌트</h3>

<h4 class="hb1 h4">컴포넌트가 무엇인가요?</h4>

<p>
	컴포넌트는 Vue의 가장 강력한 기능 중 하나입니다.<br />
	기본 HTML 엘리먼트를 확장하여 재사용 가능한 코드를 캡슐화하는 데 도움이 됩니다.<br />
	상위 수준에서 컴포넌트는 Vue의 컴파일러에 의해 동작이 추가된 사용자 지정 엘리먼트입니다.<br />
	경우에 따라 특별한 <code>is</code> 속성으로 확장 된 원시 HTML 엘리먼트로 나타날 수도 있습니다.<br />
</p>

<p>
	Vue 컴포넌트는 Vue 인스턴스이기도 합니다.<br />
	그러므로 모든 옵션 객체를 사용할 수 있습니다. (루트에만 사용하는 옵션은 제외)<br />
	그리고 같은 라이프사이클 훅을 사용할 수 있습니다.<br />
</p>

<h4 class="hb1 h4">컴포넌트 사용하기</h4>

<h5 class="hb1 h5">전역 등록</h5>

<p>이전 섹션에서 다음을 사용하여 새 Vue 인스턴스를 만들 수 있음을 알게 되었습니다.</p>

<xmp class="xmp">
new Vue({
  el: '#some-element',
  // 옵션
})
</xmp>

<p>전역 컴포넌트를 등록하려면, <code>Vue.component(tagName, options)</code>를 사용합니다.</p>

<xmp class="xmp">
Vue.component('my-component', {
  // 옵션
})
</xmp>

<p class="tip">
	Vue는 사용자 지정 태그 이름에 대해 <a href="http://www.w3.org/TR/custom-elements/#concepts" target="_blank" rel="noopener">W3C 규칙</a>을 적용하지 않습니다
	(모두 소문자이어야 하고 하이픈을 포함해야합니다).<br />
	그러나 이 규칙을 따르는 것이 좋습니다.<br />
</p>

<xmp class="xmp">
<div id="example">
  <my-component></my-component>
</div>
</xmp>

<xmp class="xmp">
// 등록
Vue.component('my-component', {
  template: '<div>사용자 정의 컴포넌트 입니다!</div>'
})

// 루트 인스턴스 생성
new Vue({
  el: '#example'
})
</xmp>

<p>아래와 같이 렌더링 됩니다.</p>

<xmp class="xmp">
<div id="example">
  <div>사용자 정의 컴포넌트 입니다!</div>
</div>
</xmp>


<h5 class="hb1 h5">지역 등록</h5>

<xmp class="xmp">
var Child = {
  template: '<div>사용자 정의 컴포넌트 입니다!</div>'
}

new Vue({
  // ...
  components: {
    // <my-component> 는 상위 템플릿에서만 사용할 수 있습니다.
    'my-component': Child
  }
})
</xmp>


<h5 class="hb1 h5">DOM 템플릿 구문 분석 경고</h5>

<p>
	<code>&lt;ul&gt;</code>,<code>&lt;ol&gt;</code>,<code>&lt;table&gt;</code>과<code>&lt;select&gt;</code>와 같은 일부 엘리먼트는 그 안에 어떤 엘리먼트가 나타날 수 있는지에 대한 제한을 가지고 있으며,<br />
	<code>&lt;option&gt;</code>과 같이 특정 다른 엘리먼트 안에만 나타날 수 있습니다.<br />
</p>

<p>이러한 제한이 있는 엘리먼트가 있는 사용자 지정 컴포넌트를 사용하면 다음과 같은 문제가 발생할 수 있습니다.</p>

<xmp class="xmp">
<table>
  <my-row>...</my-row>
</table>
</xmp>

<p>
	사용자 지정 컴포넌트 <code>&lt;my-row&gt;</code> 는 잘못 된 컨텐츠가 되어,
	결과적으로 렌더링시 에러를 발생시킵니다. 해결 방법은 <code>is</code> 특수 속성을 사용하는 것입니다 :<br />
</p>

<xmp class="xmp">
<table>
  <tr is="my-row"></tr>
</table>
</xmp>


<h5 class="hb1 h5">data 는 반드시 함수여야합니다.</h5>

<xmp class="xmp">
data: function () {
  return {
    counter: 0
  }
}
</xmp>



<h5 class="hb1 h5">컴포넌트 작성</h5>

<h4 class="hb1 h4">Props</h4>

<h5 class="hb1 h5">Props로 데이터 전달하기</h5>

<p>
	모든 컴포넌트 인스턴스에는 자체 <strong>격리 된 범위</strong> 가 있습니다.<br />
	즉, 하위 컴포넌트의 템플릿에서 상위 데이터를 직접 참조 할 수 없으며 그렇게 해서는 안됩니다.<br />
	데이터는 <a href="../api/#props"><code>props</code> 옵션</a> 을 사용하여 하위 컴포넌트로 전달 될 수 있습니다.<br />
</p>

<h5 class="hb1 h5">camelCase vs. kebab-case</h5>

<p>
	HTML 속성은 대소 문자를 구분하지 않으므로 문자열이 아닌 <em class="em">템플릿을 사용할 때</em><br />
	camelCased prop 이름에 해당하는 <em class="em">kebab-case(하이픈 구분)를 사용해야 합니다.</em><br />
</p>

<h5 class="hb1 h5">동적 Props</h5>

<xmp class="xmp">
<div>
  <input v-model="parentMsg">
  <br>
  <child v-bind:my-message="parentMsg"></child>
</div>
</xmp>

<h5 class="hb1 h5">리터럴 vs. 동적</h5>

<xmp class="xmp">
<!-- 이것은 일반 문자열 "1"을 전달합니다. -->
<comp some-prop="1"></comp>

<!-- 이것은 실제 숫자로 전달합니다. -->
<comp v-bind:some-prop="1"></comp>
</xmp>


<h5 class="hb1 h5">단방향 데이터 흐름</h5>

<h5 class="hb1 h5">Prop 검증</h5>

<h4 class="hb1 h4">Props가 아닌 속성</h4>

<h5 class="hb1 h5">존재하는 속성 교체/병합</h5>
<h5 class="hb1 h5">v-on을 이용한 사용자 지정 이벤트</h5>
<h5 class="hb1 h5">.sync 수식어</h5>
<h5 class="hb1 h5">사용자 정의 이벤트를 사용하여 폼 입력 컴포넌트 만들기</h5>
<h5 class="hb1 h5">컴포넌트의 v-model 사용자 정의</h5>
<h5 class="hb1 h5">비 부모-자식간 통신</h5>

<h4 class="hb1 h4">슬롯을 사용한 컨텐츠 배포</h4>

<h5 class="hb1 h5">범위 컴파일</h5>
<h5 class="hb1 h5">단일 슬롯</h5>
<h5 class="hb1 h5">이름을 가지는 슬롯</h5>
<h5 class="hb1 h5">범위를 가지는 슬롯</h5>

<h4 class="hb1 h4">동적 컴포넌트</h4>

<h5 class="hb1 h5">keep-alive</h5>

<h4 class="hb1 h4">기타</h4>

<h5 class="hb1 h5">재사용 가능한 컴포넌트 제작하기</h5>
<h5 class="hb1 h5">자식 컴포넌트 참조</h5>
<h5 class="hb1 h5">비동기 컴포넌트</h5>
<h5 class="hb1 h5">고급 비동기 컴포넌트</h5>
<h5 class="hb1 h5">컴포넌트 이름 규약</h5>
<h5 class="hb1 h5">재귀 컴포넌트</h5>
<h5 class="hb1 h5">컴포넌트 사이의 순환 참조</h5>
<h5 class="hb1 h5">인라인 템플릿</h5>
<h5 class="hb1 h5">X-Templates</h5>
<h5 class="hb1 h5">v-once를 이용한 비용이 적게드는 정적 컴포넌트</h5>


<!-- ◇◆◇◆◇◆◇◆ -->
<h2 class="hb1 h2" id="animation">트랜지션 & 애니메이션</h2>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">진입/진출 그리고 리스트 트랜지션</h3>


<h4 class="hb1 h4">개요</h4>

<h4 class="hb1 h4">단일 엘리먼트 / 컴포넌트 트랜지션</h4>
<h5 class="hb1 h5">트랜지션 클래스</h5>
<h5 class="hb1 h5">CSS 트랜지션</h5>
<h5 class="hb1 h5">CSS 애니메이션</h5>
<h5 class="hb1 h5">사용자 지정 트랜지션 클래스</h5>
<h5 class="hb1 h5">트랜지션과 애니메이션을 함께 사용하기</h5>
<h5 class="hb1 h5">명시적 트랜지션 지속 시간</h5>
<h5 class="hb1 h5">JavaScript 훅</h5>

<h4 class="hb1 h4">최초 렌더링 시 트랜지션</h4>

<h4 class="hb1 h4">엘리먼트 간 트랜지션</h4>
<h5 class="hb1 h5">트랜지션 모드</h5>

<h4 class="hb1 h4">컴포넌트간 트랜지션</h4>

<h4 class="hb1 h4">리스트 트랜지션</h4>
<h5 class="hb1 h5">리스트의 진입 / 진출 트랜지션</h5>
<h5 class="hb1 h5">리스트 이동 트랜지션</h5>
<h5 class="hb1 h5">비틀거리는 목록 트랜지션</h5>

<h4 class="hb1 h4">트랜지션 재사용</h4>

<h4 class="hb1 h4">동적 트랜지션</h4>

<ul>
<li>CSS 트랜지션 및 애니메이션을 위한 클래스를 자동으로 적용합니다.</li>
<li>Animate.css와 같은 타사 CSS 애니메이션 라이브러리 통합</li>
<li>트랜지션 훅 중에 JavaScript를 사용하여 DOM을 직접 조작</li>
<li>Velocity.js와 같은 써드파티 JavaScript 애니메이션 라이브러리 통합</li>
</ul>


<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">트렌지션 상태</h3>

<!-- ◇◆◇◆◇◆◇◆ -->
<h2 class="hb1 h2">재사용 & 컴포지션</h2>

<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">믹스인</h3>

<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">사용자 지정 디렉티브</h3>

<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">Render Functions & JSX</h3>

<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">플러그인</h3>

<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">필터</h3>

<!-- ◇◆◇◆◇◆◇◆ -->
<h2 class="hb1 h2">도구</h2>

<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">프로덕션 배포 팁</h3>

<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">싱글 파일 컴포넌트</h3>

<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">단위 테스팅</h3>

<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">TypeScript 지원</h3>

<!-- ◇◆◇◆◇◆◇◆ -->
<h2 class="hb1 h2">스케일링 업</h2>

<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">라우팅</h3>

<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">상태 관리</h3>

<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">서버사이드 렌더링</h3>

<!-- ◇◆◇◆◇◆◇◆ -->
<h2 class="hb1 h2">내부</h2>

<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">반응형에 대해 깊이 알아보기</h3>

<!-- ◇◆◇◆◇◆◇◆ -->
<h2 class="hb1 h2">마이그레이션1</h2>

<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">Vue 1.x에서 마이그레이션</h3>

<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">Vue Router 0.7.x으로 부터 마이그레이션</h3>

<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">Vuex 0.6.x에서 1.0로 마이그레이션</h3>

<!-- ◇◆◇◆◇◆◇◆ -->
<h2 class="hb1 h2">메타</h2>

<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">다른 프레임워크와의 비교</h3>

<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">Vue.js 커뮤니티에 참여하세요!</h3>

<!-- ◇◆◇◆◇◆◇◆ -->
<h3 class="hb1 h3">팀 구성원 만나기</h3>


		</div>
	</div>
</div>
<!-- /even-grid -->


<!-- /◇◆ even-grid ◇◆◇◆◇◆◇◆◇◆ -->





<hr />
<br />
<hr class="show" />
<p>
<strong>History</strong>
: 20180410 ~
20181123.
20181121.
20180410.
</p>





<script src="../../share/inc/all_footer.js"></script>
</body>
</html>