<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<script>/*<![CDATA[*/
var _$ = {
	nowPage: {
		id: [0,1,0,0,0],
		title: 'CSS - LESS | mNote', // Home | mNote
		pageType: 'sub',
		layoutType: 'sub'
	}
};
/*]]>*/</script>
<script src="../../share/inc/html_head.js"></script>
</head>
<body>
<script src="../../share/inc/all_header.js"></script>





<!-- ◇◆◇◆◇◆◇◆◇◆◇◆ -->
<h1 class="hb1 h1">SASS</h1>


<!-- mtab1 -->
<div class="mtab1">
<ul>
<li><a>Using SASS</a>
	<ul>
	<li><a href="#Sass-Basics">Sass - Basics 기초</a></li>
	<li><a href="#Sass-SassScript">Sass - SassScript 스크립트</a></li>
	<li><a href="#Sass-CSS-Extensions">Sass - CSS Extensions 확장</a></li>
	<li><a href="#Sass-Built-in-Function">Sass - Built-in Function 내장 함수</a></li>
	</ul>
</li>
<li><a href="#Link">Link</a></li>
</ul>
</div>
<!-- /mtab1 -->


<!-- even-grid -->
<div class="even-grid float-left gap40px vgap00">
	<div class="small-9 column">
		<div class="wrap1">


<p>
	((( <a href="https://poiemaweb.com/" target="_blank" rel="noopener" title="새 창" class="a1">poiemaweb.com</a>
			<a href="https://poiemaweb.com/sass-basics" target="_blank" rel="noopener" title="새 창" class="a1">Sass</a>
</p>


<!-- ◇◆◇◆◇◆◇◆◇◆ -->
<h2 class="hb1 h2" id="Sass-Basics">4.1 Sass - Basics :: <small class="dpib">Sass의 소개, 설치와 간단한 명령어 사용법</small></h2>


<h3 class="hb1 h3">Introduction</h3>


<ol class="bo">
<li>변수 Variable</li>
<li>조건문과 반복문 Conditional and Looping Statements</li>
<li>이입 Import</li>
<li>내포 Nesting</li>
<li>혼합 Mixin</li>
<li>확장 Extend</li>
<li>상속 Inheritance</li>
</ol>


<h3 class="hb1 h3">Install</h3>


<h4 class="hb1 h4"><a href="https://poiemaweb.com/nodejs-basics#2-install">Node.js의 설치와 npm 업데이트</a></h4>


<pre class="mg0">
<code class="xmp">
$ npm install -g node-sass
$ node-sass -v
node-sass 4.12.0  (Wrapper) [JavaScript]
libsass   3.5.4 (Sass Compiler) [C/C++]
</code>
</pre>


<h3 class="hb1 h3">Command</h3>

<h4 class="hb1 h4">node-sass</h4>

<h4 class="hb1 h4">compile</h4>


<pre class="mg0">
<code class="xmp">
$ cd sass-project

// 특정 파일을 특정 파일 이름으로 컴파일
// Compile foo.scss to bar.css
$ node-sass foo.scss > bar.css

// 폴더 내의 모든 파일을 컴파일
// node-sass input-folder-path -o output-folder-path
$ node-sass src/sass --output dist/css
</code>
</pre>


<h4 class="hb1 h4">style</h4>


<pre class="mg0">
<code class="xmp">
node-sass --output-style nested src/sass --output dist/css.nested
node-sass --output-style expanded src/sass --output dist/css.expanded
node-sass --output-style compact src/sass --output dist/css.compact
node-sass --output-style compressed src/sass --output dist/css.compressed
</code>
</pre>


<h4 class="hb1 h4">watch</h4>

<p>watch command는 scss 파일의 변경을 감지하여 변경될 때마다 scss 파일을 컴파일하여 css 파일을 자동 업데이트한다.</p>
<p>디렉터리 단위 또는 파일 단위의 모니터링이 가능하다.</p>


<h5 class="hb1 h5">파일 단위의 watch</h5>

<pre class="mg0">
<code class="xmp">
$ cd my-project

// watch src/sass/foo.scss -> dist/css
$ node-sass --watch src/sass/foo.scss --output dist/css
</code>
</pre>


<h5 class="hb1 h5">디렉터리 단위의 watch</h5>

<pre class="mg0">
<code class="xmp">
$ cd my-project

## watch src/sass -> dist/css
$ node-sass --watch src/sass --output dist/css
</code>
</pre>


<h4 class="hb1 h4">SASS vs. SCSS</h4>


Sass는 SASS 표기법(.sass)과 SCSS 표기법(.scss)이 있다. 
이전 버전에서는 SASS 표기법이 기본 표기법이었으나 Sass 3.0부터 CSS 친화적인 SCSS (Sassy CSS) 표기법이 기본 표기법이 되었다.


<table class="t3">
  <thead>
    <tr>
      <th>&nbsp;</th>
      <th>SCSS</th>
      <th>SASS</th>
      <th>CSS</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>중괄호 {}</td>
      <td>필요</td>
      <td>불필요（공백 2문자 들여쓰기가 코드 블록을 의미)</td>
      <td>필요</td>
    </tr>
    <tr>
      <td>세미콜론 ;</td>
      <td>필요</td>
      <td>불필요</td>
      <td>필요</td>
    </tr>
    <tr>
      <td>: 뒤의 공백</td>
      <td>불필요</td>
      <td>필요</td>
      <td>불필요</td>
    </tr>
    <tr>
      <td>Mixin</td>
      <td>@mixin</td>
      <td>=</td>
      <td>없음</td>
    </tr>
    <tr>
      <td>Include</td>
      <td>@include</td>
      <td>+</td>
      <td>없음</td>
    </tr>
    <tr>
      <td>확장자</td>
      <td>.scss</td>
      <td>.sass</td>
      <td>.css</td>
    </tr>
  </tbody>
</table>

SASS 표기법은 보다 코딩을 간략화할 수 있는 장점이 있지만
CSS 친화적인 SCSS 표기법를 사용하는 경우가 더 많으므로
본 Post에서는 SCSS 표기법을 기준으로 한다.
Sass의 문법에 대한 설명은 아래 포스트를 참조하기 바란다.


<!-- ◇◆◇◆◇◆◇◆◇◆ -->
<h2 class="hb1 h2" id="Sass-SassScript">4.2 Sass - SassScript :: <small class="dpib">CSS를 프로그래밍 언어와 같이 작성할 수 있게 확장한 SassScript</small></h2>


<h3 class="hb1 h3">1. Data Type</h3>

<dl class="fixed1auto1 tp1 dtw4em dtem">
<dt>숫자형</dt>
<dd>e.g) 1.2, 13, 10px</dd>
<dt>문자열</dt>
<dd>CSS는 2종류의 문자열을 사용할 수 있다. 따옴표를 사용하는 경우(“Lucida Grande”, ‘http://sass-lang.com’)와 사용하지 않는 경우(bold, sans-serif)가 있다. Sass는 2종류의 문자열 모두를 인식할 수 있으며 컴파일 후의 CSS에는 Sass에서 사용한 문자열이 그대로 출력된다. e.g. “Lucida Grande”, ‘http://sass-lang.com’, sans-serif</dd>
<dt>컬러</dt>
<dd>e.g. blue, #04a3f9, rgba(255, 0, 0, 0.5)</dd>
<dt>boolean</dt>
<dd>e.g. true, false</dd>
<dt>null</dt>
<dd>프로퍼티 값에 값이 null인 변수가 지정되면 해당 룰셋은 출력되지 않는다.</dd>
<dt>list</dt>
<dd>margin과 padding 프로퍼티값 지정에 사용되는 0 auto와 font-family 프로퍼티값 지정에 사용되는 Helvetica, Arial, sans-serif 등은 공백 또는 콤마 구분된 값의 list이다. e.g. 1.5em 1em 0 2em, Helvetica, Arial, sans-serif</dd>
<dt>map</dt>
<dd>JSON과 유사한 방식으로 map-get 함수를 사용하여 원하는 값은 추출할 수 있다. e.g. (key1: value1, key2: value2)</dd>
</dl>


<pre class="mg0">
<code class="xmp">
// map
$foundation-palette: (
  primary: #E44347,
  mars: #D7525C,
  saturn: #E4B884,
  neptune: #5147D7
);

.mars {
  color: map-get($foundation-palette, mars);
}

// => .mars { color: #D7525C; }
</code>
</pre>


<h3 class="hb1 h3">2. 변수</h3>

변수명은 <code>$</code>로 시작한다.


<h3 class="hb1 h3">3. 변수의 Scope</h3>

<ul class="bu">
<li>변수에는 유효범위(scope)가 존재한다.</li>
<li>위의 예에서 변수 $width는 top level에 기술되었으므로 전역변수(global variable)가 된다.</li>
<li>전역변수는 전역은 물론 하위의 어떤 코드 블록 내에서도 유효하다.</li>
<li>코드 블록 내에서 선언된 변수는 지역변수(local variable)가 된다.</li>
<li>지역변수의 유효범위는 자신이 속한 코드 블록과 하위 코드 블록이다.</li>
</ul>

<p>코드 블록 내에서 선언한 지역변수를 전역변수화하는 방법은 아래와 같다.</p>

<pre class="mg0">
<code class="xmp">
#main {
  $color: #333 <em class="em">!global</em>; // global variable
  width: $width;
}
</code>
</pre>

<h3 class="hb1 h3">4. 연산자(Operation)</h3>

<h4 class="hb1 h4">4.1 숫자 연산자</h4>

<table class="t3">
  <thead>
    <tr>
      <th>Operator</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>+</td>
      <td>덧셈</td>
    </tr>
    <tr>
      <td>-</td>
      <td>뺄셈</td>
    </tr>
    <tr>
      <td>*</td>
      <td>곱셈</td>
    </tr>
    <tr>
      <td>/</td>
      <td>나눗셈</td>
    </tr>
    <tr>
      <td>%</td>
      <td>나머지</td>
    </tr>
    <tr>
      <td>==</td>
      <td>동등</td>
    </tr>
    <tr>
      <td>!=</td>
      <td>부등</td>
    </tr>
  </tbody>
</table>


변수 $width의 값 100px에 10 또는 10em과 같이 다른 단위의 값을 연산하여도 에러없이 연산이 수행된다. 이때 연산자의 왼쪽 값을 기준으로 단위가 설정된다.

$width에 10em을 더하면 어떻게 될까?

컴파일 결과 Incompatible units: ‘em’ and ‘px’.이라는 에러를 출력한다.

Sass 연산은 대상을 변환하여 연산할 수 없는 경우, 에러를 출력한다.

%, em, rem, vh, vw, vmin, vmax과 같이 상대적인 값을 Sass는 알지 못한다. 상대적인 값의 결과값은 브라우저만이 알 수 있기 때문이다.

따라서 상대적인 값을 갖는 단위의 연산은 동일한 단위를 갖는 값과의 연산만이 유효하다.

CSS3의 <code>calc</code> 함수(IE9 이상 사용가능)를 사용하면 이런 문제를 해결할 수 있다.

<pre class="mg0">
<code class="xmp">
#foo {
  width: calc(25% - 5px);
}
</code>
</pre>


아래의 CSS를 살펴보자.


<pre class="mg0">
<code class="xmp">
p {
  /*
    font: font-style font-variant font-weight font-size/line-height font-family
  */
  font: italic bold 12px/30px Georgia, serif;
}
</code>
</pre>

<p>CSS에서의 /는 나눗셈의 의미가 아니라 값을 분리하는 의미를 갖는다.</p>

<p>따라서 Sass의 / 연산자를 사용하기 위해서는 몇가지 조건이 필요하다.</p>

<ul class="bu">
<li>변수에 대해 사용</li>
<li>괄호 내에서 사용</li>
<li>다른 연산의 일부로서 사용</li>
</ul>


<pre class="mg0">
<code class="xmp">
p {
  // font와 border-radius의 '/'는 CSS문법에 맞는 표현이므로 연산되지 않는다.
  font: italic bold 12px/30px Georgia, serif;
  // 타원형 둥근 모서리
  border-radius: 10px 20px/20px;
  /*
  border-top-left-radius: 10px 20px;
  border-top-right-radius: 20px;
  border-bottom-right-radius: 10px 20px;
  border-bottom-left-radius: 20px;
  */

  $width: 1000px;

  width: $width / 2;            // 변수에 대해 사용 →　width: 500px;
  height: (500px / 2);          // 괄호 내에서 사용 →　height: 250px;
  margin-left: 5px + 8px / 2px; // 다른 연산의 일부로서 사용 →　margin-left: 9px;
}
</code>
</pre>

<p>변수를 CSS의 /와 함께 사용하고자 하는 경우 #{}(Interpolation)를 사용한다.</p>

<pre class="mg0">
<code class="xmp">
p {
  $font-size: 12px;
  $line-height: 30px;
  font: #{$font-size}/#{$line-height};  // 12px/30px
}
</code>
</pre>

<h4 class="hb1 h4">4.2 컬러 연산자</h4>

<p>모든 산술 연산자는 컬러 값에도 사용할 수 있다.</p>

<pre class="mg0">
<code class="xmp">
p {
  color: #010203 + #040506;
  // R: 01 + 04 = 05
  // G: 02 + 05 = 07
  // B: 03 + 06 = 09
  // => #050709
}

p {
  color: #010203 * 2;
  // R: 01 * 2 = 02
  // G: 02 * 2 = 04
  // B: 03 * 2 = 06
  // => #020406
}

p {
  color: rgba(255, 0, 0, 0.75) + rgba(0, 255, 0, 0.75);
  // alpha 값은 연산되지 않는다
  // color: rgba(255, 255, 0, 0.75);
}
</code>
</pre>


<p>alpha 값은 연산되지 않는다. alpha 값의 연산을 위해서는 opacify 함수 또는 transparentize 함수를 사용한다.</p>

<ul class="bu">
<li>opacify 함수: 첫번째 argument의 alpha값에 두번째 argument를 더해 불투명도를 증가시킨다.(더 불투명해진다)</li>
<li>transparentize 함수: 첫번째 argument의 alpha값에 두번째 argument를 빼서 불투명도를 감소시킨다.(더 투명해진다)</li>
</ul>


<pre class="mg0">
<code class="xmp">
$translucent-red: rgba(255, 0, 0, 0.5);

p {
  color: opacify($translucent-red, 0.3);
  // => color: rgba(255, 0, 0, 0.8);

  background-color: transparentize($translucent-red, 0.25);
  // => background-color: rgba(255, 0, 0, 0.25);
}
</code>
</pre>

<h4 class="hb1 h4">4.3 문자열 연산자</h4>

<p><code>+</code> 연산자는 자바스크립트와 같이 문자열을 연결할 수 있다.</p>

<pre class="mg0">
<code class="xmp">
p {
  cursor: e + -resize;  // e-resize
}
</code>
</pre>

<p>따옴표가 있는 문자열과 없는 문자열을 함께 사용하는 경우, 좌항의 문자열을 기준으로 따옴표를 처리한다.</p>

<pre class="mg0">
<code class="xmp">
p:before {
  content: "Foo " + Bar;        // "Foo Bar"
  font-family: sans- + "serif"; // sans-serif
}
</code>
</pre>


<h4 class="hb1 h4">4.4 불린 연산자</h4>

<table class="t3">
  <thead>
    <tr>
      <th>Operator</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>&amp;&amp;</td>
      <td>and</td>
    </tr>
    <tr>
      <td>||</td>
      <td>or</td>
    </tr>
    <tr>
      <td>!</td>
      <td>not</td>
    </tr>
  </tbody>
</table>

<ul>
  <li><a href="./sass-css-extention#31-if">if</a></li>
  <li><a href="./sass-css-extention#31-if">@if</a></li>
</ul>

<h4 class="hb1 h4">4.5 리스트 연산자</h4>

<p>리스트를 위한 별도의 연산자는 제공되지 않지만 리스트 함수를 사용하여 필요한 처리를 수행할 수 있다.</p>


<h3 class="hb1 h3">5. 함수</h3>

<p><a href="./sass-built-in-function">Sass Built-in Functions</a>를 참조하기 바란다.</p>


<h3 class="hb1 h3">6. Interpolation: #{}</h3>

<p>인터폴레이션은 변수의 값을 문자열 그대로 삽입한다. 인터폴레이션에 의해 삽입된 문자열은 연산의 대상으로 취급되지 않는다.</p>

<p>변수는 프로퍼티값으로만 사용할 수 있으나 <code>#{}</code>을 사용하면 프로퍼티값은 물론 셀렉터와 프로퍼티명에도 사용할 수 있다.</p>

<pre class="mg0">
<code class="xmp">
$name: foo;
$attr: border;

p.#{$name} {            // p.foo
  #{$attr}-color: blue; // border-color: blue;
}

.someclass {
  $font-size: 12px;
  $line-height: 30px;
  // 연산의 대상으로 취급되지 않도록
  font: #{$font-size} / #{$line-height}; // 12px / 30px
}
</code>
</pre>


<h3 class="hb1 h3">7. Ampersand(&)</h3>


<code>&</code>는 부모요소를 참조하는 셀렉터이다.


<pre class="mg0">
<code class="xmp">
a {
  color: #ccc;

  &.home {
    color: #f0f;
  }

  &:hover {
    text-decoration: none;
  }

  // & > span (X)
  > span {
    color: blue;
  }

  span {
    color: red;
  }
}
</code>
</pre>


<h3 class="hb1 h3">8. !default</h3>


<p><code>!default</code> flag는 할당되지 않은 변수의 초기값을 설정한다.</p>

<p>이미 값이 할당되어 있는 변수에 !default flag를 사용하면 적용되지 않는다.</p>

<p>이러한 특성은 partial에 매우 유용하다.</p>

<strong class="h1 em big">***? 뭔소린지 모르겠다.</strong>



<!-- ◇◆◇◆◇◆◇◆◇◆ -->
<h2 class="hb1 h2" id="Sass-CSS-Extensions">4.3 Sass - CSS Extensions :: <small class="dpib">Nesting, import, extend, 조건과 반복, Mixin, Function</small></h2>


<h3 class="hb1 h3">1. Nesting</h3>

<pre class="mg0">
<code class="xmp">
#navbar {
  width: 80%;
  height: 23px;

  ul { list-style-type: none; }

  li {
    float: left;
    a { font-weight: bold; }
  }
}
</code>
</pre>

<p>
	너무 깊은 Nesting은 가독성을 나쁘게 하고 셀렉터를 복잡하게 만든다.
</p>

<p>
	부모요소의 참조가 필요한 경우 <code>&</code>를 사용한다.
	예를들어 :hover 또는 ::before 등의 가상 클래스 선택자 (Pseudo-Class Selector)를 지정하는 경우 부모요소의 참조가 필요하다.
</p>

<pre class="mg0">
<code class="xmp">
.myAnchor {
  color: blue;

  // .myAnchor:hover
  &:hover {
    text-decoration: underline;
  }

  // .myAnchor:visited
  &:visited {
    color: purple;
  }
}
</code>
</pre>

Nesting은 프로퍼티에도 사용할 수 있다.

<pre class="mg0">
<code class="xmp">
.funky {
  font: {
    family: fantasy;
    size: 30em;
    weight: bold;
  }
}
</code>
</pre>


<h3 class="hb1 h3">2. @-Rules and Directives</h3>


<h4 class="hb1 h4">2.1 @import</h4>

<p>
	1개의 CSS 파일에 모든 스타일을 기술하는 것은 가독성을 나쁘게 한다.
	또한 기능에 따라 CSS 파일을 분리하면 재사용 및 유지보수 측면에서 유리하다.
	따라서 룰을 정하여 파일을 분리하여 개발하는 것은 효과적인 방법이다.
</p>
<p>
	Sass는 @import directive를 사용하여 분리된 stylesheet 파일을 import할 수 있다. 기존의 CSS @import보다 편리한 기능을 제공한다.
</p>

<pre class="mg0">
<code class="xmp">
@import "foo.scss";

// 확장자는 생략 가능하다
@import "foo";

// import multiple files
@import "rounded-corners", "text-shadow";

$family: unquote("Droid+Sans");
@import url("http://fonts.googleapis.com/css?family=#{$family}");
</code>
</pre>

<p>여러 개의 파일로 분할하는 것 또는 분할된 파일을 <strong>partial</strong> 이라 하며
partial된 Sass 파일명의 선두에는 underscore(_)를 붙인다. (_reset.scss, _module.scss, _print.scss)</p>

예를 들어 “_foo.scss”라는 partial된 Sass 파일이 있고 이 파일을 import하는 경우 아래와 같이 기술한다. 파일명 선두의 _와 확장자는 생략할 수 있다.

<pre class="mg0">
<code class="xmp">
@import "foo";
</code>
</pre>

<p>
	partial된 Sass 파일명 선두에 붙인 _의 의미는 import는 수행하되 CSS로의 컴파일은 수행하지 말라는 의미를 갖는다.
	따라서 partial은 import시에는 CSS 파일로 컴파일되지 않기 때문에 최종적으로 CSS로 컴파일을 수행할 Sass 파일에서 import한다.
</p>

<img src="https://poiemaweb.com/img/partial.png" style="width:100%;height:auto;" alt="★대체텍스트필수" />

<p>
	예를 들어 위 그림과 같이 partial된 _vars.scss, _header.scss, _sidebar.scss, _footer.scss를 style.scss가 import하는 경우를 생각해 보자.
</p>



<pre class="mg0">
<code class="xmp">
// _vars.scss
$width: 960px;
</code>
</pre>

<pre class="mg0">
<code class="xmp">
// _header.scss
#header {
  width: $width;
}
</code>
</pre>

<pre class="mg0">
<code class="xmp">
// _sidebar.scss
#sidebar {
  width: $width;
}
</code>
</pre>

<pre class="mg0">
<code class="xmp">
// _footer.scss
#footer {
  width: $width;
}
</code>
</pre>

<pre class="mg0">
<code class="xmp">
// style.scss
@import "partial/vars";
@import "partial/header";
@import "partial/sidebar";
@import "partial/footer";
</code>
</pre>

<p>
	_vars.scss에는 변수가 선언되어 있으므로 partial된 _vars.scss, _header.scss, _sidebar.scss, _footer.scss를 import가 수행되어 하나의 파일이 되기 이전에 컴파일을 실행하면 에러가 발생한다. 즉, partial된 Sass 파일명 선두에 붙인 _을 제거하면 에러가 발생한다. 따라서 partial된 Sass 파일명 선두에는 반드시 _를 붙여서 import 시에는 partial이 CSS 파일로 컴파일되지 않고 import가 완료된 이후, CSS로 컴파일을 수행도록 한다.
</p>

<p>
	@import는 top-level에서 사용하는 것이 일반적이지만 CSS rule 또는 @media rule 내에 포함시키는 것도 가능하다.
</p>

<pre class="mg0">
<code class="xmp">
// _example.scss
.example {
  color: red;
}
#main {
  @import "example";
}
</code>
</pre>

<p>위 코드의 컴파일 결과는 아래와 같다.</p>

<pre class="mg0">
<code class="xmp">
#main .example {
  color: red;
}
</code>
</pre>


<h4 class="hb1 h4">2.2 @extend</h4>

기존 스타일을 상속하고자 경우 @extend를 사용한다.

예를 들어 아래의 경우를 살펴보자.

<div class="error seriousError">
  Oh no! You've been hacked!
</div>
<p>기존에 선언되어 있는 error class를 사용하면서 일부 rule set에 대해서는 다른 선언이 필요한 경우 자주 사용하는 방법이다.</p>

<p>이러한 경우 사용할 수 있는 방법이 상속이다. 상속되는 rule set을 그대로 상속받아 다른 부분만 별도 선언하면 된다.</p>

<pre class="mg0">
<code class="xmp">
.error {
  border: 1px #f00;
  background-color: blue;
}

.seriousError {
  @extend .error;

  border-width: 3px;
  border-color: darkblue;
}
</code>
</pre>

<p>위 코드의 컴파일 결과는 아래와 같다. .error와 .seriousError가 공통으로 사용하는 프로퍼티를 묶어 합리적인 룰셋을 생성한다.</p>

<p>.error, .seriousError {
  border: 1px #f00;
  background-color: blue;
}

.seriousError {
  border-width: 3px;
  border-color: darkblue;
}
</p>

<p>이제는 하나의 클래스만 적용시키면 된다.</p>

<xmp class="xmp">
<div class="seriousError">
  Oh no! You've been hacked!
</div>
</xmp>

<p>@extend를 @media 블록과 같이 사용하는 경우, 제대로 작동하지 않는다. 다시말해 @media 안에서 외부의 선택자를 @extend할 수 없다.</p>

<pre class="mg0">
<code class="xmp">
.foo {
  color: red;
}

@media print {
  .bar {
    // ERROR
    @extend .foo;
  }
}
</code>
</pre>

<p class="pd1em-rv bg-warning">
	@extend를 사용하면 컴파일 후 자신의 셀렉터가 어디에 첨부될 것인지 예상하기 어렵고, 예상치 못했던 부작용이 발생할 수 있다.<br />
	따라서 @extend의 사용은 가급적 자제하고 Mixin은 사용하는 것을 추천한다.
</p>


<h4 class="hb1 h4">2.3 Placeholder Selectors</h4>

<p>Placeholder Selector는 Sass 3.2부터 제공되는 기능으로 재이용이 가능한 rule set을 % 키워드로 지정하는 @extend 전용 Selector이다.</p>

<p>Placeholder Selector은 상속만을 위한 rule set으로 자신은 컴파일되지 않는다.</p>

<pre class="mg0">
<code class="xmp">
%input-style {
  font-size: 14px;
}

.input-black {
  @extend %input-style;

  color: black;
}

.input-red {
  @extend %input-style;

  color: red;
}
</code>
</pre>

<p>컴파일 결과는 아래와 같다.</p>

<pre class="mg0">
<code class="xmp">
.input-black, .input-red {
  font-size: 14px;
}

.input-black {
  color: black;
}

.input-red {
  color: red;
}
</code>
</pre>


<h3 class="hb1 h3">3. 조건과 반복</h3>

<h4 class="hb1 h4">3.1 if()</h4>

<p>built-in if() 함수는 주어진 조건을 판단하여 결과를 리턴한다. Javascript의 삼항연산자와 유사하게 동작한다.</p>

<pre class="mg0">
<code class="xmp">
if(condition, if_true, if_false)
</code>
</pre>

<p>condition이 true이면 if_true를, false이면 if_false를 반환한다.</p>

<pre class="mg0">
<code class="xmp">
$type: ocean;

p {
  color: if($type == ocean, blue, black); // color: blue;
}
</code>
</pre>

<h4 class="hb1 h4">3.2 @if</h4>

<p>@if를 사용하면 조건분기가 가능하다.</p>

<pre class="mg0">
<code class="xmp">
$type: monster;

p {
  @if $type == ocean {
    color: blue;
  } @else if $type == matador {
    color: red;
  } @else if $type == monster {
    color: green;
  } @else {
    color: black;
  }
}
</code>
</pre>

<p>컴파일 결과는 아래와 같다.</p>

<pre class="mg0">
<code class="xmp">
p {
  color: green;
}
</code>
</pre>

<h4 class="hb1 h4">3.3 @for</h4>

<p>@for으로 반복문을 사용할 수 있다.</p>

<pre class="mg0">
<code class="xmp">
@for $i from 1 through 3 {
  .item-#{$i} { width: 2em * $i; }
}
</code>
</pre>

<p>컴파일 결과는 아래와 같다.</p>

<pre class="mg0">
<code class="xmp">
.item-1 {
  width: 2em;
}
.item-2 {
  width: 4em;
}
.item-3 {
  width: 6em;
}
</code>
</pre>

<h4 class="hb1 h4">3.4 @each</h4>

<p>@each와 list 또는 map의 요소에 대해 반복을 실시한다.</p>

<pre class="mg0">
<code class="xmp">
// List
@each $animal in puma, sea-slug, egret, salamander {

  .#{$animal}-icon {
    background-image: url('/images/#{$animal}.png');
  }
}

// Map
// $header: h1, $size: 2em
// $header: h2, $size: 1.5em
// $header: h3, $size: 1.2em
@each $header, $size in (h1: 2em, h2: 1.5em, h3: 1.2em) {
  #{$header} {
    font-size: $size;
  }
}
</code>
</pre>

<p>컴파일 결과는 아래와 같다.</p>

<pre class="mg0">
<code class="xmp">
.puma-icon {
  background-image: url("/images/puma.png");
}

.sea-slug-icon {
  background-image: url("/images/sea-slug.png");
}

.egret-icon {
  background-image: url("/images/egret.png");
}

.salamander-icon {
  background-image: url("/images/salamander.png");
}

h1 {
  font-size: 2em;
}

h2 {
  font-size: 1.5em;
}

h3 {
  font-size: 1.2em;
}
</code>
</pre>


<h4 class="hb1 h4">3.5 @while</h4>


<p>@while으로 반복문을 사용할 수 있다.</p>

<pre class="mg0">
<code class="xmp">
$i: 6;
@while $i > 0 {
  .item-#{$i} { width: 2em * $i; }
  $i: $i - 2;
}
</code>
</pre>

<p>컴파일 결과는 아래와 같다.</p>

<pre class="mg0">
<code class="xmp">
.item-6 {
  width: 12em;
}

.item-4 {
  width: 8em;
}

.item-2 {
  width: 4em;
}
</code>
</pre>


<h3 class="hb1 h3">4. Mixin</h3>


<p>Mixin은 Sass의 매우 유용한 기능으로 중복 기술을 방지하기 위해 사용 빈도가 높은 마크업을 사전에 정의하여 필요할 때에 불러 사용하는 방법이다.</p>

<p>@extend와 유사하나 프로그래밍 언어의 함수와 같이 argument를 받을 수 있다.</p>

<p>사용법은 매우 간단하다. @mixin 선언하고 @include로 불러들인다.</p>

<pre class="mg0">
<code class="xmp">
// 지름이 50px인 원
@mixin circle {
  width: 50px;
  height: 50px;
  border-radius: 50%;
}

// 지름이 50px인 원을 위한 mixin을 include한 후, 배경을 추가 지정
.box {
  @include circle;

  background: #f00;
}
</code>
</pre>

<p>컴파일 결과는 아래와 같다. 배경이 red이고 지름이 50px인 원을 표시한다.</p>

<pre class="mg0">
<code class="xmp">
.box {
  width: 50px;
  height: 50px;
  border-radius: 50%;
  background: #f00;
}
</code>
</pre>

<p>@extend와 차이가 없어 보이나 Mixin은 함수와 같이 argument를 사용할 수 있다.</p>

<pre class="mg0">
<code class="xmp">
@mixin circle($size) {
  width: $size;
  height: $size;
  border-radius: 50%;
}

.box {
  @include circle(100px);

  background: #f00;
}
</code>
</pre>

<p>컴파일 결과는 아래와 같다.</p>

<pre class="mg0">
<code class="xmp">
.box {
  width: 100px;
  height: 100px;
  border-radius: 50%;
  background: #f00;
}
</code>
</pre>

<p>argument의 초기값을 설정할 수도 있다.</p>

<pre class="mg0">
<code class="xmp">
@mixin circle($size: 10px) {
  width: $size;
  height: $size;
  border-radius: 50%;
}

.box {
  // 인자가 없으면 초기값을 사용한다.
  @include circle();
  background: #f00;
}
</code>
</pre>

<p>컴파일 결과는 아래와 같다.</p>

<pre class="mg0">
<code class="xmp">
.box {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: #f00;
}
</code>
</pre>

<p>Mixin을 사용한 유용한 예제를 살펴보자.</p>


<h4 class="hb1 h4">vendor prefix</h4>


<pre class="mg0">
<code class="xmp">
@mixin vendorPrefix($property, $value) {
  @each $prefix in -webkit-, -moz-, -ms-, -o-, '' {
    #{$prefix}#{$property}: $value;
  }
}

.border_radius {
  @include vendorPrefix(transition, 0.5s);
}
</code>
</pre>

<pre class="mg0">
<code class="xmp">
.border_radius {
  -webkit-transition: 0.5s;
  -moz-transition: 0.5s;
  -ms-transition: 0.5s;
  -o-transition: 0.5s;
  transition: 0.5s;
}
</code>
</pre>


<h4 class="hb1 h4">opacity</h4>

<pre class="mg0">
<code class="xmp">
@mixin opacity($opacity) {
  opacity: $opacity; /* All modern browsers */
  $opacityIE: $opacity * 100;
  filter: alpha(opacity=$opacityIE); /* For IE5~IE9 */
}

.box {
  @include opacity(0.5);
}
</code>
</pre>

<pre class="mg0">
<code class="xmp">
.box {
  opacity: 0.5;
  /* All modern browsers */
  filter: alpha(opacity=50);
  /* For IE5~IE9 */
}
</code>
</pre>


<h4 class="hb1 h4">position</h4>

<pre class="mg0">
<code class="xmp">
@mixin position($position, $top: null, $right: null, $bottom: null, $left: null) {
  position: $position;
  top: $top;
  right: $right;
  bottom: $bottom;
  left: $left;
}

.box {
  @include position(absolute, $top: 10px, $left: 50%);
}
</code>
</pre>

<pre class="mg0">
<code class="xmp">
.box {
  position: absolute;
  top: 10px;
  left: 50%;
}
</code>
</pre>

<p>이와 같이 Mixin을 작성하여 사용할 수도 있으나 Sass Framework/Library를 사용하는 것은 매우 바람직한 방법이다.</p>


<ul class="bu">
  <li>
    <a href="http://bourbon.io/">Bourbon: Sass Mixins Library</a>
  </li>
  <li>
    <a href="http://compass-style.org/">Compass: CSS Authoring Framework</a>
  </li>
  <li>
    <a href="http://susy.oddbird.net/">Susy: Sass grid framework</a>
  </li>
</ul>


<h3 class="hb1 h3">5. Function</h3>

<p>Function은 mixin과 유사하나 리턴값에 차이가 있다.</p>

<ul class="bu">
<li>mixin : style markup을 리턴</li>
<li>function : @return directive를 통하여 값을 리턴</li>
</ul>

<pre class="mg0">
<code class="xmp">
$grid-width: 40px;
$gutter-width: 10px;

@function grid-width($n) {
  @return $n * $grid-width + ($n - 1) * $gutter-width;
}

#sidebar { width: grid-width(5); }  // width: 240px;
</code>
</pre>


<h3 class="hb1 h3">6. Comment</h3>


<p>CSS는 멀티 라인 주석 /* */만을 지원하지만 Sass는 /* */와 // 모두 사용할 수 있다.</p>

<p>한 줄 주석 //은 컴파일 후 CSS에서 사라지고, 멀티 라인 주석은 CSS에 나타난다.</p>



<!-- ◇◆◇◆◇◆◇◆◇◆ -->
<h2 class="hb1 h2" id="Sass-Built-in-Function">4.4 Sass - Built-in Function :: <small class="dpib">Sass가 제공하는 기본 내장 함수</small></h2>


<h3 class="hb1 h3">1. Number Functions</h3>


<pre class="mg0">
<code class="xmp">
// 숫자값을 %로 변환
percentage(0.2)	=> 20%
percentage(100px / 50px) => 200%

// 소숫점 이하 반올림
round(10.4px) => 10px
round(10.6px) => 11px

// 소숫점 이하 올림
ceil(10.4px) => 11px
ceil(10.6px) => 11px

// 소숫점 이하 절사
floor(10.4px) => 10px
floor(10.6px) => 10px

// 절대값 취득
abs(10px) => 10px
abs(-10px) => 10px
</code>
</pre>


<h3 class="hb1 h3">2. Introspection Functions</h3>

<pre class="mg0">
<code class="xmp">
// Data type 취득
type-of(100px)  => number
type-of(asdf)   => string
type-of("asdf") => string
type-of(true)   => bool
type-of(#fff)   => color
type-of(blue)   => color

// Data unit 취득
unit(100)   => ""
unit(100px) => "px"
unit(3em)   => "em"
unit(10px * 5em) => "em*px"
unit(10px * 5em / 30cm / 1rem) => "em*px/cm*rem"

// 값에 단위가 있는지 확인
unitless(100)   => true
unitless(100px) => false

// 2개의 값을 합산, 감산, 비교 가능한지 확인
comparable(2px, 1px)   => true
comparable(100px, 3em) => false
comparable(10cm, 3mm)  => true
</code>
</pre>

<h3 class="hb1 h3">3. String Functions</h3>

<pre class="mg0">
<code class="xmp">
// 따옴표 붙이기
quote("foo") => "foo"
quote(foo)   => "foo"

// 따옴표 제거
unquote("foo") => foo
unquote(foo)   => foo
</code>
</pre>


<h3 class="hb1 h3">4. List Functions</h3>

<pre class="mg0">
<code class="xmp">
// 리스트 요소수 취득
length(10px)                        => 1
length(10px 20px 30px)              => 3
length((width: 10px, height: 20px)) => 2

// 리스트의 n번째 요소 취득
nth(10px 20px 30px, 1)                 => 10px
nth((Helvetica, Arial, sans-serif), 3) => sans-serif
nth((width: 10px, length: 20px), 2)    => length 20px

$n: nth(width: 10px, length: 20px);
nth(($n, 2), 1)                        => length

// 요소의 index 취득
index(1px solid red, solid)                       => 2
index(1px solid red, dashed)                      => null
index((width: 10px, height: 20px), (height 20px)) => 2

// 리스트의 마지막에 단일 요소 추가
append(10px 20px, 30px)      => 10px 20px 30px
append((blue, red), green)   => blue, red, green
append(10px 20px, 30px 40px) => 10px 20px (30px 40px)
append(10px, 20px, comma)    => 10px, 20px
append((blue, red), green, space) => blue red green

// 리스트와 리스트의 결합
join(10px 20px, 30px 40px)      => 10px 20px 30px 40px
join((blue, red), (#abc, #def)) => blue, red, #abc, #def
join(10px, 20px)                => 10px 20px
join(10px, 20px, comma)         => 10px, 20px
join((blue, red), (#abc, #def), space) => blue red #abc #def

// 복수의 리스트를 각자의 순서에 맞추어 재결합
zip(1px 1px 3px, solid dashed solid, red green blue)
=> 1px solid red, 1px dashed green, 3px solid blue
</code>
</pre>


<h3 class="hb1 h3">5. Map Functions</h3>

<pre class="mg0">
<code class="xmp">
// key로 value 취득
map-get(("foo": 1, "bar": 2), "foo") => 1
map-get(("foo": 1, "bar": 2), "bar") => 2
map-get(("foo": 1, "bar": 2), "baz") => null
</code>
</pre>

<h3 class="hb1 h3">6. Color Functions</h3>


<pre class="mg0">
<code class="xmp">
<b class="em5">// 색상(hue) 변경</b>
$base-color: #ad141e;

.adjust-hue {
  color: adjust-hue($base-color, 20%);
  // => #ad3d14
}
adjust-hue

<b class="em5">// 채도(saturation) 변경</b>
$base-color: #ad141e;

p {
  .saturate {
    color: saturate($base-color, 20%);
  }

  .desaturate {
    color: desaturate($base-color, 20%);
  }
}
saturation

<b class="em5">// 휘도(lightness) 변경</b>
$base-color: #ad141e;

p {
  .darken {
    color: darken($base-color, 10%);
  }

  .lighten {
    color: lighten($base-color, 10%);
  }
}
lightness

<b class="em5">// 투명도(opacity) 변경</b>
$base-color: #ad141e;

.rgba {
  color: rgba($base-color, .7);
}

/*
.rgba {
  color: rgba(173, 20, 30, 0.7); }
*
<b class="em5">// alpha 연산</b>
$base-color: rgba(255, 0, 0, 0.5);

// alpha +
// 불투명도를 증가시킨다.(더 불투명해진다)
.opacify {
  color: opacify($base-color, 0.3);
}

// alpha -
// 불투명도를 감소시킨다.(더 투명해진다)
.transparentize {
  color: transparentize($base-color, 0.25);
}

/*
.opacify {
  color: rgba(255, 0, 0, 0.8); }

.transparentize {
  color: rgba(255, 0, 0, 0.25); }
*/

<b class="em5">// Tint & Shade</b>
// 색상은 흰색(tint)과 검정색(shade)의 값으로 혼합되며 darken, lighten과 유사하다.

$base-color: #ad141e;

.tint {
  color: tint($base-color, 10%);
}

.shade {
  color: shade($base-color, 10%);
}
</code>
</pre>


<h3 class="hb1 h3">Reference</h3>

<ul class="bu">
  <li>
    <a href="http://sass-lang.com/">Sass</a>
  </li>
  <li>
    <a href="http://sass-lang.com/documentation/Sass/Script/Functions.html">Sass Built-in Functions</a>
  </li>
  <li>
    <a href="http://jackiebalzer.com/color">Sass &amp; Compass Color Functions</a>
  </li>
  <li>
    <a href="http://scg.ar-ch.org/">Sass Color Generator</a>
  </li>
</ul>


		</div>
	</div>
	<div class="small-3 column">
		<div class="wrap1">


<!-- ◇◆◇◆◇◆◇◆◇◆ -->
<h2 class="hb1 h2" id="Link">Link</h2>


<ol class="bo">
<li>
	<a href="★★" target="_blank" rel="noopener" title="새 창" class="a1">
		★★
	</a>
</li>
<li>
	<a href="https://poiemaweb.com/sass-basics" target="_blank" rel="noopener" title="새 창" class="a1">
		4.1 <b class="em1">Sass - Basics</b> :: Sass의 소개, 설치와 간단한 명령어 사용법
	</a> - PoiemaWeb
</li>
<li>
	<a href="https://sass-guidelin.es/ko/" target="_blank" rel="noopener" title="새 창" class="a1">
		Sass Guidelines
	</a>
</li>
<li>
	<a href="https://ko.wikipedia.org/wiki/Sass_(스타일시트_언어)" target="_blank" rel="noopener" title="새 창" class="a1">
		Sass (스타일시트 언어)
	</a>
</li>
<li><a href="http://sass-lang.com/guide" target="_blank" title="새 창">Sass의 guide페이지</a></li>
<li><a href="http://windtale.net/blog/why-i-choose-sass/" target="_blank" title="새 창">내가 Sass를 선택한 이유</a></li>
</ol>


		</div>
	</div>
</div>
<!-- /even-grid -->





<br />
<hr class="show" />
<p>
<strong>History</strong>
20150324.~
20200121.
20200120.
20200117.
20150324.
</p>





<script src="../../share/inc/all_footer.js"></script>
</body>
</html>