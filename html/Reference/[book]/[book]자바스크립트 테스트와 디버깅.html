<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<script>/*<![CDATA[*/
var $meta = {
	title: 'Reference - [book]자바스크립트 테스트와 디버깅 | mNote',
	pageType: 'default'
};
/*]]>*/</script>
<script src="../../share/inc/html_head.js"></script>
</head>
<body>
<script src="../../share/inc/all_header.js"></script>





<h1>[book]자바스크립트 테스트와 디버깅</h1>
| <a href="http://www.yes24.com/24/Goods/11573621?Acode=101">View</a>
| <del>Demo</del>
| <a href="https://github.com/mixed/js_test_and_debug_book/">Exam</a>
| <a >Errata</a>
| <a >[PDF]</a>
| <a href="http://blog.mixed.kr/">추가정보</a>
<br />
| Read 384p/20h = 19.2/h
<br />
Legend: <strong>Read</strong> <em>Remember</em> <b>Question</b> <i>Answer</i>

<h2 id="Overview">Overview : Summary</h2>

<pre>
I. 테스팅
'개발을 잘한다' 조건 중 하나 '생산성'.
단순히 짧은 시간 안에 많은양의 코드를 만드는 것이 아닌.. 버그가 적고 유지보수 쉬운 좋은 품질의 코드를 효율적으로 작성.
'생산성' 을 가장 저해하는 요소는 '디버깅'.
가장 효율적인 디버깅이란 디버깅이 필요 없는 프로그래밍을 하는 것.
디버깅을 하지 않을 수는 없으므로.. 적게 할 수 있는 수 있는 테스팅 방법을 알아본다.

<h3>01. TDD를 적용한 단위 테스트</h3>
_1.1 테스트의 종류
__1.1.1 테스트 수준에 따른 분류
__1.1.2 테스트 목적에 따른 분류
__1.1.3 테스트 방법에 따른 분류
_1.2 테스트 주도 개발(TDD)이란 무엇인가
_1.3 TDD 진행 방법
_1.4 TDD에서 유의해야 할 점
_1.5 TDD의 장점
<div class="box1"><!-- box1 -->
<strong>테스트 주도 개발 (Test-Driven Development, TDD)</strong>

개발 프로세스
| 폭포수 모델 : 분석 디자인 구현 테스트 유지보수
| V모델 : 
| | 단위 테스트(Unit Test) : 모듈, 컴포넌트, 함수 - 프로그래머
| | 통합 테스트(Intergration Test) : 단위 모듈 통합 후 - 프로그래머
| | 시스템 테스트(System Test) : 전체 시스템 - 별도의 팀이나 담당자. 코드에 대한 설계나 구현 내용을 자세히 이해할 필요는 없다.
| | 인수 테스트(Acceptane Test) : 함수 - 고객(사용자) 스스로 또는 별도의 팀이나 담당자. 코드를 이해할 필요는 없다.

긍정(positive) 테스트 - 본인
부정(negative) 테스트 - 별도의 조직(QA팀)
| 새너티(Sanity) Test
| 회귀(Regression) Test
| 부하(Stress) Test
| 로드(Load) Test

Black Box Test
White Box Test (Glass Test)
Gray Box Test

TDD : 실패 → 성공 → 리팩터링(Refactoring) → 실패 → ..

삼진규칙 : 일반적으로 같은 코드가 세 번 이상 사용되면 리팩터링을 진행한다.(두 번 이상 같을 때 하기도 한다.)

보폭을 넓힌다.

작은 보폭으로 테스트 케이스를 작성한다. 익숙해지면 큰 보폭..
각 테스트 케이스는 독립적이어야 한다. 연관된 케이스는 연쇄 실패 가능성 크다.

TDD 장점
1) 구현 코드에 테스트 케이스가 존재하므로, 버그 줄고 안정적 개발 가능하다.
2) 프로그램이 군더더기 없이 개발된다. 디자인이 단순해진다.
3) 개발 방향이 잘못된 길로 들어설 때 빠르게 알려 준다.

깨진 유리창 이론

<!-- /box1 --></div>

<h3>02. 자바스크립트 단위 테스트 도구</h3>
_2.1 QUnit
__2.1.1 환경 설정
__2.1.2 테스트 함수
__2.1.3 단언문(assertion)
__2.1.4 비동기 테스트에 사용하는 함수
_2.2 그 밖에 유용한 함수
__2.2.1 일부 모듈(module)만 실행하기
__2.2.2 QUnit을 활용하여 자동화된 CI 테스트 구축하기
_2.3 테스텀(Testem)
__2.3.1 설치 방법
__2.3.2 사용 방법
__2.3.3 기타 설정 및 기능

<div class="box1"><!-- box1 -->
Testem : node.js 기반 도구
<!-- /box1 --></div>

<h3>03. 자바스크립트 단위 테스트 패턴</h3>
_3.1 테스트 케이스 패턴
_3.2 기본적인 DOM 테스트
_3.3 시스템 창 테스트 (alert, confirm)
_3.4 <strong>이벤트 테스트</strong>
__3.4.1 가짜 이벤트를 이용한 테스트
__3.4.2 이벤트와 연관된 부분을 함수로 분리한 테스트
_3.5 Ajax 테스트
__3.5.1 동기 테스트
__3.5.2 비동기 테스트
_3.6 Timer(setTimeout, setInterval) 테스트

<div class="box1"><!-- box1 -->
Given/When/Then 패턴.
가독성 중요.
TimerMock
<!-- /box1 --></div>

<h3>04. 테스트 더블을 이용한 테스트</h3>
_4.1 테스트 더블(Test Double)
__4.1.1 스텁 객체를 사용한 테스트
__4.1.2 목 객체를 사용한 테스트
_4.2 테스트 더블의 사용 전략 및 장단점
__4.2.1 테스트 더블의 사용 전략
__4.2.2 테스트 더블의 장점
__4.2.3 테스트 더블 사용의 단점

<div class="box1"><!-- box1 -->
테스트 더블(Test Double)
목 객체(Mock Object)
<!-- /box1 --></div>

II. 디버깅
자바스크립트 디버깅이 어려운 이유? 테스트 환경에 따라 다양한 도구가 필요하고 사용 방법이 익숙하지 않기 때문.
[IE6~7] 도구 사용이 어렵다.
모바일 웹에서도 디버깅 환경이 매우 열악하다.

<h3>05. 파이어폭스(Firefox) 디버깅</h3>
_5.1 파이어버그
__5.1.1 파이어폭스 설치
__5.1.2 파이어버그 설치
_5.2 콘솔(Console) 이용하기
__5.2.1 콘솔 탭
__5.2.2 콘솔 객체
_5.3 HTML, CSS 디버깅
__5.3.1 HTML 탭
__5.3.2 CSS 탭
_5.4 스크립트 디버깅
_5.5 네트워크 디버깅
_5.6 쿠키

<div class="box1"><!-- box1 -->
Firefox 27.01 - 개발자 도구 - 콘솔 창
에서 help 명령어를 실행하면 콘솔 메서드 설명을 볼 수 있다.
<!-- /box1 --></div>

<h3>06. 인터넷 익스플로러 디버깅</h3>
_6.1 IE 하위 버전(6~7) 디버깅
__6.1.1 디버깅 도구 설치하기
__6.1.2 IE 개발자 도구(IE developer tool bar)
__6.1.3 스크립트 디버깅
__6.1.4 스크립트 편집기
__6.1.5 네트워크 프로파일링
_6.2 IE 상위 버전(8~9) 디버깅
__6.2.1 엘리먼트 선택 도구(HTML, CSS 탭)
__6.2.2 스크립트 탭
__6.2.3 네트워크 탭(IE 9 이상)
__6.2.4 프로파일러

<div class="box1"><!-- box1 -->
<strong>[IE6~7] 디버깅 도구 4가지 설치 필요</strong>
IE developer tool bar : 엘리먼트 선택 도구
Script Debugger : 
Script Editor : MS오피스2007 이하가 설치되어 있어야만 사용할 수 있다.
HttpWatch : 네트워크 확인. HttpWatch 무료 버전에서는 DNS lookup 등 기능 제한. 유료 버전에는 있다.
--
엘리먼트를 확인하는 일이나 스크립트 디버깅은 브라우저의 영향을 많이 받기 때문에 하위 버전의 IE에서 직접하는 것이 좋으며,
프로파일링이나 네트워크 프로파일링은 버전이나 브라우저의 영향을 많이 받지 않으므로 상위 버전의 브라우저나
다른 도구를 이용하는 것이 좋은 방법이다.
/--

<strong>[IE8~9] 디버깅 도구 내장</strong>
디버거를 열어 놓은 상태에서 페이지를 이동하면 브라우저 구동 속도가 느려지므로
디버깅하지 않는다면 반드시 디버거를 끄도록 한다.
이전에는 alert 창이나 document.title 등으로 로그를 확인했지만,
console 객체 사용 가능 : console.log(); console.info(); console.warn(); console.error(); 등은 사용할 수 있다.
<!-- /box1 --></div>

<h3>07. 크롬, 사파리 디버깅</h3>
_7.1 디버깅 도구 실행
_7.2 엘리먼트(Elements) 탭
_7.3 자원 탭(Resources)
_7.4 네트워크 탭(Network)
_7.5 스크립트 탭(Sources)
_7.6 타임라인 탭
_7.7 프로파일 탭 (Profiles)
_7.8 검사 탭 (Audits)
_7.9 콘솔 탭
_7.10 기타 기능
_7._11 기타 설정

<div class="box1"><!-- box1 -->
<strong><strong>[Chrome] [Safari]</strong></strong>
<strong>Elements</strong> 탭
	- Event Listeners
	- DOM Breakpoints
<strong>Network</strong> 탭
<strong>Sources</strong> 탭
	- <b>Breakpoint 설정</b>
	- - 디버깅 하고싶은 라인에 debugger; 키워드를 넣는 방법
	- - 조건 중단 방법 : 라인번호 우클릭 Add Conditional Breakpoint
	- <b>실행 조절</b>
	- - 1) 다음 중단점으로 이동하거나 중단점이 없으면 이어서 실행되는 기능이다. (함수를 건너뛸 때 사용한다.)
	- - 2) 멈춤 상태에서 다음 행으로 이동할 때 사용하는 기능으로 줄별로 확인하고 싶을 때 사용한다.
	- - 3) 두 번째 버튼처럼 다음 행으로 이동하는데, 이동하는 동안 함수를 만나면 함수 안으로 들어간다. 전체 흐름을 확인할 때 사용한다.
	- - 4) 현재 함수에서 벗어나는 기능이다. 디버깅 중 함수 호출이 많은 경우가 있는데, 디버깅이 필요 없는 함수 안으로 들어가면 해당 버튼을 사용해서 벗어날 수 있다.
	- - 5) 중단점을 모두 비활성하거나 활성화할 때 사용한다.
	- <b>멈춘 상태 정보</b>
	- <b>기타 기능</b>
	- - pretty print : 코드에 공백, 개행을 넣어 보기 좋게 한다.
	- - 동적 코드 수정 : 코드 수정 후 [Ctrl+s]. 단, 크롬에서만 가능하고 Pretty print 기능을 사용하면 수정 불가하다.
	- - 수정 히스토리 : 마우스 우버튼 클릭 Local modifications… 선택하면 History 를 볼 수 있다. 특정 시점으로 돌아갈 수도 있다.
<strong>Timeline</strong> 탭
	- 병목 구간 찾기
	- 도구모음
	- - 1) Record : 녹화 시작·종료.
	- - 2) Clear : 로그 삭제.
	- - 3) Filter : ?
	- - 4) Collect Garbage : garbage collector 가 메모리를 바로 회수한다.
	- - 5) Glue asynchronous events of causes : ?
	- 타임라인에 특정 시점을 표시하고 싶다면, console.timeStamp 메서드를 실행해 로그를 남기면 된다.
	- 녹화할 때는 먼저 녹화의 왜곡을 줄이기 위해 가비지 컬렉터를 실행한 후 녹화하는 방법을 추천한다.
	- 녹화가 끝나면.. Events, Frames, Memory 결과 확인 가능.
	- - <b><i>Events</i></b> : 시간의 흐름에 따라 각 이벤트들이 어디서 발생했는지 확인. Loading, Scripting, Rendering, Painting 으로 색상 구분.
	- - - (파랑) Loading : 이미지, XHR 등의 네트워크가 발생하였을 때 시간 표시
	- - - (주황) Scripting : 이벤트, Timer(setTimeout, setInterval) 등이 발생한 시점과 위치 확인
	- - - (보라) Rendering : 스타일 재계산(Recalculate Style), 레이아웃(Layout) 의 시간 표시
	- - - (초록) Painting : 화면에 그려진 시간 표시.
	- - <b><i>Frames</i></b> : 시간의 흐름에 따라 프레임별 그룹 지어 확인.
	- - <b><i>Memory</i></b> : 시간의 흐름에 따른 메모리 크기 그래프 확인. 메모리
	- - - 메모리 타임라인 : 줄지 않고 늘어나기만 한다면 해당 웹페이지는 메모리 누수가 발생하고 있음을 추정할 수 있다.
	- - - 이벤트 타임라인 : [m] RECORDS 영역. 
	- - - 엘리먼트 타임라인 :  [m] COUNTERS 영역. Document, DOM Node, Event Listener 의 개수 추이를 확인할 수 있다.
	      일반적으로 돔 노드가 많이 늘어날 때 메노리 사용량이 증가한다.
	실제로 사용해 보면 병목 현상이나 소스 코드에서 디버깅해야 하는 라인을 찾기에는 제한적인 부분이 있지만, 지속적으로 개선되고 있는 도구이므로 성능 개선을 하는 데 많은 도움을 줄 것이다.
<strong>Profiles</strong> 탭
	프로그램 성능 측정 도구
	- <b>Collect JavaScript CPU Profile</b> : 자바스크립트가 어느 구간에서 실행 시간이 오래 걸렸는지.. 성능을 측정
	- - Self : = Own Time.
	- - Total : = Time.
	- - Function : (program) 은 프로파일하는 동안 전체 시간으로, 대기 시간까지 포함하고 있어 그 밑에 있는 함수부터 확인하면 된다.
	- - 하단 메뉴
	- - - 정렬 : Heavy, Tree
	- - - % : ms 로도 보여준다.
	- - - 눈 : Focus ..
	- - - x : Exclude .. 
	- - - 되돌림 : Restore .. 
	- <b>Collect CSS Selector Profile</b> : 스타일 적용 시간. 적용된 엘리멘트 수 확인. [m] CR.v32 에 없어짐.
<div class="box2" id="efficient-css"><!-- box2 -->
<strong>CSS 선택자 개선 전략</strong> (<a href="http://tinyurl.com/efficient-css/">http://tinyurl.com/efficient-css/</a>)
1) <em>미사용 선택자 삭제</em>. CSS 파일 크기 작아지고, 파싱 성능이 개선된다.
2) 자손이나 자식 선택자 보다는 <em>클래스나 아이디를 사용</em>. 예) ul li a{} ▷ <code>.ordered-list-item{}</code>
    하지만 모든 엘리멘트에 클래스나 아이디를 넣는 것은 불가능하기 때문에 적절히 이용한다.
3) <em>불필요한 선택자 삭제</em>. 예) div#some{} ▷ <code>#some{}</code> [m] <em>주의! div.some{} 는 권장</em>한다.
4) [IE7]이하에서 <em>:hover 를 링크 외에는 사용안함</em>. 사용하면 매우 느리다.  대안) JavaScript 로 onmouseover 구현.
5) 공통(Universal) 선택자 <em>* 를 key 선택자로 사용안함</em>.
6) 브라우저 렌더링 엔진은 CSS 선택자를 가장 <em>오른쪽에서부터 왼쪽 방향으로 선택자를 탐색</em>한 후 적합한 엘리먼트에 스타일을 적용한다.
    이때 가장 우측에 있는 선택자를 키(key) 선택자라고 한다.
    이 키 선택자가 * 와 같은 공통 선택자라면 매칭되는 엘리먼트가 많아서 성능이 느려진다.
    따라서 키 선택자는 특정 클래스와 같이 구체적으로 적는 것이 중요하다.
<!-- /box2 --></div>
	- <b>Take Heap Snapshot</b> : 메모리 측정. [CR]만 지원.
	자바스크립트의 가비지 컬렉터(<i>garbage collector</i>)는 참조하는 곳의 수가 0인 변수들을 적당한 시점에 메모리에서 해제한다.
	만약 참조하는 곳이 하나 이상이라면 가비지 컬렉터에서 메모리를 해제하지 못하기 때문에 그런 변수들이 쌓일수록 프로그램은 무거워진다.
	일반적으로 시간이 지날수록 브라우저가 느려지는 이유는 가비지 컬렉터에서 메모리 회수를 하지 못하기 때문이다.
	이런 현상을 메모리가 누수(<i>memory leak</i>) 라고 표현한다.
	메모리 누수가 발생하는 경우는 거의 동일하기에 크롬에서 확인하고 수정하면 다른 브라우저에서도 개선될 것이다.
	- - Summary view (요약 보기)
		- - - Constructor : 생성자
		- - - Distance : 해당 객체의 깊이
		- - - Objects Count : 인스턴스의 개수
		- - - Shallow Size : 자신의 메모리 크기
		- - - Retained Size : 자신의 크기는 물론 참조하고 있는 곳까지 모두 합한 크기다. Retained Size 가 큰 생성자를 찾아서 해제하면 성능이 개선된다.
		찾는 과정에서 () 안에 있는 생성자나 Object, Array 를 비롯하여 내가 만든 생성자가 아닌 경우는 제외하고 확인하는 게 좋다.
	- - Comparison view (비교 보기)
		두 개의 스냅샷을 찍어 두 스냅샷 사이의 메모리 변화 확인.
		개발하다가 특정 시점 이후에 느려진다면 특정 시점 전후로 스냅샷을 찍어 어느 인스턴스가 늘어나고 줄었는지 확인하면 개선하는데 도움을 준다.
	- - Containment view (전체 보기)
		전체 변수나 객체 정보, 클로저, iframe 에 대한 정보를 자세히 확인 가능
	- - 돔으로 인한 메모리 누수 찾기 (Ubcovering DOM Leaks)
		메모리 누수가 발생하는 원인 중 하나인 오프라인 된 DOM을 참조한 곳을 찾아주는 기능을 제공한다.
	- - 도미네티터 보기 (DOMinators view)\
		특정 객체가 참조되고 있는 곳을 확인.
		메모리를 효율적으로 사용하기 위해 객체들의 참조를 끊어 가비지 컬렉터가 회수할 수 있도록 해야 한다.
	- <b>Record Heap Allocations</b> : [m] CR.v32 에 추가됨.

<strong>Resources</strong> 탭
	- Frames : 
	- Web SQL, IndexedDB, localStorage, sessionStorage, Cookie, Application Cache : [CR,SF] 도구에 추가로 제공되는 것들.

<strong>Audits</strong> 탭
	- 현재 페이지에 개선할만한 사항들을 측정하여 추천해 주는 기능이다.
	- 크롬 플러그인 PageSpeed Insights 와 유사하다.

<strong>Console</strong> 탭
	- 스크립트를 바로 실행할 수 있도록 도와주는 기능
	- 이벤트를 모니터링하는 monitorEvents
	<code>monitorEvents("ele");</code> <code>monitorEvents("ele","click");</code>
	- 다른 탭에서 <b>[>≡] Show console. 버튼</b>을 누르면 콘솔 탭을 함께 사용할 수 있다.
	- - Console : 
	- - Search : <em>함수가 어느 파일에 있는지 확인하고 해당 라인으로 이동</em>할 수 있다.
	- - History : 
	
<strong>설정</strong>
	- [기어 아이콘] Settings 으로 실행
	- Disable Cache (캐시 막음)

※ 구글 개발자 도구 문서 : [m] 링크 오류라서 직접 찾아보면.. <a href="https://www.google.co.kr/#newwindow=1&q=%ED%81%AC%EB%A1%AC+%EA%B0%9C%EB%B0%9C%EC%9E%90+%EB%8F%84%EA%B5%AC">크롬 개발자 도구</a>
<!-- /box1 --></div>

<h3>08. 오페라 디버깅</h3>
_8.1 엘리먼트 탭(documents)
_8.2 스크립트 탭(Scripts)
_8.3 네트워크 탭
_8.4 자원 탭(Resources)
_8.5 스토리지 탭(Storage Inspector)
_8.6 에러 로그 탭(Error Log)
_8.7 콘솔 탭(Console)
_8.8 유용한 도구들(Utilities)

<div class="box1"><!-- box1 -->
<strong>Dragonfly</strong> : 디버깅 도구 잠자리는 [Ctrl+Shift+I] 또는 [Opera]-[페이지]-[개발자 도구]-[Opera Dragonfly]로 실행.
<b>Utilities</b> 탭
- Update Screenshot
- Store Color
- Show ruler

오페라는 웹킷 엔진을 사용할 예정이기 때문에 크롬이나 사파리와 유사한 도구가 될 것으로 예상된다.
<!-- /box1 --></div>

<h3>09. 모바일 웹 디버깅</h3>
_9.1 모바일 웹 디버깅 환경
_9.2 데스크톱에서 모바일 디버깅
_9.3 모바일 사파리(Safari) 디버깅 도구
_9.4 JS콘솔 (JSConsole)
_9.5 와이너리(weinre - WEb INspector REmote)
__9.5.1 설치 및 실행 방법
__9.5.2 사용 방법
_9.6 아더울프(Aardwolf)
__9.6.1 설치 및 실행 방법
__9.6.2 사용 방법

<div class="box1"><!-- box1 -->
<strong>JSConsole</strong> : 간단히 스크립트 실행하거나 조작. 실행 환경은 iOS 4.2x 이상, Android 2.2.2 이상, WebOS 이다.
<strong>WEINRE</strong> : node.js 기반 도구. http 만 지원. https 는 지원하지 않는다. (앞으로 지원 예정)
<strong>Aardwolf</strong> : node.js 기반 도구. 중단점 설정 가능. 현재 모바일 스크립트 디버깅 가능한 유일한 도구.
| 아직 도구 불안정. 브라우저 다운 현상. 콜 스택 정확도 낮음.
<!-- /box1 --></div>


III. 성능 개선
전체 코드의 1%도 안 되는 코드가 성능의 90% 이상을 결정짓는 원인이 되는 경우가 많다.
성능 개선 작업은 그 1%도 안 되는 영역을 얼마나 잘 찾느냐가 핵심이다.
<em>클라이언트의 성능</em>을 결정 짓는 곳을 크게 두 가지로 나눠 보면 <em>자바스크립트와 네트워크</em>라고 말할 수 있다.

<h3>10. 다이나트레이스</h3>
_10.1 설치 및 실행 방법
_10.2 시작하기
_10.3 성능 리포트(Performance Report)
__10.3.1 요약 보기(Summary)
__10.3.2 캐시(Cache)
__10.3.3 네트워크(Network)
__10.3.4 서버 성능(Server-Side)
__10.3.5 자바스크립트(JavaScript), Ajax
__10.3.6 타임라인(Timeline)과 주요 성과 지표(KPI-Key Performance Indicator)
_10.4 사용자 경험 리포트(User Experience Report)
_10.5 타임라인(Timeline)
__10.5.1 타임라인 기능
__10.5.2 자바스크립트 개선
__10.5.3 네트워크
_10.6 퓨어패스(PurePaths)
_10.7 핫 스팟(Hot spot)
_10.8 설정 및 기타 기능

<div class="box1"><!-- box1 -->
<a href="http://tinyurl.com/dynaTrace-download/">dynaTrace 다운로드 설치</a>
- [IE] 와 [FF] 에서만 사용할 수 있다.
- [CR] 에서는 Speed Tracer 가 유사한 기능을 제공하는 도구(확장 프로그램).

<strong>자바스크립트 개선</strong>
서능 문제의 초기 원인은 네트워크인 경우가 많지만, 로딩 이후로는 자바스크립트 성능 탓인 경우가 많다.
하지만 자바스크립트가 갖는 성능 문제의 원인은 생각보다 많지 않다.
개발할 때 몇 가지만 주의하면 성능상에 큰 문제가 발생하지는 않을 것이다.

	<b>DOM 접근 줄이기</b>
	자주 사용하는 DOM 은 보관하여 재사용한다.
	단점. DOM 삭제하면 레퍼런스가 남아서 메모리 누수가 발생한다. 개발자 도구 - 프로파일링 탭으로 개선한다.
	동적 노드 리스트(live nodelist : getElementsByTagName(), getElementsByClassName())는 정적 노드 리스트(static nodelist : querySelectorAll())에 비해 성능이 빠르고 엘리먼트가 변경이 되면 바로 반영이 된다.
	(대부분 라이브러리를 사용하여 크게 문제는 없다.)
	적절한 CSS 선택자를 사용한다.
	[IE9~] 최신 브라우저에서는 querySelector() 라는 메서드가 있어 성능 좋고 CSS 선택자 사용법에 따른 영향이 적다.
	[IE6~8] 하위 브라우저에서는 직접 많은 DOM 을 검색하기에, 성능이 CSS 선택자에 영향을 많이 받는다.

	<b>선택자 사용법</b>
<div class="box2"><!-- box2 -->
- <em>아이디로 접근</em>. 예) <code>$('#some_id')</code>
- <em>기준 엘리멘트 지정</em>. 예) <code>$('#some_id .some_class')</code>
- <em>클래스명에 태그 지정</em>. 예) <code>$('div.some_class')</code>
- <em>하위 선택자 짧게</em>. 예) $('.some_class1 div .some_class2') >=> <code>$('.some_class1 .some_class2')</code>
- <em>실행 순서 이해</em>.
- - jQuery : 브라우저에서 CSS 선택자 적용 순서와 동일하게.. 오른쪽에서 왼쪽으로 적용되므로 오른쪽 선택자를 자세히 적는다. 예) $('.parent_class div.child_class')
- - jindo : 반대로 왼쪽에서 오른쪽으로 적용된다. 왼쪽 선택자를 자세히 적는다. 예) $$('div.parent_class .child_class')
- - 양쪽 다 성능 업하려면 : <code>$('div.parent_class div.child_class')</code> 이렇게 구체적으로 적어준다.
<!-- /box2 --></div>

	<b>효율적 DOM 변경</b>
	DOM 변경에는 크게 Repaint 와 Reflow 가 있다.
	- <i class="fwb">Repaint</i> : 색상과 같이 레이아웃애 영향을 미치지 않는 스타일을 변경할 때 발생. 비교적 비용이 적게 드는 편이다.
	- <i class="fwb">Reflow</i> : 돔을 추가, 삭제하거나 위치 값 등을 변경하여 돔의 레이아웃을 재구성하는 작업. 비용이 많이 발생한다.
	따라서 돔과 관련된 작업들은 한 번에 처리하는 것이 좋다. 예)
<xmp class="xmp">
ele.style.cssText = 'top:10px;left:10px;'; // ele.style.top=''; ele.style.left=''; 여러 번 사용말고 한 번에 처리한다.
ele.className = 'some'; // 클래스를 이용하면 더 효율적이다.
ele.innerHTML = '<li class='li1'></li><li class='li2'></li>'; // appendChild(); 여러 번 사용말고 한 번에 처리한다.
</xmp>
	※ <a href="http://tinyurl.com/reflow-repaint/">리플로에 대한 보다 자세한 설명</a>
	※ <a href="http://tinyurl.com/reflow-tip/">리플로 원인과 마크업 최적화에 관해서</a> [m] 링크오류!

	<b>엘리먼트에 최신 값을 가지는 속성을 현명하게 사용하기</b>
	접근할 때 재계산 되는 속성들..
	위치, 크기 속성 (offset…, scroll… client…) 과 getComputedStyle(), currentStyle (인터넷 익스플로러) 
	처음 읽어올 때 시간이 오래 걸리지만, 다시 읽어오면 처음과 달리 읽는 속도가 빨라진다.
	이유는 브라우저가 리플로가 발생할 때 수많은 값을 변경하는 것이 아니라,
	해당 속성을 사용할 때 계산하여 최신 값으로 변경한다.
<xmp class="xmp">
ele,appendChild(eChild);
var offset = ele.offsetTop; // 매우 느림

// 아래와 같이 수정
var offset = ele.offsetTop; // 빠름
ele,appendChild(eChild);
</xmp>

	[Book] 자바스크립트 코딩 기법과 핵심 패턴
	[Book] NHN은 이렇게 한다 자바스크립트 성능 이야기
	[Book] 자바스크립트 성능 최적화

<strong>네트워크 성능 개선</strong>

[Book] 초고속 웹사이트 구축
[Book] 웹사이트 최적화 기법

<b>파일 크기 줄이기</b>
	자바스크립트, CSS, HTML, 이미지
	Content-Encoding : gzip
	UglyfyJS : Node.js 기반. 압축률 높다. 소스 최소화 후 디버깅 도와주는 sourcemap 등 다양한 기능 있다.
	Clean-CSS : CSS 축소.
	도구 사용 시 유의점 : 축소시킨 JS 와 CSS 가 정상적으로 실행되지 않는 경우 발생. 확인 필요하다.
	HTML-minifiler
	<a href="http://www.smushit.com/">Smush.it</a> : 이미지 품질 변경 없이 크기를 줄이는 도구
	-- [m] Test! 해보니.. 저조한 감소이므로 큰 png24 에 이용해보겠다는 기대는 접었다.
	텍스트 png24 -- 파일크기 약 2% 감소.
	비쥬얼 jpg -- 파일크기 약 5% 감소.
	비쥬얼 png24 -- 파일크기 약 3% 감소. /--
<b>네트워크 요청 횟수 줄이기</b>
	파일 합치기
	SpriteMe : 이미지 합치는 도구. 이미지를 무조건 합치기보다는 아이콘이나 배경 위주로 합치고, 의미가 있는 이미지는 접근성과 연관된 부분이므로 합치지 않는 것이 좋다.
	캐시 활용
	최근에는 초반에 사용하는 스크립트만 내려받고, 필요한 스크립트는 사용할 때 서버에서 요청하여 삽입하는 방식(on demand javascript)으로 개발하여 성능을 개선.
<b>적당한 도메인 분리</b>
	각 도메인마다 동시에 내려받을 수 있는 연결 개수는 HTTP1.1 에서 [IE6,7] 2개, [FF2] 2개, [FF3~] 6개, .. 브라우저별로 차이가 있지만 모두 제한적이다.
	도메인 적절하게 나누는 것이 좋다. 실험을 통해서..
	도메인 개수가 너무 많은면 DNS Lookup 시간이 길어져 느려지고, ..
	일부 개발자는 도메인당 내려받는 개수 4개 정도가 적절하다고 보기도 한다.
<b>스크립트 파일은 하단에, 스타일시트 파일은 상단에</b>
	
<strong>퓨어패스(PurePaths)</strong>
	웹페이지에서 일어난 일들이 어떤 경로롤 발생했는지 한눈에 볼 수 있다.

<strong>핫 스팟(Hot spot)</strong>
	자바스크립트의 실행 시간을 기준으로 정렬하여 자바스크립트 성능을 한눈에 확인하고, 병목 현상이 나타나는 지점을 찾아 성능을 개선할 수 있다.
<!-- /box1 --></div>

<h3>11. 웹페이지 테스트</h3>
__11.1 사용 방법 및 주요 기능
__11.2 분석적 검토(Analytical review)
___11.2.1 측정 방법
__11.2.2 테스트 설정(Test Setting)
__11.2.3 고급 설정(Advanced)
__11.2.4 권한(Auth)
__11.2.5 스크립트(Script)
__11.2.6 광고 제거(Block)
__11.2.7 단일 고장점(Single Point Of Failure, SPOF)
__11.2.8 비디오(Video)
__11.3 페이지 측정 및 결과 확인
__11.3.1 요약 보기(Summary)
__11.3.2 상세 보기(Detail)
__11.3.3 성능 리뷰(Performance Review)
__11.3.4 페이지 스피드(Page Speed)
__11.3.5 콘텐츠 분해(Content breakdown)
__11.3.6 도메인(Domain)
_11.4 기타 테스트
__11.4.1 시각적 비교(Visual Comparison)
__11.4.2 모바일(Mobile)
__11.4.3 경로추적(Tracerouter)
__11.4.4 API 활용하기

<div class="box1"><!-- box1 -->
<strong><a href="http://webpagetest.org">WebpageTest.org</a></strong>
<!-- /box1 --></div>

<h3>12. 피들러(Fiddler)</h3>
_12.1 설치하기
_12.2 실행 방법
_12.3 자동 응답(AutoResponder)
__12.3.1 기본 자동 응답 기능
__12.3.2 요청 지연하기
__12.3.3 모바일 자동 응답 기능
__12.3.4 HTTPS 자동 응답 기능
_12.4 필터 기능
__12.4.1 특정 조건 요청만 기록
__12.4.2 중단점(BreakPoint) 설정
_12.5 피들러 스크립트(Rule)
__12.5.1 Global Scope
__12.5.2 이벤트(OnBeforeRequest, onBeforeResponse)
_12.6 자바스크립트 포맷터

<div class="box1"><!-- box1 -->
<strong><a href="http://www.fiddler2.com/fiddler2">Fiddler</a></strong> (<a href="http://www.telerik.com/fiddler">http://www.telerik.com/fiddler</a>) 내려받아 설치한다.
피들러는 컴퓨터와 인터넷 사이의 모든 http(s) 요청을 기록하는 웹 디버깅 프록시(proxy) 도구로, 특정 요청을 다른 요청으로 변경할 때 주로 사용한다.
개발 완료 후 서비스 중인 JS 나 CSS 오류 발견 시 파일을 내려받은 후, 파일에 대한 요청을 로컬 파일로 변경해서 디버깅할 수 있다.

[Any Process] 이걸 끌어서 브라우저 창에 놓으면 해당 브라우저 요청만 기록한다.

[m] 이 후 설명은 뭔말인지..?
<!-- /box1 --></div>

<h3>부록 기타 자바스크립트 개발 도구</h3>

_A 성능 개선 도구
__A.1 스피드 트레이서(Speed Tracer)
__A.2 모바일 성능 북마크릿(Mobile Perf bookmarklet)
__A.3 JSPerf
_B 문서화 도구
__B.1 YUIDOC
_C 압축 도구
__C.1 UglifyJS
__C.2 Clean CSS
__C.3 HTML Compressor
__C.4 해제 도구
_D 테스트 커버리지 도구(Test Coverage Tool)
__D.1 이스탄불(Istanbul) 설치 및 사용 방법
__D.2 결과 확인
_E 정적 코드 검사 도구
__E.1 JSHint
__E.2 CSSLint
_F 빌드 도구(grunt)
__F.1 설치 방법
__F.2 실행 방법

<div class="box1"><!-- box1 -->
<strong><a href="https://developers.google.com/web-toolkit/speedtracer/?hl=ko&csw=1">Speed Tracer</a></strong> 크롬 확장 프로그램 설치한다.
	크롬 개발자 도구를 닫아야 정상적으로 성능을 측정할 수 있다.
	개선할 부분을 색상과 숫자로 표시한다. 빨강(개선 시급), 주황, 초록(비교적 덜 시급).

<strong><a href="http://stevesouders.com/mobileperf/mobileperfbkm.php">Mobile Perf bookmarklet</a></strong> 로 이동하자.
	Installation - DESKTOP: MOBILE: 설명대로 설치하면 된다.
	10가지 기능. 일부 도구는 정상적으로 동작하지 않지만, 가볍게 사용하기 좋은 도구이다.
<div class="box2"><!-- box2 -->
<b>Firebug Lite</b> : 파이어폭스 파이어버그 플러그인을  다른 브라우저에서도 작동하도록 만든 도구
<b>Page Resources</b> : 제이지 자원 확인
<b>Docsource</b> : HTML 소스 보기
<b>Web Timing</b> : 네비게이션 타이밍 확인
<b>DOM Monster</b> : 성능 개선 부분 알려줌
<b>Storager</b> : LocalStroge 와 SessionStorge 값 관리
<b>YSlow</b> : 웹페이지 퍼포먼스 측정 도구
<b>SpriteMe</b> : CSS Sprite 를 사용할 수 있도록 이미지들을 합쳐준다.
<b>CSSess</b> : 사용하지 않은 CSS 를 찾아준다.
Zoompf : 다양한 성능 측정. 현재 사용불가. <a href="http://zoompf.com/">http://zoompf.com/</a> 에 접속해서 사용하자.
<!-- /box2 --></div>
<strong><a href="http://JSPerf.com">JSPerf</a></strong> 로 접속하자.
	Published 옵션 해제하면 외부 개발자가 볼 수 없다.
	[m] 사용법..?

<strong>YUIDOC</strong> node.js 기반
<strong>UglifyJS</strong> node.js 기반
<strong>Clean CSS</strong> node.js 기반
<strong>HTML Compressor</strong> JAVA 기반
	HTML 은 개행이 디자인에 영향을 줄 수 있고, .. 압축 후 반드시 확인 필요.
	YUI Compressor : 자바스크립트와 CSS 를 함께 압축 가능
	Google Closure Copiler : 자바스크립트를 함께 압축 가능
<strong><a href="http://ctrlq.org/beautifier">Code beautifier</a></strong> : 온라인 코드 압축 해제 도구. JS, CSS, HTML 모두 알아서 적절히 해제해준다. <em>[m] HTML 만 되는거 같던데..?</em>
<strong>Istanbul</strong> node.js 기반
<strong>JSHint</strong> node.js 기반
<strong>CSSLint</strong> node.js 기반
<strong>Grunt</strong> node.js 기반
<!-- /box1 --></div>
</pre>



<hr class="show" />
<p>
<strong>History</strong>
20140220.
20140219.
20140218.
</p>





<script src="../../share/inc/all_footer.js"></script>
</body>
</html>