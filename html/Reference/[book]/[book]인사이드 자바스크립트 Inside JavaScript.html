<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<script>/*<![CDATA[*/
var $meta = {
	title: 'Reference - [book]인사이드 자바스크립트 Inside JavaScript | mNote',
	pageType: 'default'
};
/*]]>*/</script>
<script src="../../share/inc/html_head.js"></script>
<script>/*<![CDATA[*/
/* 크롬 콘솔 창 확인바람. */
var a=[];
var o={};
console.dir(a.__proto__);
console.dir(o.__proto__);
/*]]>*/</script>
</head>
<body>
<script src="../../share/inc/all_header.js"></script>







<h1>[book]인사이드 자바스크립트 Inside JavaScript <span style="font-size:14px;"><small>: 핵심 개념과 원리를 정확하게. jQuery, Node.js, 클로저의 개념까지</small></span> </h1>
| <a href="http://www.yes24.com/24/goods/11781589?scode=032&OzSrank=1">View</a>
| <a >Demo</a>
| <a ><a href="http://www.hanbit.co.kr/exam/2065/">Exam</a></a>
| <a >Errata</a>
| <a >[PDF]</a>
| <a >추가정보</a>
<br />
| Read 284p/20h = 14.2/h
<br />
Legend: <strong>Read</strong> <em>Remember</em> <b>Question</b> <i>Answer</i>

<h2 id="Exam">Exam Code</h2>

<div class="box2"><!-- box2 -->
<strong>Progress Chart</strong>
<span class="markingpen1"><!-- markingpen1 -->
| 자바스크립트 기본 개요
| 자바스크립트 개발 환경
| 자바스크립트 데이터 타입과 연산자
| 함수와 프로토타입 체이닝
<span class="fade1">| 실행 컨텍스트와 클로저</span>
<!-- /markingpen1 --></span>
| 객체지향 프로그래밍
| 함수형 프로그래밍
| jQuery 소스 코드 분석
<!-- /box2 --></div>

<pre>
<h3>CHAPTER 1 자바스크립트 기본 개요</h3>
__1.1 소개
__1.2 자바스크립트 활용 범위
____1.2.1 웹 개발
____1.2.2 서버 개발
____1.2.3 애플리케이션 개발
__1.3 자바스크립트의 핵심 개념
____1.3.1 객체
____1.3.2 함수
____1.3.3 프로토타입
____1.3.4 실행 컨텍스트와 클로저
__1.4 자바스크립트와 객체지향 프로그래밍
__1.5 자바스크립트와 함수형 프로그래밍
__1.6 자바스크립트의 단점

<div class="box1"><!-- box1 -->
jQuery, knockout, backbone
Node.js, express, socket.io
웹OS, 크롬OS
PhoneGap
null, undefined 를 제외한 모든 것을 객체로 다룰 수 있다.
함수는 일급 객체
모든 객체는 숨겨진 링크인 프로토타입을 가진다. 이 링크는 해당 객체를 생성한 생성자의 프로토타입 객체를 가리킨다.
실행 컨텍스트, 유효 범위, 클로저
프로토타입 체인과 클로저로 객체지향 프로그래밍에서 제시하는 상속, 캡슐화, 정보 은닉 등의 개념을 소화할 수 있다.
실제로 GOF의 디자인 패턴을 자바스크립트로 구현한 코드들이 많이 공개되어 있다.
함수형 프로그래밍(함수 특성과 클로저를 활용)은 높은 수준의 모듈화가 가능하지만, 이 때문에 가독성을 떨어뜨리기도 한다.
단점1. 느슨한 타입 체크로 인한 디버깅이 어려움.
단점2. 전역 객체의 존재로 충돌의 위험성.
단점3. 1999년 ECMAScript 3 모호성으로 자바스크립트 엔진 차이. 2009년 ECMAScript 5 버전 승인으로 브라우저 독립 코드 구현 간능해져..
C, Java 와는 다르고, 상대적으로 Lisp, Haskell 등의 언어와 비슷한 면이 있다.
<!-- /box1 --></div>

<h3>CHAPTER 2 자바스크립트 개발 환경</h3>
__2.1 웹스톰 설치 및 실행
__2.2 프로젝트 생성 및 프로그래밍
__2.3 테스트 및 디버깅
____2.3.1 테스트
____2.3.2 디버깅

<div class="box1"><!-- box1 -->
통합 IDE 상용 소프트웨어인 Webstorm. 30일 평가판.
웹스톰에서 테스트할 브라우저를 파이어폭스로 정하면.. JetBrains 라는 애드온을 설치해야 한다.
브레이크 포인트를 정하여 디버깅
<!-- /box1 --></div>

<h3>CHAPTER 3 자바스크립트 데이터 타입과 연산자</h3>
__3.1 자바스크립트 기본 타입
____3.1.1 숫자
____3.1.2 문자열
____3.1.3 불린값
____3.1.4 null과 undefined
__3.2 자바스크립트 참조 타입(객체 타입
____3.2.1 객체 생성
____3.2.2 객체 프로퍼티 읽기/쓰기/갱신
____3.2.3 for in 문과 객체 프로퍼티 출력
____3.2.4 객체 프로퍼티 삭제
__3.3 참조 타입의 특성
____3.3.1 객체 비교
____3.3.2 참조에 의한 함수 호출 방식
__3.4 프로토타입
__3.5 배열
____3.5.1 배열 리터럴
____3.5.2 배열의 요소 생성
____3.5.3 배열의 length 프로퍼티
____3.5.4 배열과 객체
____3.5.5 배열의 프로퍼티 동적 생성
____3.5.6 배열의 프로퍼티 열거
____3.5.7 배열 요소 삭제
____3.5.8 Array() 생성자 함수
____3.5.9 유사 배열 객체
__3.6 기본 타입과 표준 메서드
__3.7 연산자
____3.7.1 + 연산자
____3.7.2 typeof 연산자
__3.7.3 == (동등) 연산자와 === (일치) 연산자
__3.7.4 !! 연산자

<div class="box1"><!-- box1 -->
기본 타입 : 숫자, 문자열, 불린값, null, undefined : -- 하나의 값만 가진다.
참조 타입 : 객체 - (배열, 함수, 정규표현식) : -- 여러 개의 프로퍼티를 포함할 수 있다.
[[Prototype]]프로퍼티. 크롬에서는 __proto__ 프로퍼티 형태로 구현되어 있다.
배열은 굳이 크기를 지정하지 않아도 되며, 어떤 위치에 어느 타입의 데이터를 저장하더라도 에러가 발생하지 않는다.
delete arr[2]; // 배열 인덱스 요소의 값을 undefined 로 설정할 뿐, 인덱스 자체는 삭제하지 않으므로 arr.length 는 변함없다.
arr.splice(2,1); // 배열 인덱스 요소를 완전히 없앤다.
유사 배열 객체 : 객체지만 length 프로퍼티를 가지는 객체
유사 배열 객체도 apply() 메서드를 사용하면 객체지만 표준 배열 메서드를 활용하는 것이 가능하다.
기본 타입은 원래 객체가 아닌데.. 메서드 처리 순간에 객체로 변환한 다음 각 타입별 표준 메서드를 호출하고 끝나면 다시 기본값으로 복귀한다.
연산자
+ 연산자는 피연산자가 모두 숫자일 때만 더하기 연산이고 나머지는 문자열 연결이다.
typeof 연산자에서 null 과 배열이 'object' 이고, 함수는 'function'이라는 점에 유의하자.
== 동등 연산자는 타입이 다를 경우 타입 변환을 거친 다음 비교한다.
=== 일치 연산자 타입 변경없이 비교한다. <a href="https://contribute.jquery.org/style-guide/js/">jQuery 코딩 가이드라인</a>에서도 가급적 === 연산자로 비교하기를 권하고 있다.
!! 연산자는 피연산자를 불린값으로 변환한다. 빈 객체라도 true 로 변환되는 것을 주의해야 한다.
<!-- /box1 --></div>

<h3>CHAPTER 4 함수와 프로토타입 체이닝</h3>
__4.1 함수 정의
____4.1.1 함수 리터럴
____4.1.2 함수 선언문 방식으로 함수 생성하기
____4.1.3 함수 표현식 방식으로 함수 생성하기
____4.1.4 Function() 생성자 함수를 통한 함수 생성하기
____4.1.5 함수 호이스팅
__4.2 함수 객체: 함수도 객체다
____4.2.1 자바스크립트에서는 함수도 객체다
____4.2.2 자바스크립트에서 함수는 값으로 취급된다
____4.2.3 함수 객체의 기본 프로퍼티
__4.3 함수의 다양한 형태
____4.3.1 콜백 함수
____4.3.2 즉시 실행 함수
____4.3.3 내부 함수
____4.3.4 함수를 리턴하는 함수
__4.4 함수 호출과 this
____4.4.1 arguments 객체
____4.4.2 호출 패턴과 this 바인딩
____4.4.3 함수 리턴
__4.5 프로토타입 체이닝
____4.5.1 프로토타입의 두 가지 의미
____4.5.2 객체 리터럴 방식으로 생성된 객체의 프로토타입 체이닝
____4.5.3 생성자 함수로 생성된 객체의 프로토타입 체이닝
____4.5.4 프로토타입 체이닝의 종점
____4.5.5 기본 데이터 타입 확장
____4.5.6 프로토타입도 자바스크립트 객체다
____4.5.7 프로토타입 메서드와 this 바인딩
____4.5.8 디폴트 프로토타입은 다른 객체로 변경이 가능하다
____4.5.9 객체의 프로퍼티 읽기나 메서드를 실행할 때만 프로토타입 체이닝이 동작한다

<div class="box1"><!-- box1 -->
<strong>함수 선언문</strong> (Function Statement) -- 기명 함수로 함수 리터럴 형태와 같다.
<strong>함수 표현식</strong> (Function Expression) -- 일반적으로 익명 함수를 변수에 할당하여 생성한다.
기명 함수 표현식 --
<code class="xmp">
var add = function sum(x, y) { // 함수 변수 add, 함수 이름 sum
	return x + y;
}
add(3,4); // 출력값 7
sum(3,4); // 출력값 Uncaught ReferenceError : sum is not defined 에러 발생  -- 함수 표현식에서 사용된 함수 이름 sum 이 외부 코드에서 접근 불가능하다.
</code>
생성자 함수를 통한 함수 생성 -- 자주 사용되지 않는다.
<code class="xmp">
var a = new Function('x', 'y', 'return x + y');
</code>

<strong>함수 호이스팅</strong> (Function Hoisting) -- 함수 선언문 형태로 정의한 함수의 유효 범위는 코드의 맨 처음부터 시작한다.
더글러스 크럭포드는 이러한 함수 호이스팅은 함수를 사용하기 전에 반드시 선언해야 한다는 규칙을 무시하므로 코드의 구조를 엉성하게 만들 수도 있다고 지적하며,
함수 표현식 사용을 권장하고 있다.
함수는 일급 객체다.

<strong>프로토타입 객체 [[Prototype]] _proto_</strong>
<i class="ic">prototype 프로퍼티와 [[Prototype]] 프로퍼티</i>
두 프로퍼티 모두 프로토타입 객체를 가리킨다는 점에서는 공통점이 많지만, 관점에 차이가 있다.
모든 객체에 있는 내부 프로퍼티인 [[Prototype]] 는 객체 입장에서 자신의 부모 역할을 하는 프로토타입 객체를 가리키는 반면에,
함수 객체가 가지는 prototype 프로퍼티 는 이 함수가 생성자로 사용될 때 이 함수를 통해 생성된 객체의 부모 역할을 하는 프로토타입 개체를 가리킨다.

<strong>콜백 함수</strong> : 코드를 통해 명시적으로 호출하는 함수가 아니라, 개발자는 단시 함수를 등록하기만 하고, 어떤 이벤트가 발생했거나 특정 시점에 도달했을 때 시스템에서 호출하는 함수를 말한다. 또한, 특정 함수의 인자로 넘겨서, 코드 내부에서 호출되는 함수 또한 콜백 함수가 될 수 있다.
<strong>즉시 실행 함수</strong> : 최초 한 번의 실행만을 필요로 하는 초기화 코드 부분 등에 사용할 수 있다.
<strong>함수 스코프(유효 범위)</strong>, <strong>내부 함수</strong>, <strong>스코프 체이닝</strong>
| 내부 함수는 자신을 둘러싼 외부 함수의 변수에 접근 가능하다.
| 내부 함수는 일반적으로 자신이 정의된 부모 함수 내부에서만 호출이 가능하다.
하지만, 부모 함수에서 내부 함수를 외부로 리턴하면, 부모 함수 밖에서도 내부 함수를 호출하는 것이 가능하다.
<code class="xmp">
function parent(){
	var a = 100;
	var child = function(){
		console.log(a);
	}
	return child;
}
var inner = parent();
inner();
</code>
<strong>클로저</strong> - p97 -
1) 위 예제에서는 내부 함수를 함수ㅜ 표현식 형식으로 정의하고, child 함수 변수에 저장했다.
그리고 parent() 함수의 리턴값으로 내부 함수의 참조값을 가진 child 함수 변수를 리턴했다.
2) parent() 함수가 호출되면, inner 변수에 child 함수 변수 값이 리턴된다.
child 함수 변수는 내부 함수의 참조값이 있으므로, 결국 inner 변수도 child() 내부 함수를 참조한다.
3) 때문에 inner 변수에 함수 호출 연산자 ()를 붙여 함수 호출 구문을 만들면, parent() 함수 스코프 밖에서도 내부 함수 child()가 호출된다.
호출하는 내부 함수에는 a 변수가 정의되어 있지 않아, 스코프 체이닝으로 부모 함수에 a 변수가 정의되어 있는지 확인하게 되고, a가 정의되어 있으면 그 값이 그대로 출력된다.
<b>이와 같이 <em>실행이 끝난</em> parent() 와 같은 부모 <em>함수 스코프의 변수를 참조하는</em> inner()와 같은 <em>함수</em>를 클로저라고 한다.</b>

<strong>arguments 객체는 유사 배열 객체</strong> -- 매개변수 개수가 정해지지 않은 함수나, 전달된 인자의 개수에 따라 서로 다른 처리를 해줘야 하는 함수를 개발하는 데 유용하게 사용할 수 있다.
자바스크립트에서 함수를 호출할 때 기존 매개변수로 전달되는 인자값에 더해, arguments 객체 및 this 인자가 함수 내부로 암묵적으로 전달된다.
함수 호출 패턴에 따라 this 가 다른 객체를 참조한다. (this 바인딩)
객체의 메서드 호출할 때 this 는 자신을 호출한 객체에 바인딩된다.
함수를 호출할 때 this 는 전역 객체에 바인딩된다. 브라우저에서 자바스크립트를 실행하면 window 객체가 된다.
내부 함수를 호출했을 경우에도 마찬가지이므로 부모 함수의 this 를 내부함수가 접근 가능한 다른 변수에 저장하는 방법이 사용된다.
관례상 <code>var that = this;</code> 와 같이 한다.
this 바인딩의 한계를 극복하려고, this 바인딩을 명시적으로 할 수 있도록 call 과 apply 메서드를 제공한다.
기존 함수에 new 연산자를 붙여서 호출하면 해당 함수는 생성자 함수로 동작한다.
특정 함수가 생성자 함수로 정의되어 있음을 알리려고 함수 이름의 첫 문자를 대문자로 쓰기를 권하고 있다.
강제로 인스턴스 생성하기 -- 생성자 함수인데 new 를 사용해서 호출하지 않을 경우 코드의 에러가 발생할 수 있으므로, new 로 호출하도록 사용하는 패턴.
if(!(this instanceof arguments.callee))
…

<strong>명시적인 this 바인딩</strong>
<code class="xmp">
생성자함수명.<b>apply</b>(foo, ['foo', 30, 'main']);
생성자함수명.<b>call</b>(foo, 'foo', 30, 'main');
var args = Array.prototype.slice.apply(arguments); // 유사 배열 객체 arguments 에서 배열 메서드 사용
</code>

<strong>함수 리턴</strong>
일반 함수나 메서드는 리턴값을 지정하지 않을 경우, undefined 값이 리턴된다.
생성자 함수에서 리턴값을 지정하지 않을 경우 생성된 객체가 리턴된다.
생성자 함수의 리턴값으로 넘긴 값이 객체가 아닌 불린, 숫자, 문자열의 경우는 이러한 리턴값을 무시하고 this 로 바인딩된 객체가 리턴된다.

<strong>프로토타입 체이닝</strong>
자바와 같은 객체지향 프로그래밍에서는 클래스를 정의하고 이를 통해 객체를 생성하지만, 자바스크립트에서는 이러한 클래스 개념이 없다.
대신에 객체 리터럴이나 앞서 설명했던 생성자 함수로 객체를 생성한다.
이렇게 생성된 객체의 부모 객체가 바로 바로 <strong>프로토타입 객체</strong>다.

<code class="xmp">
console.dir(myFunction);
console.dir(myFunction.prototype);
console.dir(myFunction.prototype.constructor);
</code>

hasOwnProperty() 메서드 : 이 메서들 호출한 객체에 인자로 넘긴 문자열 이름의 프로퍼티나 메서드가 있는지 체크하는 자바스크립트 표준 API 함수다.

자바스크립트에서 특정 객체의 프로퍼티나 메서드에 접근하려고 할 때, 해당 객체에 접근하려는 프로퍼티 또는 메서드가 없다면 <b>[[Prototype]]링크</b>를 따라 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티를 차례대로 검색하는 것을 <b>프로토타입 체이닝</b> 이라고 말한다.

Object.prototype 객체는 <b>프로토타입 체이닝의 종점</b>이다.

<strong>console.dir(Object);</strong> -- [m] 크롬 콘솔에서 확인하면.. 모든 이치를 느껴볼 수 있을 것이다!!

자바스크립트는 Object.prototype, String.prototype 등과 같이 표준 빌트인 프로토타입 객체에도 사용자가 직접 정의한 메서드들을 추가하는 것을 허용한다.
<code class="xmp">
String.prototype.testMethod = function(){ … };
</code>

프로토타입 객체도 일반 객체처럼 동적으로 프로퍼티를 추가/삭제하는 것이 가능하다.
이렇게 변경된 프로퍼티는 실시간으로 프로토타입 체이닝에 반영된다.
<code class="xmp">
function Person(name){ };
var foo = new Person('foo');
Person.prototype.sayHello = function(){ … };
foo.sayHello();
</code>
<!-- /box1 --></div>

<h3>CHAPTER 5 실행 컨텍스트와 클로저</h3>
__5.1 실행 컨텍스트 개념
__5.2 실행 컨텍스트 생성 과정
____5.2.1 활성 객체 생성
____5.2.2 arguments 객체 생성
____5.2.3 스코프 정보 생성
____5.2.4 변수 생성
____5.2.5 this 바인딩
____5.2.6 코드 실행
__5.3 스코프 체인
____5.3.1 전역 실행 컨텍스트의 스코프 체인
____5.3.2 함수를 호출한 경우 생성되는 실행 컨텍스트의 스코프 체인
__5.4 클로저
____5.4.1 클로저의 개념
____5.4.2 클로저의 활용
____5.4.3 클로저를 활용할 때 주의사항

<div class="box1"><!-- box1 -->
[m] <a href="http://dic.daum.net/word/view_example.do?wordid=ekw000036747&q=context" target="_blank">Context 사전 의미?</a> 1. <b>문맥</b> ; 전후 관계, <em>맥락</em>, 흐름. 2. <b>상황</b> ; 정황, 조건, <em>환경</em>.
<strong>실행 컨텍스트 Execution Context</strong>
<b>콜 스택 Call Stack</b> : C언어 등 고급 프로그래밍 언어에서 함수를 호출할 때 해당 함수의 호출 정보(함수 내 지역변수, 인자값 등)가 차곡차곡 쌓여있는 <em>스택</em>을 의미한다.
자바스크립트 역시 이 범주를 크게 벗어나지 않는다.
<b>실행 컨텍스트</b> : 콜 스택에 들어가는 실행 정보 하나와 비슷하다.
실행 가능한 코드를 형상화하고 구분하는 추상적인 개념. (실행 가능한 자바스크립트 코드 블록이 실행되는 <em>환경</em>)
실행 가능한 코드 블록은 대부분의 경우 함수가 된다.
실행 컨텍스트가 형성되는 경우를 세 가지로 규정한다.
- 전역 코드
- eval() 함수로 실행되는 코드
- 함수 안의 코드를 실행할 경우
제일 위<sup>top</sup> 에 위치하는 실행 컨텍스트가 현재 실행되고 있는 컨텍스트다.
ECMAScript 에서는 실행 컨텍스트의 생성을 다음처럼 설명한다.
<b>"현재 실행되는 컨텍스트에서 이 컨텍스트와 관련 없는 실행 코드가 실행되면, 새로운 컨텍스트가 생성되어 스택에 들어가고 제어권이 그 컨텍스트로 이동한다."</b>
<b>전역 실행 컨텍스트</b> : 가정 먼저 실행되는 컨텍스트. 다른 실행 컨텍스트와 다른 점은..
arguments 객체가 없으며, 전역 객체 하나만을 포함하는 스코프 체인이 있다.

<strong>활성 객체 Activation Object</strong> ( = <strong>변수 객체 Variable Object</strong>)
실행 컨텍스트가 생성되면 자바스크립트 엔진은 해당 컨텍스트에서 실행에 필요한 여러 가지 정보를 담을 활성 객체를 생성한다.
이 객체는 앞으로 매개변수나 사용자가 정의한 변수 및 객체를 저장하고, 새로 만들어진 컨텍스트로 접근 가능하게 되어 있다.
이는 엔진 내부에서 접근할 수 있다는 것이지 사용자가 접근할 수 있는 것은 아니다.
활성 객체가 변수 객체로 사용된다.
우리가 자바스크립트 문서를 읽다 보면 어떤 곳에서는 활성 객체, 어떤 곳에서는 변수 객체라고 사용되어 혼란스러운 경우가 있는데..
두 객체가 같은 객체이므로, 혼동하는 일이 없기를 바란다.

<code class="xmp">
function execute(parm1, parm2){
	var a = 1, b = 2;
	function func(){
		return a + b;
	}
	return parm1 + parm2 + func();
}
execute(3, 4);
</code>

arguments 객체 생성 >> 스코프 정보 생성 >> 변수 생성 >> this 바인딩 >> 코드 실행

<div class="box3 tac"><!-- box3 -->
<div><b>실행 컨텍스트</b></div>
<div class="box2"><!-- box2 -->
<div class="bd1 pd05em bgf" style="width:33.3%;margin:-2.5em auto 0;"><b>활성 객체 ( = 변수 객체 )</b></div>
<table class="wsn" style="margin:0 auto;border-collapse:separate;border-spacing:5px;">
<col style="width:45%;" /><col style="" /><col style="width:45%;" />
<tr>
<td class="bd1 tac">arguments</td>
<td>→</td>
<td class="bd1 pd05em tac">[parm1, parm2]</td>
</tr>
<tr>
<td class="bd1 pd05em tac">[[scope]](스코프체인)</td>
<td>→</td>
<td class="bd1 pd05em tac">[List]</td>
</tr>
<tr>
<td class="bd1 pd05em tac">parm1: value</td>
<td></td>
<td class="bd1 pd05em tac">parm2: value</td>
</tr>
<tr>
<td class="bd1 pd05em tac">a : undefined</td>
<td></td>
<td class="bd1 pd05em tac">b : undefined</td>
</tr>
<tr>
<td class="bd1 pd05em tac">func</td>
<td>→</td>
<td class="bd1 pd05em tac">Function Object</td>
</tr>
<tr>
<td class="bd1 pd05em tac">this</td>
<td>→</td>
<td class="bd1 pd05em tac">Object</td>
</tr>
</table>
<!-- /box2 --></div>
<!-- /box3 --></div>
<div class="mnote1">
브라우저에서는 최상위 코드가 곧 전역 코드지만, Node.js 에서는 다르다.
브라우저에서는 최상위에서 var a 정의한 변수가 전역 객체인 window 의 한 프로퍼티로 들어간다.
Node.js 에서는 일반적인 자바스크립트 파일, 이를테면 filename.js 가 하나의 모듈로 동작하고 이 파일의 최상위에 var a 로 변수를 선언해도 그 모듈의 지역 변수가 된다.
var 를 사용하지 않을 경우 전역 객체인 global 에 들어가고, 이는 전역 객체를 오염시키는 원인이 되므로 주의해야 한다.
</div>

<em>[m] 이걸 알아야 하는 이유가 무엇인가?</em>

<strong>스코프 체인 Scope Chain</strong>

C 는 함수 뿐 아니라 if, for 문의 { } 블록도 유효범위다.
JS 오직 함수만이 유효범위의 한 단위가 된다.

자바스크립트에는 스코프 체인을 사용자가 임의로 수정하는 키워드가 있는데, 이것이 with 이다.
with 는 eval 과 함께, 성능을 높이고자 하는 경우에는 사용하지 말아야 할 키워드다.
함수 호이스팅

<strong>클로저 Closure</strong>
이미 생명 주기가 끝난 외부 함수의 변수를 참조하는 함수를 클로저라고 한다.
<code class="xmp">
function outerFunc(){
	var x = 1; // 자유 변수
	return function(){ // 클로저
		/* x 와 arguments 를 활용한 로직 */
	}
}

var new_func = outerFunc();

/* outerFunc 실행 컨텍스트가 끝났다. */

new_func();
</code>

<strong>클로저의 활용</strong>
<p><em>[m] for 문의 최종값 할당되는거를 해결할 수 있다.</em></p>
<!-- /box1 --></div>

<h3>CHAPTER 6 객체지향 프로그래밍</h3>
__6.1 클래스, 생성자, 메서드
__6.2 상속
____6.2.1 프로토타입을 이용한 상속
____6.2.2 클래스 기반의 상속
__6.3 캡슐화
__6.4 객체지향 프로그래밍 응용 예제
____6.4.1 클래스의 기능을 가진 subClass 함수
____6.4.2 subClass 함수와 모듈 패턴을 이용한 객체지향 프로그래밍

<h3>CHAPTER 7 함수형 프로그래밍</h3>
__7.1 함수형 프로그래밍의 개념
__7.2 자바스크립트에서의 함수형 프로그래밍
____7.2.1 배열의 각 원소 총합 구하기
____7.2.2 팩토리얼
____7.2.3 피보나치 수열
__7.3 자바스크립트에서의 함수형 프로그래밍을 활용한 주요 함수
____7.3.1 함수 적용
____7.3.2 커링
____7.3.3 bind
____7.3.4 래퍼
____7.3.5 반복 함수

<h3>CHAPTER 8 jQuery 소스 코드 분석</h3>
__8.1 jQuery 1.0 소스 코드 구조
____8.1.1 jQuery 함수 객체
____8.1.2 변수 $를 jQuery() 함수로 매핑
____8.1.3 jQuery.prototype 객체 변경
____8.1.4 객체 확장 - extend() 메서드
____8.1.5 jQuery 소스 코드의 기본 구성 요소
__8.2 jQuery의 id 셀렉터 동작 분석
____8.2.1 $(“#myDiv”) 살펴보기
____8.2.2 $(“#myDiv”).text() 살펴보기
__8.3 jQuery 이벤트 핸들러 분석
____8.3.1 jQuery 이벤트 처리 예제
____8.3.2 .click() 메서드 정의
____8.3.3 $(‘#clickDiv’).click() 호출 코드 분석
____8.3.4 $(‘#clickDiv’).bind() 메서드 분석
____8.3.5 Click 이벤트 핸들러 실행 과정
____8.3.6 jQuery 이벤트 핸들러 특징 __2.1 웹스톰 설치 및 실행
</pre>





<hr class="show" />
<p>
<strong>History</strong>
20130207.
20130205.
</p>





<script src="../../share/inc/all_footer.js"></script>
</body>
</html>